/* tslint:disable */
/* eslint-disable */
/**
 * JAPM API
 * API para la aplicación de Prompt Engineering JAPM
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AssetVersionLinkDto
 */
export interface AssetVersionLinkDto {
    /**
     * ID de la PromptAssetVersion a vincular.
     * @type {string}
     * @memberof AssetVersionLinkDto
     */
    'assetVersionId': string;
    /**
     * Contexto de uso (opcional).
     * @type {string}
     * @memberof AssetVersionLinkDto
     */
    'usageContext'?: string;
    /**
     * Posición/orden (opcional).
     * @type {number}
     * @memberof AssetVersionLinkDto
     */
    'position'?: number;
}
/**
 * 
 * @export
 * @interface CreateAiModelDto
 */
export interface CreateAiModelDto {
    /**
     * Unique name for the AI model
     * @type {string}
     * @memberof CreateAiModelDto
     */
    'name': string;
    /**
     * Provider of the AI model
     * @type {string}
     * @memberof CreateAiModelDto
     */
    'provider'?: string;
    /**
     * Optional description for the AI model
     * @type {string}
     * @memberof CreateAiModelDto
     */
    'description'?: string;
    /**
     * Identifier used for API calls
     * @type {string}
     * @memberof CreateAiModelDto
     */
    'apiIdentifier'?: string;
}
/**
 * 
 * @export
 * @interface CreateAssetTranslationDto
 */
export interface CreateAssetTranslationDto {
    /**
     * ID de la versión del asset a la que pertenece esta traducción
     * @type {string}
     * @memberof CreateAssetTranslationDto
     */
    'versionId': string;
    /**
     * Código de idioma para esta traducción (formato xx-XX)
     * @type {string}
     * @memberof CreateAssetTranslationDto
     */
    'languageCode': string;
    /**
     * Valor del asset traducido a este idioma
     * @type {string}
     * @memberof CreateAssetTranslationDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface CreateCulturalDataDto
 */
export interface CreateCulturalDataDto {
    /**
     * ID único para estos datos culturales (formato slug)
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'id': string;
    /**
     * ID de la región asociada (código de idioma xx-XX)
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'regionId': string;
    /**
     * Nivel de formalidad (opcional)
     * @type {number}
     * @memberof CreateCulturalDataDto
     */
    'formalityLevel'?: number;
    /**
     * Estilo de comunicación (opcional)
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'style'?: string;
    /**
     * Consideraciones culturales (opcional)
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'considerations'?: string;
    /**
     * Notas adicionales (opcional)
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface CreateEnvironmentDto
 */
export interface CreateEnvironmentDto {
    /**
     * Nombre único del entorno
     * @type {string}
     * @memberof CreateEnvironmentDto
     */
    'name': string;
    /**
     * Descripción opcional del entorno
     * @type {string}
     * @memberof CreateEnvironmentDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateOrUpdatePromptTranslationDto
 */
export interface CreateOrUpdatePromptTranslationDto {
    /**
     * Código de idioma de la traducción (e.g., es-ES, fr-FR).
     * @type {string}
     * @memberof CreateOrUpdatePromptTranslationDto
     */
    'languageCode': string;
    /**
     * Texto traducido del prompt para esta versión y idioma.
     * @type {string}
     * @memberof CreateOrUpdatePromptTranslationDto
     */
    'promptText': string;
}
/**
 * 
 * @export
 * @interface CreateProjectDto
 */
export interface CreateProjectDto {
    /**
     * Name of the project
     * @type {string}
     * @memberof CreateProjectDto
     */
    'name': string;
    /**
     * Optional description for the project
     * @type {string}
     * @memberof CreateProjectDto
     */
    'description'?: string;
    /**
     * Optional ID of the User who owns this project
     * @type {string}
     * @memberof CreateProjectDto
     */
    'ownerUserId'?: string;
}
/**
 * 
 * @export
 * @interface CreatePromptAssetDto
 */
export interface CreatePromptAssetDto {
    /**
     * Clave única identificadora del asset (e.g., saludo_formal_es)
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'key': string;
    /**
     * Nombre descriptivo del asset
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'name': string;
    /**
     * Tipo de asset (e.g., texto, json, lista)
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'type'?: string;
    /**
     * Descripción más detallada del propósito del asset
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'description'?: string;
    /**
     * Categoría para organizar assets (e.g., Saludos, Despedidas)
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'category'?: string;
    /**
     * Valor inicial del asset para la primera versión (v1.0.0)
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'initialValue': string;
    /**
     * Mensaje de cambio para la primera versión
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'initialChangeMessage'?: string;
    /**
     * ID opcional del proyecto al que pertenece el asset
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'projectId'?: string;
}
/**
 * 
 * @export
 * @interface CreatePromptAssetLinkDto
 */
export interface CreatePromptAssetLinkDto {
    /**
     * ID de la PromptVersion a la que se vincula el asset.
     * @type {string}
     * @memberof CreatePromptAssetLinkDto
     */
    'promptVersionId': string;
    /**
     * ID de la PromptAssetVersion que se vincula.
     * @type {string}
     * @memberof CreatePromptAssetLinkDto
     */
    'assetVersionId': string;
    /**
     * Contexto de uso o propósito de este asset en el prompt.
     * @type {string}
     * @memberof CreatePromptAssetLinkDto
     */
    'usageContext'?: string;
    /**
     * Orden posicional del asset dentro del prompt (si aplica).
     * @type {number}
     * @memberof CreatePromptAssetLinkDto
     */
    'position'?: number;
    /**
     * Lógica de inserción condicional (formato a definir).
     * @type {string}
     * @memberof CreatePromptAssetLinkDto
     */
    'insertionLogic'?: string;
    /**
     * Indica si el asset es requerido para el prompt (default: true).
     * @type {boolean}
     * @memberof CreatePromptAssetLinkDto
     */
    'isRequired'?: boolean;
}
/**
 * 
 * @export
 * @interface CreatePromptAssetVersionDto
 */
export interface CreatePromptAssetVersionDto {
    /**
     * Key (slug) del asset lógico al que pertenece esta versión
     * @type {string}
     * @memberof CreatePromptAssetVersionDto
     */
    'assetId': string;
    /**
     * El valor del asset para esta versión
     * @type {string}
     * @memberof CreatePromptAssetVersionDto
     */
    'value': string;
    /**
     * Etiqueta de versión (e.g., v1.0.0). Debe ser única por asset.
     * @type {string}
     * @memberof CreatePromptAssetVersionDto
     */
    'versionTag'?: string;
    /**
     * Mensaje describiendo los cambios en esta versión.
     * @type {string}
     * @memberof CreatePromptAssetVersionDto
     */
    'changeMessage'?: string;
}
/**
 * 
 * @export
 * @interface CreatePromptDto
 */
export interface CreatePromptDto {
    /**
     * Nombre único del prompt (usado como ID)
     * @type {string}
     * @memberof CreatePromptDto
     */
    'name': string;
    /**
     * Descripción del propósito del prompt.
     * @type {string}
     * @memberof CreatePromptDto
     */
    'description'?: string;
    /**
     * ID (nombre) de la táctica conversacional asociada.
     * @type {string}
     * @memberof CreatePromptDto
     */
    'tacticId'?: string;
    /**
     * Lista de nombres de etiquetas a asociar.
     * @type {Set<string>}
     * @memberof CreatePromptDto
     */
    'tags'?: Set<string>;
    /**
     * Texto base del prompt para la primera versión (v1.0.0)
     * @type {string}
     * @memberof CreatePromptDto
     */
    'promptText': string;
    /**
     * Traducciones iniciales opcionales para la primera versión
     * @type {Array<InitialTranslationDto>}
     * @memberof CreatePromptDto
     */
    'initialTranslations'?: Array<InitialTranslationDto>;
}
/**
 * 
 * @export
 * @interface CreatePromptTranslationDto
 */
export interface CreatePromptTranslationDto {
    /**
     * ID de la versión del prompt a la que pertenece esta traducción
     * @type {string}
     * @memberof CreatePromptTranslationDto
     */
    'versionId': string;
    /**
     * Código de idioma para esta traducción (formato xx-XX)
     * @type {string}
     * @memberof CreatePromptTranslationDto
     */
    'languageCode': string;
    /**
     * Texto del prompt traducido a este idioma
     * @type {string}
     * @memberof CreatePromptTranslationDto
     */
    'promptText': string;
}
/**
 * 
 * @export
 * @interface CreatePromptVersionDto
 */
export interface CreatePromptVersionDto {
    /**
     * Texto BASE del prompt para esta nueva versión.
     * @type {string}
     * @memberof CreatePromptVersionDto
     */
    'promptText': string;
    /**
     * Etiqueta única para esta versión dentro del prompt (e.g., v1.1.0, beta-feature-x).
     * @type {string}
     * @memberof CreatePromptVersionDto
     */
    'versionTag': string;
    /**
     * Mensaje describiendo los cambios en esta versión.
     * @type {string}
     * @memberof CreatePromptVersionDto
     */
    'changeMessage'?: string;
    /**
     * Lista de versiones de assets a vincular a esta versión del prompt.
     * @type {Array<AssetVersionLinkDto>}
     * @memberof CreatePromptVersionDto
     */
    'assetLinks': Array<AssetVersionLinkDto>;
    /**
     * Traducciones iniciales opcionales para esta nueva versión.
     * @type {Array<InitialTranslationDto>}
     * @memberof CreatePromptVersionDto
     */
    'initialTranslations'?: Array<InitialTranslationDto>;
}
/**
 * 
 * @export
 * @interface CreateRagDocumentMetadataDto
 */
export interface CreateRagDocumentMetadataDto {
    /**
     * ID de la región asociada (opcional)
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'regionId'?: string;
    /**
     * Nombre del documento RAG
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'documentName': string;
    /**
     * Categoría (opcional)
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'category'?: string;
    /**
     * Indica si ha sido revisado por compliance
     * @type {boolean}
     * @memberof CreateRagDocumentMetadataDto
     */
    'complianceReviewed'?: boolean;
    /**
     * Nivel de riesgo PII (Información Personal Identificable) (opcional)
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'piiRiskLevel'?: string;
    /**
     * Identificador de quién lo revisó por última vez (opcional)
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'lastReviewedBy'?: string;
}
/**
 * 
 * @export
 * @interface CreateRegionDto
 */
export interface CreateRegionDto {
    /**
     * Código de idioma único que actúa como ID
     * @type {string}
     * @memberof CreateRegionDto
     */
    'languageCode': string;
    /**
     * Nombre de la región
     * @type {string}
     * @memberof CreateRegionDto
     */
    'name': string;
    /**
     * languageCode de la región padre (opcional)
     * @type {string}
     * @memberof CreateRegionDto
     */
    'parentRegionId'?: string;
    /**
     * Zona horaria
     * @type {string}
     * @memberof CreateRegionDto
     */
    'timeZone'?: string;
    /**
     * Nivel de formalidad por defecto (opcional)
     * @type {string}
     * @memberof CreateRegionDto
     */
    'defaultFormalityLevel'?: string;
    /**
     * Notas adicionales (opcional)
     * @type {string}
     * @memberof CreateRegionDto
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface CreateTacticDto
 */
export interface CreateTacticDto {
    /**
     * Nombre único de la táctica (formato slug: minúsculas, guiones)
     * @type {string}
     * @memberof CreateTacticDto
     */
    'name': string;
    /**
     * Código de idioma de la región asociada (e.g., es-ES, opcional)
     * @type {string}
     * @memberof CreateTacticDto
     */
    'regionId'?: string;
    /**
     * ID (slug) de los datos culturales asociados (opcional)
     * @type {string}
     * @memberof CreateTacticDto
     */
    'culturalDataId'?: string;
    /**
     * Configuración específica de la táctica en formato JSON (opcional)
     * @type {object}
     * @memberof CreateTacticDto
     */
    'tacticsConfig'?: object;
    /**
     * ID del proyecto al que pertenece la táctica.
     * @type {string}
     * @memberof CreateTacticDto
     */
    'projectId'?: string;
}
/**
 * 
 * @export
 * @interface CreateTagDto
 */
export interface CreateTagDto {
    /**
     * Nombre único de la etiqueta
     * @type {string}
     * @memberof CreateTagDto
     */
    'name': string;
    /**
     * Descripción opcional de la etiqueta
     * @type {string}
     * @memberof CreateTagDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * Nombre del usuario
     * @type {string}
     * @memberof CreateUserDto
     */
    'name'?: string;
    /**
     * Email único del usuario
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * Contraseña del usuario
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CulturalDataResponse
 */
export interface CulturalDataResponse {
    /**
     * ID único para estos datos culturales (formato slug)
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'id': string;
    /**
     * ID de la región asociada (código de idioma xx-XX)
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'regionId': string;
    /**
     * Nivel de formalidad (opcional)
     * @type {number}
     * @memberof CulturalDataResponse
     */
    'formalityLevel'?: number;
    /**
     * Estilo de comunicación (opcional)
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'style'?: string;
    /**
     * Consideraciones culturales (opcional)
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'considerations'?: string;
    /**
     * Notas adicionales (opcional)
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'notes'?: string;
    /**
     * 
     * @type {CreateRegionDto}
     * @memberof CulturalDataResponse
     */
    'region': CreateRegionDto;
    /**
     * 
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface ExecuteLlmDto
 */
export interface ExecuteLlmDto {
    /**
     * ID del AIModel a utilizar (de la tabla AIModel)
     * @type {string}
     * @memberof ExecuteLlmDto
     */
    'modelId': string;
    /**
     * El texto completo del prompt ya procesado y listo para enviar al LLM
     * @type {string}
     * @memberof ExecuteLlmDto
     */
    'promptText': string;
    /**
     * Variables originales usadas para ensamblar el prompt (opcional, para logging/contexto)
     * @type {object}
     * @memberof ExecuteLlmDto
     */
    'variables'?: object;
}
/**
 * 
 * @export
 * @interface ExecutePromptBodyDto
 */
export interface ExecutePromptBodyDto {
    /**
     * 
     * @type {object}
     * @memberof ExecutePromptBodyDto
     */
    'variables': object;
}
/**
 * 
 * @export
 * @interface HealthControllerCheck200Response
 */
export interface HealthControllerCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'info'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'error'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'details'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface HealthControllerCheck200ResponseInfoValue
 */
export interface HealthControllerCheck200ResponseInfoValue {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200ResponseInfoValue
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface HealthControllerCheck503Response
 */
export interface HealthControllerCheck503Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck503Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'info'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'error'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'details'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface InitialTranslationDto
 */
export interface InitialTranslationDto {
    /**
     * Código de idioma ISO (e.g., es, en)
     * @type {string}
     * @memberof InitialTranslationDto
     */
    'languageCode': string;
    /**
     * Texto traducido del prompt
     * @type {string}
     * @memberof InitialTranslationDto
     */
    'promptText': string;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * User email address
     * @type {string}
     * @memberof LoginDto
     */
    'email': string;
    /**
     * User password
     * @type {string}
     * @memberof LoginDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface RagDocumentMetadataResponse
 */
export interface RagDocumentMetadataResponse {
    /**
     * ID de la región asociada (opcional)
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'regionId'?: string;
    /**
     * Nombre del documento RAG
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'documentName': string;
    /**
     * Categoría (opcional)
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'category'?: string;
    /**
     * Indica si ha sido revisado por compliance
     * @type {boolean}
     * @memberof RagDocumentMetadataResponse
     */
    'complianceReviewed'?: boolean;
    /**
     * Nivel de riesgo PII (Información Personal Identificable) (opcional)
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'piiRiskLevel'?: string;
    /**
     * Identificador de quién lo revisó por última vez (opcional)
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'lastReviewedBy'?: string;
    /**
     * 
     * @type {CreateRegionDto}
     * @memberof RagDocumentMetadataResponse
     */
    'region'?: CreateRegionDto;
    /**
     * 
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface RegisterDto
 */
export interface RegisterDto {
    /**
     * User email address
     * @type {string}
     * @memberof RegisterDto
     */
    'email': string;
    /**
     * User password
     * @type {string}
     * @memberof RegisterDto
     */
    'password': string;
    /**
     * User full name
     * @type {string}
     * @memberof RegisterDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TacticResponse
 */
export interface TacticResponse {
    /**
     * 
     * @type {string}
     * @memberof TacticResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TacticResponse
     */
    'tacticsConfig'?: string;
    /**
     * 
     * @type {CreateRegionDto}
     * @memberof TacticResponse
     */
    'region'?: CreateRegionDto;
    /**
     * 
     * @type {CreateCulturalDataDto}
     * @memberof TacticResponse
     */
    'culturalData'?: CreateCulturalDataDto;
    /**
     * 
     * @type {string}
     * @memberof TacticResponse
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface UpdateAiModelDto
 */
export interface UpdateAiModelDto {
    /**
     * Unique name for the AI model
     * @type {string}
     * @memberof UpdateAiModelDto
     */
    'name'?: string;
    /**
     * Provider of the AI model
     * @type {string}
     * @memberof UpdateAiModelDto
     */
    'provider'?: string;
    /**
     * Optional description for the AI model
     * @type {string}
     * @memberof UpdateAiModelDto
     */
    'description'?: string;
    /**
     * Identifier used for API calls
     * @type {string}
     * @memberof UpdateAiModelDto
     */
    'apiIdentifier'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAssetTranslationDto
 */
export interface UpdateAssetTranslationDto {
    /**
     * Valor del asset traducido a este idioma
     * @type {string}
     * @memberof UpdateAssetTranslationDto
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCulturalDataDto
 */
export interface UpdateCulturalDataDto {
    /**
     * Nivel de formalidad (opcional)
     * @type {number}
     * @memberof UpdateCulturalDataDto
     */
    'formalityLevel'?: number;
    /**
     * Estilo de comunicación (opcional)
     * @type {string}
     * @memberof UpdateCulturalDataDto
     */
    'style'?: string;
    /**
     * Consideraciones culturales (opcional)
     * @type {string}
     * @memberof UpdateCulturalDataDto
     */
    'considerations'?: string;
    /**
     * Notas adicionales (opcional)
     * @type {string}
     * @memberof UpdateCulturalDataDto
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface UpdateEnvironmentDto
 */
export interface UpdateEnvironmentDto {
    /**
     * Nuevo nombre único del entorno (opcional)
     * @type {string}
     * @memberof UpdateEnvironmentDto
     */
    'name'?: string;
    /**
     * Nueva descripción opcional del entorno
     * @type {string}
     * @memberof UpdateEnvironmentDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProjectDto
 */
export interface UpdateProjectDto {
    /**
     * Name of the project
     * @type {string}
     * @memberof UpdateProjectDto
     */
    'name'?: string;
    /**
     * Optional description for the project
     * @type {string}
     * @memberof UpdateProjectDto
     */
    'description'?: string;
    /**
     * Optional ID of the User who owns this project
     * @type {string}
     * @memberof UpdateProjectDto
     */
    'ownerUserId'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePromptAssetDto
 */
export interface UpdatePromptAssetDto {
    /**
     * Nombre descriptivo del asset
     * @type {string}
     * @memberof UpdatePromptAssetDto
     */
    'name'?: string;
    /**
     * Tipo de asset (e.g., texto, json, lista)
     * @type {string}
     * @memberof UpdatePromptAssetDto
     */
    'type'?: string;
    /**
     * Descripción más detallada del propósito del asset
     * @type {string}
     * @memberof UpdatePromptAssetDto
     */
    'description'?: string;
    /**
     * Categoría para organizar assets (e.g., Saludos, Despedidas)
     * @type {string}
     * @memberof UpdatePromptAssetDto
     */
    'category'?: string;
    /**
     * Activa o desactiva el asset
     * @type {boolean}
     * @memberof UpdatePromptAssetDto
     */
    'enabled'?: boolean;
    /**
     * ID opcional del proyecto al que pertenece el asset (null para desvincular)
     * @type {string}
     * @memberof UpdatePromptAssetDto
     */
    'projectId'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdatePromptAssetLinkDto
 */
export interface UpdatePromptAssetLinkDto {
    /**
     * Contexto de uso o propósito de este asset en el prompt.
     * @type {string}
     * @memberof UpdatePromptAssetLinkDto
     */
    'usageContext'?: string;
    /**
     * Orden posicional del asset dentro del prompt (si aplica).
     * @type {number}
     * @memberof UpdatePromptAssetLinkDto
     */
    'position'?: number;
    /**
     * Lógica de inserción condicional (formato a definir).
     * @type {string}
     * @memberof UpdatePromptAssetLinkDto
     */
    'insertionLogic'?: string;
    /**
     * Indica si el asset es requerido para el prompt (default: true).
     * @type {boolean}
     * @memberof UpdatePromptAssetLinkDto
     */
    'isRequired'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdatePromptAssetVersionDto
 */
export interface UpdatePromptAssetVersionDto {
    /**
     * Nuevo valor/contenido del asset para esta versión.
     * @type {string}
     * @memberof UpdatePromptAssetVersionDto
     */
    'value'?: string;
    /**
     * Nuevo mensaje describiendo los cambios.
     * @type {string}
     * @memberof UpdatePromptAssetVersionDto
     */
    'changeMessage'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePromptDto
 */
export interface UpdatePromptDto {
    /**
     * Nueva descripción del propósito del prompt.
     * @type {string}
     * @memberof UpdatePromptDto
     */
    'description'?: string;
    /**
     * ID de la táctica a asociar, o null para desasociar.
     * @type {string}
     * @memberof UpdatePromptDto
     */
    'tacticId'?: string | null;
    /**
     * Lista completa de IDs de etiquetas a asociar (reemplaza las existentes). Array vacío para quitar todas.
     * @type {Array<string>}
     * @memberof UpdatePromptDto
     */
    'tagIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdatePromptTranslationDto
 */
export interface UpdatePromptTranslationDto {
    /**
     * Texto del prompt traducido a este idioma
     * @type {string}
     * @memberof UpdatePromptTranslationDto
     */
    'promptText'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePromptVersionDto
 */
export interface UpdatePromptVersionDto {
    /**
     * Texto BASE del prompt para esta nueva versión.
     * @type {string}
     * @memberof UpdatePromptVersionDto
     */
    'promptText'?: string;
    /**
     * Mensaje describiendo los cambios en esta versión.
     * @type {string}
     * @memberof UpdatePromptVersionDto
     */
    'changeMessage'?: string;
    /**
     * Lista de versiones de assets a vincular a esta versión del prompt.
     * @type {Array<AssetVersionLinkDto>}
     * @memberof UpdatePromptVersionDto
     */
    'assetLinks'?: Array<AssetVersionLinkDto>;
    /**
     * Traducciones iniciales opcionales para esta nueva versión.
     * @type {Array<InitialTranslationDto>}
     * @memberof UpdatePromptVersionDto
     */
    'initialTranslations'?: Array<InitialTranslationDto>;
}
/**
 * 
 * @export
 * @interface UpdateRegionDto
 */
export interface UpdateRegionDto {
    /**
     * Nombre de la región
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'name'?: string;
    /**
     * languageCode de la región padre (opcional)
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'parentRegionId'?: string;
    /**
     * Zona horaria
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'timeZone'?: string;
    /**
     * Nivel de formalidad por defecto (opcional)
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'defaultFormalityLevel'?: string;
    /**
     * Notas adicionales (opcional)
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTacticDto
 */
export interface UpdateTacticDto {
    /**
     * Nueva configuración específica de la táctica (e.g., JSON string)
     * @type {string}
     * @memberof UpdateTacticDto
     */
    'tacticsConfig'?: string;
    /**
     * Nuevo código de idioma de la región asociada, o null para desasociar.
     * @type {string}
     * @memberof UpdateTacticDto
     */
    'regionId'?: string | null;
    /**
     * Nuevo ID de los datos culturales asociados, o null para desasociar.
     * @type {string}
     * @memberof UpdateTacticDto
     */
    'culturalDataId'?: string | null;
    /**
     * Nuevo ID del proyecto asociado, o null para desasociar.
     * @type {string}
     * @memberof UpdateTacticDto
     */
    'projectId'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateTagDto
 */
export interface UpdateTagDto {
    /**
     * Nuevo nombre único de la etiqueta (opcional)
     * @type {string}
     * @memberof UpdateTagDto
     */
    'name'?: string;
    /**
     * Nueva descripción opcional de la etiqueta
     * @type {string}
     * @memberof UpdateTagDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'createdAt': string;
}

/**
 * AIModelsProjectSpecificApi - axios parameter creator
 * @export
 */
export const AIModelsProjectSpecificApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new AI model for this project
         * @param {string} projectId 
         * @param {CreateAiModelDto} createAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerCreate: async (projectId: string, createAiModelDto: CreateAiModelDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerCreate', 'projectId', projectId)
            // verify required parameter 'createAiModelDto' is not null or undefined
            assertParamExists('aiModelControllerCreate', 'createAiModelDto', createAiModelDto)
            const localVarPath = `/api/projects/{projectId}/aimodels`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAiModelDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all AI models for this project (includes global models)
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/aimodels`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific AI model by ID (must belong to project or be global)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerFindOne: async (projectId: string, aiModelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerFindOne', 'projectId', projectId)
            // verify required parameter 'aiModelId' is not null or undefined
            assertParamExists('aiModelControllerFindOne', 'aiModelId', aiModelId)
            const localVarPath = `/api/projects/{projectId}/aimodels/{aiModelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"aiModelId"}}`, encodeURIComponent(String(aiModelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerRemove: async (projectId: string, aiModelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerRemove', 'projectId', projectId)
            // verify required parameter 'aiModelId' is not null or undefined
            assertParamExists('aiModelControllerRemove', 'aiModelId', aiModelId)
            const localVarPath = `/api/projects/{projectId}/aimodels/{aiModelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"aiModelId"}}`, encodeURIComponent(String(aiModelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {UpdateAiModelDto} updateAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerUpdate: async (projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerUpdate', 'projectId', projectId)
            // verify required parameter 'aiModelId' is not null or undefined
            assertParamExists('aiModelControllerUpdate', 'aiModelId', aiModelId)
            // verify required parameter 'updateAiModelDto' is not null or undefined
            assertParamExists('aiModelControllerUpdate', 'updateAiModelDto', updateAiModelDto)
            const localVarPath = `/api/projects/{projectId}/aimodels/{aiModelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"aiModelId"}}`, encodeURIComponent(String(aiModelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAiModelDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIModelsProjectSpecificApi - functional programming interface
 * @export
 */
export const AIModelsProjectSpecificApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIModelsProjectSpecificApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new AI model for this project
         * @param {string} projectId 
         * @param {CreateAiModelDto} createAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerCreate(projectId: string, createAiModelDto: CreateAiModelDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAiModelDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerCreate(projectId, createAiModelDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all AI models for this project (includes global models)
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateAiModelDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific AI model by ID (must belong to project or be global)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerFindOne(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAiModelDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerFindOne(projectId, aiModelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerRemove(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAiModelDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerRemove(projectId, aiModelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {UpdateAiModelDto} updateAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerUpdate(projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAiModelDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerUpdate(projectId, aiModelId, updateAiModelDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AIModelsProjectSpecificApi - factory interface
 * @export
 */
export const AIModelsProjectSpecificApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIModelsProjectSpecificApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new AI model for this project
         * @param {string} projectId 
         * @param {CreateAiModelDto} createAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerCreate(projectId: string, createAiModelDto: CreateAiModelDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateAiModelDto> {
            return localVarFp.aiModelControllerCreate(projectId, createAiModelDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all AI models for this project (includes global models)
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateAiModelDto>> {
            return localVarFp.aiModelControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific AI model by ID (must belong to project or be global)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerFindOne(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateAiModelDto> {
            return localVarFp.aiModelControllerFindOne(projectId, aiModelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerRemove(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateAiModelDto> {
            return localVarFp.aiModelControllerRemove(projectId, aiModelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {UpdateAiModelDto} updateAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerUpdate(projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateAiModelDto> {
            return localVarFp.aiModelControllerUpdate(projectId, aiModelId, updateAiModelDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIModelsProjectSpecificApi - interface
 * @export
 * @interface AIModelsProjectSpecificApi
 */
export interface AIModelsProjectSpecificApiInterface {
    /**
     * 
     * @summary Create a new AI model for this project
     * @param {string} projectId 
     * @param {CreateAiModelDto} createAiModelDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApiInterface
     */
    aiModelControllerCreate(projectId: string, createAiModelDto: CreateAiModelDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateAiModelDto>;

    /**
     * 
     * @summary Get all AI models for this project (includes global models)
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApiInterface
     */
    aiModelControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateAiModelDto>>;

    /**
     * 
     * @summary Get a specific AI model by ID (must belong to project or be global)
     * @param {string} projectId Project ID
     * @param {string} aiModelId AI Model CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApiInterface
     */
    aiModelControllerFindOne(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateAiModelDto>;

    /**
     * 
     * @summary Delete an AI model by ID (must belong to project)
     * @param {string} projectId Project ID
     * @param {string} aiModelId AI Model CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApiInterface
     */
    aiModelControllerRemove(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateAiModelDto>;

    /**
     * 
     * @summary Update an AI model by ID (must belong to project)
     * @param {string} projectId Project ID
     * @param {string} aiModelId AI Model CUID
     * @param {UpdateAiModelDto} updateAiModelDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApiInterface
     */
    aiModelControllerUpdate(projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateAiModelDto>;

}

/**
 * AIModelsProjectSpecificApi - object-oriented interface
 * @export
 * @class AIModelsProjectSpecificApi
 * @extends {BaseAPI}
 */
export class AIModelsProjectSpecificApi extends BaseAPI implements AIModelsProjectSpecificApiInterface {
    /**
     * 
     * @summary Create a new AI model for this project
     * @param {string} projectId 
     * @param {CreateAiModelDto} createAiModelDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerCreate(projectId: string, createAiModelDto: CreateAiModelDto, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerCreate(projectId, createAiModelDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all AI models for this project (includes global models)
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific AI model by ID (must belong to project or be global)
     * @param {string} projectId Project ID
     * @param {string} aiModelId AI Model CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerFindOne(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerFindOne(projectId, aiModelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an AI model by ID (must belong to project)
     * @param {string} projectId Project ID
     * @param {string} aiModelId AI Model CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerRemove(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerRemove(projectId, aiModelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an AI model by ID (must belong to project)
     * @param {string} projectId Project ID
     * @param {string} aiModelId AI Model CUID
     * @param {UpdateAiModelDto} updateAiModelDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerUpdate(projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerUpdate(projectId, aiModelId, updateAiModelDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AssetTranslationsWithinProjectAssetVersionApi - axios parameter creator
 * @export
 */
export const AssetTranslationsWithinProjectAssetVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a translation for a specific asset version within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {CreateAssetTranslationDto} createAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerCreate: async (projectId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'versionTag', versionTag)
            // verify required parameter 'createAssetTranslationDto' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'createAssetTranslationDto', createAssetTranslationDto)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}/translations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAssetTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all translations for a specific asset version within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerFindAll: async (projectId: string, assetKey: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerFindAll', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerFindAll', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerFindAll', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}/translations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerFindOneByLanguage: async (projectId: string, assetKey: string, versionTag: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerRemove: async (projectId: string, assetKey: string, versionTag: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerUpdate: async (projectId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'languageCode', languageCode)
            // verify required parameter 'updateAssetTranslationDto' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'updateAssetTranslationDto', updateAssetTranslationDto)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAssetTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetTranslationsWithinProjectAssetVersionApi - functional programming interface
 * @export
 */
export const AssetTranslationsWithinProjectAssetVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetTranslationsWithinProjectAssetVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a translation for a specific asset version within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {CreateAssetTranslationDto} createAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerCreate(projectId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerCreate(projectId, assetKey, versionTag, createAssetTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsWithinProjectAssetVersionApi.assetTranslationControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all translations for a specific asset version within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerFindAll(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateAssetTranslationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerFindAll(projectId, assetKey, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsWithinProjectAssetVersionApi.assetTranslationControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerFindOneByLanguage(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerFindOneByLanguage(projectId, assetKey, versionTag, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsWithinProjectAssetVersionApi.assetTranslationControllerFindOneByLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerRemove(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerRemove(projectId, assetKey, versionTag, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsWithinProjectAssetVersionApi.assetTranslationControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerUpdate(projectId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerUpdate(projectId, assetKey, versionTag, languageCode, updateAssetTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsWithinProjectAssetVersionApi.assetTranslationControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetTranslationsWithinProjectAssetVersionApi - factory interface
 * @export
 */
export const AssetTranslationsWithinProjectAssetVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetTranslationsWithinProjectAssetVersionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a translation for a specific asset version within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {CreateAssetTranslationDto} createAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerCreate(projectId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetTranslationDto> {
            return localVarFp.assetTranslationControllerCreate(projectId, assetKey, versionTag, createAssetTranslationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all translations for a specific asset version within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerFindAll(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateAssetTranslationDto>> {
            return localVarFp.assetTranslationControllerFindAll(projectId, assetKey, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerFindOneByLanguage(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetTranslationDto> {
            return localVarFp.assetTranslationControllerFindOneByLanguage(projectId, assetKey, versionTag, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerRemove(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.assetTranslationControllerRemove(projectId, assetKey, versionTag, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerUpdate(projectId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetTranslationDto> {
            return localVarFp.assetTranslationControllerUpdate(projectId, assetKey, versionTag, languageCode, updateAssetTranslationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetTranslationsWithinProjectAssetVersionApi - interface
 * @export
 * @interface AssetTranslationsWithinProjectAssetVersionApi
 */
export interface AssetTranslationsWithinProjectAssetVersionApiInterface {
    /**
     * 
     * @summary Create a translation for a specific asset version within a project
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {CreateAssetTranslationDto} createAssetTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApiInterface
     */
    assetTranslationControllerCreate(projectId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetTranslationDto>;

    /**
     * 
     * @summary Get all translations for a specific asset version within a project
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApiInterface
     */
    assetTranslationControllerFindAll(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateAssetTranslationDto>>;

    /**
     * 
     * @summary Get a specific translation by language code for an asset version
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code (e.g., es-ES)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApiInterface
     */
    assetTranslationControllerFindOneByLanguage(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetTranslationDto>;

    /**
     * 
     * @summary Delete a specific translation by language code for an asset version
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code of the translation to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApiInterface
     */
    assetTranslationControllerRemove(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update a specific translation by language code for an asset version
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code of the translation to update
     * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApiInterface
     */
    assetTranslationControllerUpdate(projectId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetTranslationDto>;

}

/**
 * AssetTranslationsWithinProjectAssetVersionApi - object-oriented interface
 * @export
 * @class AssetTranslationsWithinProjectAssetVersionApi
 * @extends {BaseAPI}
 */
export class AssetTranslationsWithinProjectAssetVersionApi extends BaseAPI implements AssetTranslationsWithinProjectAssetVersionApiInterface {
    /**
     * 
     * @summary Create a translation for a specific asset version within a project
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {CreateAssetTranslationDto} createAssetTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApi
     */
    public assetTranslationControllerCreate(projectId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options?: RawAxiosRequestConfig) {
        return AssetTranslationsWithinProjectAssetVersionApiFp(this.configuration).assetTranslationControllerCreate(projectId, assetKey, versionTag, createAssetTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all translations for a specific asset version within a project
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApi
     */
    public assetTranslationControllerFindAll(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return AssetTranslationsWithinProjectAssetVersionApiFp(this.configuration).assetTranslationControllerFindAll(projectId, assetKey, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific translation by language code for an asset version
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code (e.g., es-ES)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApi
     */
    public assetTranslationControllerFindOneByLanguage(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return AssetTranslationsWithinProjectAssetVersionApiFp(this.configuration).assetTranslationControllerFindOneByLanguage(projectId, assetKey, versionTag, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific translation by language code for an asset version
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code of the translation to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApi
     */
    public assetTranslationControllerRemove(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return AssetTranslationsWithinProjectAssetVersionApiFp(this.configuration).assetTranslationControllerRemove(projectId, assetKey, versionTag, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific translation by language code for an asset version
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code of the translation to update
     * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApi
     */
    public assetTranslationControllerUpdate(projectId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options?: RawAxiosRequestConfig) {
        return AssetTranslationsWithinProjectAssetVersionApiFp(this.configuration).assetTranslationControllerUpdate(projectId, assetKey, versionTag, languageCode, updateAssetTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log in a user
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerDto: RegisterDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authControllerRegister', 'registerDto', registerDto)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Log in a user
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile(options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Log in a user
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.authControllerRegister(registerDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * 
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerGetProfile(options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse>;

    /**
     * 
     * @summary Log in a user
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse>;

    /**
     * 
     * @summary Register a new user
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * 
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerGetProfile(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Log in a user
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRegister(registerDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CulturalDataApi - axios parameter creator
 * @export
 */
export const CulturalDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crear nuevos datos culturales dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateCulturalDataDto} createCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerCreate: async (projectId: string, createCulturalDataDto: CreateCulturalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerCreate', 'projectId', projectId)
            // verify required parameter 'createCulturalDataDto' is not null or undefined
            assertParamExists('culturalDataControllerCreate', 'createCulturalDataDto', createCulturalDataDto)
            const localVarPath = `/api/projects/{projectId}/cultural-data`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCulturalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener todos los datos culturales de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/cultural-data`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener datos culturales por ID dentro de un proyecto
         * @param {string} culturalDataId ID de los datos culturales
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerFindOne: async (culturalDataId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culturalDataId' is not null or undefined
            assertParamExists('culturalDataControllerFindOne', 'culturalDataId', culturalDataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/cultural-data/{culturalDataId}`
                .replace(`{${"culturalDataId"}}`, encodeURIComponent(String(culturalDataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Eliminar datos culturales por ID dentro de un proyecto
         * @param {string} culturalDataId ID a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerRemove: async (culturalDataId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culturalDataId' is not null or undefined
            assertParamExists('culturalDataControllerRemove', 'culturalDataId', culturalDataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/cultural-data/{culturalDataId}`
                .replace(`{${"culturalDataId"}}`, encodeURIComponent(String(culturalDataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualizar datos culturales por ID dentro de un proyecto
         * @param {string} culturalDataId ID a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdateCulturalDataDto} updateCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerUpdate: async (culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culturalDataId' is not null or undefined
            assertParamExists('culturalDataControllerUpdate', 'culturalDataId', culturalDataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateCulturalDataDto' is not null or undefined
            assertParamExists('culturalDataControllerUpdate', 'updateCulturalDataDto', updateCulturalDataDto)
            const localVarPath = `/api/projects/{projectId}/cultural-data/{culturalDataId}`
                .replace(`{${"culturalDataId"}}`, encodeURIComponent(String(culturalDataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCulturalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CulturalDataApi - functional programming interface
 * @export
 */
export const CulturalDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CulturalDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crear nuevos datos culturales dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateCulturalDataDto} createCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerCreate(projectId: string, createCulturalDataDto: CreateCulturalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CulturalDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerCreate(projectId, createCulturalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtener todos los datos culturales de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CulturalDataResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtener datos culturales por ID dentro de un proyecto
         * @param {string} culturalDataId ID de los datos culturales
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerFindOne(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CulturalDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerFindOne(culturalDataId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Eliminar datos culturales por ID dentro de un proyecto
         * @param {string} culturalDataId ID a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerRemove(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerRemove(culturalDataId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualizar datos culturales por ID dentro de un proyecto
         * @param {string} culturalDataId ID a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdateCulturalDataDto} updateCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerUpdate(culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CulturalDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerUpdate(culturalDataId, projectId, updateCulturalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CulturalDataApi - factory interface
 * @export
 */
export const CulturalDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CulturalDataApiFp(configuration)
    return {
        /**
         * 
         * @summary Crear nuevos datos culturales dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateCulturalDataDto} createCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerCreate(projectId: string, createCulturalDataDto: CreateCulturalDataDto, options?: RawAxiosRequestConfig): AxiosPromise<CulturalDataResponse> {
            return localVarFp.culturalDataControllerCreate(projectId, createCulturalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtener todos los datos culturales de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CulturalDataResponse>> {
            return localVarFp.culturalDataControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtener datos culturales por ID dentro de un proyecto
         * @param {string} culturalDataId ID de los datos culturales
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerFindOne(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CulturalDataResponse> {
            return localVarFp.culturalDataControllerFindOne(culturalDataId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Eliminar datos culturales por ID dentro de un proyecto
         * @param {string} culturalDataId ID a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerRemove(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.culturalDataControllerRemove(culturalDataId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualizar datos culturales por ID dentro de un proyecto
         * @param {string} culturalDataId ID a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdateCulturalDataDto} updateCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerUpdate(culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options?: RawAxiosRequestConfig): AxiosPromise<CulturalDataResponse> {
            return localVarFp.culturalDataControllerUpdate(culturalDataId, projectId, updateCulturalDataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CulturalDataApi - interface
 * @export
 * @interface CulturalDataApi
 */
export interface CulturalDataApiInterface {
    /**
     * 
     * @summary Crear nuevos datos culturales dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateCulturalDataDto} createCulturalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApiInterface
     */
    culturalDataControllerCreate(projectId: string, createCulturalDataDto: CreateCulturalDataDto, options?: RawAxiosRequestConfig): AxiosPromise<CulturalDataResponse>;

    /**
     * 
     * @summary Obtener todos los datos culturales de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApiInterface
     */
    culturalDataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CulturalDataResponse>>;

    /**
     * 
     * @summary Obtener datos culturales por ID dentro de un proyecto
     * @param {string} culturalDataId ID de los datos culturales
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApiInterface
     */
    culturalDataControllerFindOne(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CulturalDataResponse>;

    /**
     * 
     * @summary Eliminar datos culturales por ID dentro de un proyecto
     * @param {string} culturalDataId ID a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApiInterface
     */
    culturalDataControllerRemove(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Actualizar datos culturales por ID dentro de un proyecto
     * @param {string} culturalDataId ID a actualizar
     * @param {string} projectId ID del proyecto
     * @param {UpdateCulturalDataDto} updateCulturalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApiInterface
     */
    culturalDataControllerUpdate(culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options?: RawAxiosRequestConfig): AxiosPromise<CulturalDataResponse>;

}

/**
 * CulturalDataApi - object-oriented interface
 * @export
 * @class CulturalDataApi
 * @extends {BaseAPI}
 */
export class CulturalDataApi extends BaseAPI implements CulturalDataApiInterface {
    /**
     * 
     * @summary Crear nuevos datos culturales dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateCulturalDataDto} createCulturalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerCreate(projectId: string, createCulturalDataDto: CreateCulturalDataDto, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerCreate(projectId, createCulturalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtener todos los datos culturales de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtener datos culturales por ID dentro de un proyecto
     * @param {string} culturalDataId ID de los datos culturales
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerFindOne(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerFindOne(culturalDataId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Eliminar datos culturales por ID dentro de un proyecto
     * @param {string} culturalDataId ID a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerRemove(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerRemove(culturalDataId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualizar datos culturales por ID dentro de un proyecto
     * @param {string} culturalDataId ID a actualizar
     * @param {string} projectId ID del proyecto
     * @param {UpdateCulturalDataDto} updateCulturalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerUpdate(culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerUpdate(culturalDataId, projectId, updateCulturalDataDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crea un nuevo entorno para un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateEnvironmentDto} createEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerCreate: async (projectId: string, createEnvironmentDto: CreateEnvironmentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerCreate', 'projectId', projectId)
            // verify required parameter 'createEnvironmentDto' is not null or undefined
            assertParamExists('environmentControllerCreate', 'createEnvironmentDto', createEnvironmentDto)
            const localVarPath = `/api/projects/{projectId}/environments`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEnvironmentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene todos los entornos de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/environments`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene un entorno por su nombre dentro de un proyecto
         * @param {string} name Nombre único del entorno en el proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindByName: async (name: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('environmentControllerFindByName', 'name', name)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerFindByName', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/environments/by-name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene un entorno por su ID dentro de un proyecto
         * @param {string} environmentId ID único del entorno (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindOne: async (environmentId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('environmentControllerFindOne', 'environmentId', environmentId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/environments/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Elimina un entorno de un proyecto
         * @param {string} environmentId ID único del entorno a eliminar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerRemove: async (environmentId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('environmentControllerRemove', 'environmentId', environmentId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/environments/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualiza un entorno existente en un proyecto
         * @param {string} environmentId ID único del entorno a actualizar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {UpdateEnvironmentDto} updateEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerUpdate: async (environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('environmentControllerUpdate', 'environmentId', environmentId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateEnvironmentDto' is not null or undefined
            assertParamExists('environmentControllerUpdate', 'updateEnvironmentDto', updateEnvironmentDto)
            const localVarPath = `/api/projects/{projectId}/environments/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEnvironmentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crea un nuevo entorno para un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateEnvironmentDto} createEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerCreate(projectId: string, createEnvironmentDto: CreateEnvironmentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerCreate(projectId, createEnvironmentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene todos los entornos de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateEnvironmentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene un entorno por su nombre dentro de un proyecto
         * @param {string} name Nombre único del entorno en el proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerFindByName(name, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerFindByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene un entorno por su ID dentro de un proyecto
         * @param {string} environmentId ID único del entorno (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerFindOne(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerFindOne(environmentId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Elimina un entorno de un proyecto
         * @param {string} environmentId ID único del entorno a eliminar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerRemove(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerRemove(environmentId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualiza un entorno existente en un proyecto
         * @param {string} environmentId ID único del entorno a actualizar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {UpdateEnvironmentDto} updateEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerUpdate(environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerUpdate(environmentId, projectId, updateEnvironmentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Crea un nuevo entorno para un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateEnvironmentDto} createEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerCreate(projectId: string, createEnvironmentDto: CreateEnvironmentDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerCreate(projectId, createEnvironmentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene todos los entornos de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateEnvironmentDto>> {
            return localVarFp.environmentControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene un entorno por su nombre dentro de un proyecto
         * @param {string} name Nombre único del entorno en el proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerFindByName(name, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene un entorno por su ID dentro de un proyecto
         * @param {string} environmentId ID único del entorno (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindOne(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerFindOne(environmentId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Elimina un entorno de un proyecto
         * @param {string} environmentId ID único del entorno a eliminar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerRemove(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerRemove(environmentId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualiza un entorno existente en un proyecto
         * @param {string} environmentId ID único del entorno a actualizar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {UpdateEnvironmentDto} updateEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerUpdate(environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerUpdate(environmentId, projectId, updateEnvironmentDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentsApi - interface
 * @export
 * @interface EnvironmentsApi
 */
export interface EnvironmentsApiInterface {
    /**
     * 
     * @summary Crea un nuevo entorno para un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateEnvironmentDto} createEnvironmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApiInterface
     */
    environmentControllerCreate(projectId: string, createEnvironmentDto: CreateEnvironmentDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto>;

    /**
     * 
     * @summary Obtiene todos los entornos de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApiInterface
     */
    environmentControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateEnvironmentDto>>;

    /**
     * 
     * @summary Obtiene un entorno por su nombre dentro de un proyecto
     * @param {string} name Nombre único del entorno en el proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApiInterface
     */
    environmentControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto>;

    /**
     * 
     * @summary Obtiene un entorno por su ID dentro de un proyecto
     * @param {string} environmentId ID único del entorno (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApiInterface
     */
    environmentControllerFindOne(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto>;

    /**
     * 
     * @summary Elimina un entorno de un proyecto
     * @param {string} environmentId ID único del entorno a eliminar (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApiInterface
     */
    environmentControllerRemove(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto>;

    /**
     * 
     * @summary Actualiza un entorno existente en un proyecto
     * @param {string} environmentId ID único del entorno a actualizar (CUID)
     * @param {string} projectId ID del proyecto
     * @param {UpdateEnvironmentDto} updateEnvironmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApiInterface
     */
    environmentControllerUpdate(environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto>;

}

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI implements EnvironmentsApiInterface {
    /**
     * 
     * @summary Crea un nuevo entorno para un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateEnvironmentDto} createEnvironmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerCreate(projectId: string, createEnvironmentDto: CreateEnvironmentDto, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerCreate(projectId, createEnvironmentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene todos los entornos de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene un entorno por su nombre dentro de un proyecto
     * @param {string} name Nombre único del entorno en el proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerFindByName(name, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene un entorno por su ID dentro de un proyecto
     * @param {string} environmentId ID único del entorno (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerFindOne(environmentId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerFindOne(environmentId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Elimina un entorno de un proyecto
     * @param {string} environmentId ID único del entorno a eliminar (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerRemove(environmentId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerRemove(environmentId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualiza un entorno existente en un proyecto
     * @param {string} environmentId ID único del entorno a actualizar (CUID)
     * @param {string} projectId ID del proyecto
     * @param {UpdateEnvironmentDto} updateEnvironmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerUpdate(environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerUpdate(environmentId, projectId, updateEnvironmentDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthControllerCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthControllerCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck(options?: RawAxiosRequestConfig): AxiosPromise<HealthControllerCheck200Response> {
            return localVarFp.healthControllerCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - interface
 * @export
 * @interface HealthApi
 */
export interface HealthApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    healthControllerCheck(options?: RawAxiosRequestConfig): AxiosPromise<HealthControllerCheck200Response>;

}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI implements HealthApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LLMExecutionApi - axios parameter creator
 * @export
 */
export const LLMExecutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
         * @param {ExecuteLlmDto} executeLlmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        llmExecutionControllerExecuteLlm: async (executeLlmDto: ExecuteLlmDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'executeLlmDto' is not null or undefined
            assertParamExists('llmExecutionControllerExecuteLlm', 'executeLlmDto', executeLlmDto)
            const localVarPath = `/llm-execution/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeLlmDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LLMExecutionApi - functional programming interface
 * @export
 */
export const LLMExecutionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LLMExecutionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
         * @param {ExecuteLlmDto} executeLlmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async llmExecutionControllerExecuteLlm(executeLlmDto: ExecuteLlmDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.llmExecutionControllerExecuteLlm(executeLlmDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMExecutionApi.llmExecutionControllerExecuteLlm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LLMExecutionApi - factory interface
 * @export
 */
export const LLMExecutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LLMExecutionApiFp(configuration)
    return {
        /**
         * 
         * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
         * @param {ExecuteLlmDto} executeLlmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        llmExecutionControllerExecuteLlm(executeLlmDto: ExecuteLlmDto, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.llmExecutionControllerExecuteLlm(executeLlmDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LLMExecutionApi - interface
 * @export
 * @interface LLMExecutionApi
 */
export interface LLMExecutionApiInterface {
    /**
     * 
     * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
     * @param {ExecuteLlmDto} executeLlmDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMExecutionApiInterface
     */
    llmExecutionControllerExecuteLlm(executeLlmDto: ExecuteLlmDto, options?: RawAxiosRequestConfig): AxiosPromise<any>;

}

/**
 * LLMExecutionApi - object-oriented interface
 * @export
 * @class LLMExecutionApi
 * @extends {BaseAPI}
 */
export class LLMExecutionApi extends BaseAPI implements LLMExecutionApiInterface {
    /**
     * 
     * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
     * @param {ExecuteLlmDto} executeLlmDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMExecutionApi
     */
    public llmExecutionControllerExecuteLlm(executeLlmDto: ExecuteLlmDto, options?: RawAxiosRequestConfig) {
        return LLMExecutionApiFp(this.configuration).llmExecutionControllerExecuteLlm(executeLlmDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreate: async (createProjectDto: CreateProjectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectDto' is not null or undefined
            assertParamExists('projectControllerCreate', 'createProjectDto', createProjectDto)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get projects accessible by the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindMine: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects/mine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a project by ID
         * @param {string} id Project CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerFindOne', 'id', id)
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a project by ID
         * @param {string} id Project CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerRemove', 'id', id)
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a project by ID
         * @param {string} id Project CUID
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdate: async (id: string, updateProjectDto: UpdateProjectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerUpdate', 'id', id)
            // verify required parameter 'updateProjectDto' is not null or undefined
            assertParamExists('projectControllerUpdate', 'updateProjectDto', updateProjectDto)
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerCreate(createProjectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateProjectDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get projects accessible by the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerFindMine(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateProjectDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerFindMine(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerFindMine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a project by ID
         * @param {string} id Project CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a project by ID
         * @param {string} id Project CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a project by ID
         * @param {string} id Project CUID
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerUpdate(id, updateProjectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectDto> {
            return localVarFp.projectControllerCreate(createProjectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateProjectDto>> {
            return localVarFp.projectControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get projects accessible by the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindMine(options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateProjectDto>> {
            return localVarFp.projectControllerFindMine(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a project by ID
         * @param {string} id Project CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectDto> {
            return localVarFp.projectControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a project by ID
         * @param {string} id Project CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectDto> {
            return localVarFp.projectControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a project by ID
         * @param {string} id Project CUID
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectDto> {
            return localVarFp.projectControllerUpdate(id, updateProjectDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - interface
 * @export
 * @interface ProjectsApi
 */
export interface ProjectsApiInterface {
    /**
     * 
     * @summary Create a new project
     * @param {CreateProjectDto} createProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectDto>;

    /**
     * 
     * @summary Get all projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateProjectDto>>;

    /**
     * 
     * @summary Get projects accessible by the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectControllerFindMine(options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateProjectDto>>;

    /**
     * 
     * @summary Get a project by ID
     * @param {string} id Project CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectDto>;

    /**
     * 
     * @summary Delete a project by ID
     * @param {string} id Project CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectDto>;

    /**
     * 
     * @summary Update a project by ID
     * @param {string} id Project CUID
     * @param {UpdateProjectDto} updateProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectDto>;

}

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI implements ProjectsApiInterface {
    /**
     * 
     * @summary Create a new project
     * @param {CreateProjectDto} createProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerCreate(createProjectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerFindAll(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get projects accessible by the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerFindMine(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerFindMine(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a project by ID
     * @param {string} id Project CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a project by ID
     * @param {string} id Project CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a project by ID
     * @param {string} id Project CUID
     * @param {UpdateProjectDto} updateProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerUpdate(id, updateProjectDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptAssetLinksWithinProjectVersionApi - axios parameter creator
 * @export
 */
export const PromptAssetLinksWithinProjectVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Link an Asset Version to a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {CreatePromptAssetLinkDto} createPromptAssetLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerCreate: async (projectId: string, promptVersionId: string, createPromptAssetLinkDto: CreatePromptAssetLinkDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetLinkControllerCreate', 'projectId', projectId)
            // verify required parameter 'promptVersionId' is not null or undefined
            assertParamExists('promptAssetLinkControllerCreate', 'promptVersionId', promptVersionId)
            // verify required parameter 'createPromptAssetLinkDto' is not null or undefined
            assertParamExists('promptAssetLinkControllerCreate', 'createPromptAssetLinkDto', createPromptAssetLinkDto)
            const localVarPath = `/api/projects/{projectId}/prompt-versions/{promptVersionId}/links`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptVersionId"}}`, encodeURIComponent(String(promptVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptAssetLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all links for a specific Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerFindAll: async (projectId: string, promptVersionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetLinkControllerFindAll', 'projectId', projectId)
            // verify required parameter 'promptVersionId' is not null or undefined
            assertParamExists('promptAssetLinkControllerFindAll', 'promptVersionId', promptVersionId)
            const localVarPath = `/api/projects/{projectId}/prompt-versions/{promptVersionId}/links`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptVersionId"}}`, encodeURIComponent(String(promptVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerFindOne: async (projectId: string, promptVersionId: string, linkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetLinkControllerFindOne', 'projectId', projectId)
            // verify required parameter 'promptVersionId' is not null or undefined
            assertParamExists('promptAssetLinkControllerFindOne', 'promptVersionId', promptVersionId)
            // verify required parameter 'linkId' is not null or undefined
            assertParamExists('promptAssetLinkControllerFindOne', 'linkId', linkId)
            const localVarPath = `/api/projects/{projectId}/prompt-versions/{promptVersionId}/links/{linkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptVersionId"}}`, encodeURIComponent(String(promptVersionId)))
                .replace(`{${"linkId"}}`, encodeURIComponent(String(linkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerRemove: async (projectId: string, promptVersionId: string, linkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetLinkControllerRemove', 'projectId', projectId)
            // verify required parameter 'promptVersionId' is not null or undefined
            assertParamExists('promptAssetLinkControllerRemove', 'promptVersionId', promptVersionId)
            // verify required parameter 'linkId' is not null or undefined
            assertParamExists('promptAssetLinkControllerRemove', 'linkId', linkId)
            const localVarPath = `/api/projects/{projectId}/prompt-versions/{promptVersionId}/links/{linkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptVersionId"}}`, encodeURIComponent(String(promptVersionId)))
                .replace(`{${"linkId"}}`, encodeURIComponent(String(linkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {UpdatePromptAssetLinkDto} updatePromptAssetLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerUpdate: async (projectId: string, promptVersionId: string, linkId: string, updatePromptAssetLinkDto: UpdatePromptAssetLinkDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetLinkControllerUpdate', 'projectId', projectId)
            // verify required parameter 'promptVersionId' is not null or undefined
            assertParamExists('promptAssetLinkControllerUpdate', 'promptVersionId', promptVersionId)
            // verify required parameter 'linkId' is not null or undefined
            assertParamExists('promptAssetLinkControllerUpdate', 'linkId', linkId)
            // verify required parameter 'updatePromptAssetLinkDto' is not null or undefined
            assertParamExists('promptAssetLinkControllerUpdate', 'updatePromptAssetLinkDto', updatePromptAssetLinkDto)
            const localVarPath = `/api/projects/{projectId}/prompt-versions/{promptVersionId}/links/{linkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptVersionId"}}`, encodeURIComponent(String(promptVersionId)))
                .replace(`{${"linkId"}}`, encodeURIComponent(String(linkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptAssetLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptAssetLinksWithinProjectVersionApi - functional programming interface
 * @export
 */
export const PromptAssetLinksWithinProjectVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptAssetLinksWithinProjectVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Link an Asset Version to a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {CreatePromptAssetLinkDto} createPromptAssetLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetLinkControllerCreate(projectId: string, promptVersionId: string, createPromptAssetLinkDto: CreatePromptAssetLinkDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetLinkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetLinkControllerCreate(projectId, promptVersionId, createPromptAssetLinkDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetLinksWithinProjectVersionApi.promptAssetLinkControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all links for a specific Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetLinkControllerFindAll(projectId: string, promptVersionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptAssetLinkDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetLinkControllerFindAll(projectId, promptVersionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetLinksWithinProjectVersionApi.promptAssetLinkControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetLinkControllerFindOne(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetLinkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetLinkControllerFindOne(projectId, promptVersionId, linkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetLinksWithinProjectVersionApi.promptAssetLinkControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetLinkControllerRemove(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetLinkControllerRemove(projectId, promptVersionId, linkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetLinksWithinProjectVersionApi.promptAssetLinkControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {UpdatePromptAssetLinkDto} updatePromptAssetLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetLinkControllerUpdate(projectId: string, promptVersionId: string, linkId: string, updatePromptAssetLinkDto: UpdatePromptAssetLinkDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetLinkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetLinkControllerUpdate(projectId, promptVersionId, linkId, updatePromptAssetLinkDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetLinksWithinProjectVersionApi.promptAssetLinkControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptAssetLinksWithinProjectVersionApi - factory interface
 * @export
 */
export const PromptAssetLinksWithinProjectVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptAssetLinksWithinProjectVersionApiFp(configuration)
    return {
        /**
         * 
         * @summary Link an Asset Version to a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {CreatePromptAssetLinkDto} createPromptAssetLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerCreate(projectId: string, promptVersionId: string, createPromptAssetLinkDto: CreatePromptAssetLinkDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetLinkDto> {
            return localVarFp.promptAssetLinkControllerCreate(projectId, promptVersionId, createPromptAssetLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all links for a specific Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerFindAll(projectId: string, promptVersionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptAssetLinkDto>> {
            return localVarFp.promptAssetLinkControllerFindAll(projectId, promptVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerFindOne(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetLinkDto> {
            return localVarFp.promptAssetLinkControllerFindOne(projectId, promptVersionId, linkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerRemove(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetLinkControllerRemove(projectId, promptVersionId, linkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {UpdatePromptAssetLinkDto} updatePromptAssetLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerUpdate(projectId: string, promptVersionId: string, linkId: string, updatePromptAssetLinkDto: UpdatePromptAssetLinkDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetLinkDto> {
            return localVarFp.promptAssetLinkControllerUpdate(projectId, promptVersionId, linkId, updatePromptAssetLinkDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptAssetLinksWithinProjectVersionApi - interface
 * @export
 * @interface PromptAssetLinksWithinProjectVersionApi
 */
export interface PromptAssetLinksWithinProjectVersionApiInterface {
    /**
     * 
     * @summary Link an Asset Version to a Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {CreatePromptAssetLinkDto} createPromptAssetLinkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApiInterface
     */
    promptAssetLinkControllerCreate(projectId: string, promptVersionId: string, createPromptAssetLinkDto: CreatePromptAssetLinkDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetLinkDto>;

    /**
     * 
     * @summary Get all links for a specific Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApiInterface
     */
    promptAssetLinkControllerFindAll(projectId: string, promptVersionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptAssetLinkDto>>;

    /**
     * 
     * @summary Get a specific link by its ID for a Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {string} linkId Link ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApiInterface
     */
    promptAssetLinkControllerFindOne(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetLinkDto>;

    /**
     * 
     * @summary Delete a specific link by its ID for a Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {string} linkId Link ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApiInterface
     */
    promptAssetLinkControllerRemove(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update a specific link by its ID for a Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {string} linkId Link ID
     * @param {UpdatePromptAssetLinkDto} updatePromptAssetLinkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApiInterface
     */
    promptAssetLinkControllerUpdate(projectId: string, promptVersionId: string, linkId: string, updatePromptAssetLinkDto: UpdatePromptAssetLinkDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetLinkDto>;

}

/**
 * PromptAssetLinksWithinProjectVersionApi - object-oriented interface
 * @export
 * @class PromptAssetLinksWithinProjectVersionApi
 * @extends {BaseAPI}
 */
export class PromptAssetLinksWithinProjectVersionApi extends BaseAPI implements PromptAssetLinksWithinProjectVersionApiInterface {
    /**
     * 
     * @summary Link an Asset Version to a Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {CreatePromptAssetLinkDto} createPromptAssetLinkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApi
     */
    public promptAssetLinkControllerCreate(projectId: string, promptVersionId: string, createPromptAssetLinkDto: CreatePromptAssetLinkDto, options?: RawAxiosRequestConfig) {
        return PromptAssetLinksWithinProjectVersionApiFp(this.configuration).promptAssetLinkControllerCreate(projectId, promptVersionId, createPromptAssetLinkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all links for a specific Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApi
     */
    public promptAssetLinkControllerFindAll(projectId: string, promptVersionId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetLinksWithinProjectVersionApiFp(this.configuration).promptAssetLinkControllerFindAll(projectId, promptVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific link by its ID for a Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {string} linkId Link ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApi
     */
    public promptAssetLinkControllerFindOne(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetLinksWithinProjectVersionApiFp(this.configuration).promptAssetLinkControllerFindOne(projectId, promptVersionId, linkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific link by its ID for a Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {string} linkId Link ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApi
     */
    public promptAssetLinkControllerRemove(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetLinksWithinProjectVersionApiFp(this.configuration).promptAssetLinkControllerRemove(projectId, promptVersionId, linkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific link by its ID for a Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {string} linkId Link ID
     * @param {UpdatePromptAssetLinkDto} updatePromptAssetLinkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApi
     */
    public promptAssetLinkControllerUpdate(projectId: string, promptVersionId: string, linkId: string, updatePromptAssetLinkDto: UpdatePromptAssetLinkDto, options?: RawAxiosRequestConfig) {
        return PromptAssetLinksWithinProjectVersionApiFp(this.configuration).promptAssetLinkControllerUpdate(projectId, promptVersionId, linkId, updatePromptAssetLinkDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptAssetVersionsWithinProjectAssetApi - axios parameter creator
 * @export
 */
export const PromptAssetVersionsWithinProjectAssetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new version for a specific asset within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerCreate: async (projectId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerCreate', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerCreate', 'assetKey', assetKey)
            // verify required parameter 'createPromptAssetVersionDto' is not null or undefined
            assertParamExists('promptAssetVersionControllerCreate', 'createPromptAssetVersionDto', createPromptAssetVersionDto)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptAssetVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all versions for a specific asset within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerFindAll: async (projectId: string, assetKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindAll', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindAll', 'assetKey', assetKey)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag (e.g., v1.0.0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerFindOneByTag: async (projectId: string, assetKey: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindOneByTag', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindOneByTag', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindOneByTag', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerRemove: async (projectId: string, assetKey: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerRemove', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerRemove', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptAssetVersionControllerRemove', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerUpdate: async (projectId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'versionTag', versionTag)
            // verify required parameter 'updatePromptAssetVersionDto' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'updatePromptAssetVersionDto', updatePromptAssetVersionDto)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptAssetVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptAssetVersionsWithinProjectAssetApi - functional programming interface
 * @export
 */
export const PromptAssetVersionsWithinProjectAssetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptAssetVersionsWithinProjectAssetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new version for a specific asset within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerCreate(projectId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerCreate(projectId, assetKey, createPromptAssetVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsWithinProjectAssetApi.promptAssetVersionControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all versions for a specific asset within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerFindAll(projectId: string, assetKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptAssetVersionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerFindAll(projectId, assetKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsWithinProjectAssetApi.promptAssetVersionControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag (e.g., v1.0.0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerFindOneByTag(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerFindOneByTag(projectId, assetKey, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsWithinProjectAssetApi.promptAssetVersionControllerFindOneByTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerRemove(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerRemove(projectId, assetKey, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsWithinProjectAssetApi.promptAssetVersionControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerUpdate(projectId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerUpdate(projectId, assetKey, versionTag, updatePromptAssetVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsWithinProjectAssetApi.promptAssetVersionControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptAssetVersionsWithinProjectAssetApi - factory interface
 * @export
 */
export const PromptAssetVersionsWithinProjectAssetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptAssetVersionsWithinProjectAssetApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new version for a specific asset within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerCreate(projectId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto> {
            return localVarFp.promptAssetVersionControllerCreate(projectId, assetKey, createPromptAssetVersionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all versions for a specific asset within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerFindAll(projectId: string, assetKey: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptAssetVersionDto>> {
            return localVarFp.promptAssetVersionControllerFindAll(projectId, assetKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag (e.g., v1.0.0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerFindOneByTag(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto> {
            return localVarFp.promptAssetVersionControllerFindOneByTag(projectId, assetKey, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerRemove(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetVersionControllerRemove(projectId, assetKey, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerUpdate(projectId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto> {
            return localVarFp.promptAssetVersionControllerUpdate(projectId, assetKey, versionTag, updatePromptAssetVersionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptAssetVersionsWithinProjectAssetApi - interface
 * @export
 * @interface PromptAssetVersionsWithinProjectAssetApi
 */
export interface PromptAssetVersionsWithinProjectAssetApiInterface {
    /**
     * 
     * @summary Create a new version for a specific asset within a project
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApiInterface
     */
    promptAssetVersionControllerCreate(projectId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto>;

    /**
     * 
     * @summary Get all versions for a specific asset within a project
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApiInterface
     */
    promptAssetVersionControllerFindAll(projectId: string, assetKey: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptAssetVersionDto>>;

    /**
     * 
     * @summary Get a specific asset version by its tag within a project/asset
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version tag (e.g., v1.0.0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApiInterface
     */
    promptAssetVersionControllerFindOneByTag(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto>;

    /**
     * 
     * @summary Delete a specific asset version by its tag within a project/asset
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApiInterface
     */
    promptAssetVersionControllerRemove(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update a specific asset version by its tag within a project/asset
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version tag to update
     * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApiInterface
     */
    promptAssetVersionControllerUpdate(projectId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto>;

}

/**
 * PromptAssetVersionsWithinProjectAssetApi - object-oriented interface
 * @export
 * @class PromptAssetVersionsWithinProjectAssetApi
 * @extends {BaseAPI}
 */
export class PromptAssetVersionsWithinProjectAssetApi extends BaseAPI implements PromptAssetVersionsWithinProjectAssetApiInterface {
    /**
     * 
     * @summary Create a new version for a specific asset within a project
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApi
     */
    public promptAssetVersionControllerCreate(projectId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsWithinProjectAssetApiFp(this.configuration).promptAssetVersionControllerCreate(projectId, assetKey, createPromptAssetVersionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all versions for a specific asset within a project
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApi
     */
    public promptAssetVersionControllerFindAll(projectId: string, assetKey: string, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsWithinProjectAssetApiFp(this.configuration).promptAssetVersionControllerFindAll(projectId, assetKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific asset version by its tag within a project/asset
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version tag (e.g., v1.0.0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApi
     */
    public promptAssetVersionControllerFindOneByTag(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsWithinProjectAssetApiFp(this.configuration).promptAssetVersionControllerFindOneByTag(projectId, assetKey, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific asset version by its tag within a project/asset
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApi
     */
    public promptAssetVersionControllerRemove(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsWithinProjectAssetApiFp(this.configuration).promptAssetVersionControllerRemove(projectId, assetKey, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific asset version by its tag within a project/asset
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version tag to update
     * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApi
     */
    public promptAssetVersionControllerUpdate(projectId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsWithinProjectAssetApiFp(this.configuration).promptAssetVersionControllerUpdate(projectId, assetKey, versionTag, updatePromptAssetVersionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptAssetsApi - axios parameter creator
 * @export
 */
export const PromptAssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crea un nuevo prompt asset (y su primera versión) dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreatePromptAssetDto} createPromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerCreate: async (projectId: string, createPromptAssetDto: CreatePromptAssetDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerCreate', 'projectId', projectId)
            // verify required parameter 'createPromptAssetDto' is not null or undefined
            assertParamExists('promptAssetControllerCreate', 'createPromptAssetDto', createPromptAssetDto)
            const localVarPath = `/api/projects/{projectId}/prompt-assets`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene todos los prompt assets de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompt-assets`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene un prompt asset por su key dentro de un proyecto
         * @param {string} assetKey Key única del asset dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerFindOne: async (assetKey: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetControllerFindOne', 'assetKey', assetKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompt-assets/{assetKey}`
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un proyecto
         * @param {string} assetKey Key única del asset a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerRemove: async (assetKey: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetControllerRemove', 'assetKey', assetKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompt-assets/{assetKey}`
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un proyecto
         * @param {string} assetKey Key única del asset a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdatePromptAssetDto} updatePromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerUpdate: async (assetKey: string, projectId: string, updatePromptAssetDto: UpdatePromptAssetDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetControllerUpdate', 'assetKey', assetKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updatePromptAssetDto' is not null or undefined
            assertParamExists('promptAssetControllerUpdate', 'updatePromptAssetDto', updatePromptAssetDto)
            const localVarPath = `/api/projects/{projectId}/prompt-assets/{assetKey}`
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptAssetsApi - functional programming interface
 * @export
 */
export const PromptAssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptAssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crea un nuevo prompt asset (y su primera versión) dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreatePromptAssetDto} createPromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerCreate(projectId: string, createPromptAssetDto: CreatePromptAssetDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerCreate(projectId, createPromptAssetDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsApi.promptAssetControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene todos los prompt assets de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsApi.promptAssetControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene un prompt asset por su key dentro de un proyecto
         * @param {string} assetKey Key única del asset dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerFindOne(assetKey: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerFindOne(assetKey, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsApi.promptAssetControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un proyecto
         * @param {string} assetKey Key única del asset a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerRemove(assetKey: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerRemove(assetKey, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsApi.promptAssetControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un proyecto
         * @param {string} assetKey Key única del asset a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdatePromptAssetDto} updatePromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerUpdate(assetKey: string, projectId: string, updatePromptAssetDto: UpdatePromptAssetDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerUpdate(assetKey, projectId, updatePromptAssetDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsApi.promptAssetControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptAssetsApi - factory interface
 * @export
 */
export const PromptAssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptAssetsApiFp(configuration)
    return {
        /**
         * 
         * @summary Crea un nuevo prompt asset (y su primera versión) dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreatePromptAssetDto} createPromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerCreate(projectId: string, createPromptAssetDto: CreatePromptAssetDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerCreate(projectId, createPromptAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene todos los prompt assets de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene un prompt asset por su key dentro de un proyecto
         * @param {string} assetKey Key única del asset dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerFindOne(assetKey: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerFindOne(assetKey, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un proyecto
         * @param {string} assetKey Key única del asset a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerRemove(assetKey: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerRemove(assetKey, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un proyecto
         * @param {string} assetKey Key única del asset a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdatePromptAssetDto} updatePromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerUpdate(assetKey: string, projectId: string, updatePromptAssetDto: UpdatePromptAssetDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerUpdate(assetKey, projectId, updatePromptAssetDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptAssetsApi - interface
 * @export
 * @interface PromptAssetsApi
 */
export interface PromptAssetsApiInterface {
    /**
     * 
     * @summary Crea un nuevo prompt asset (y su primera versión) dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreatePromptAssetDto} createPromptAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApiInterface
     */
    promptAssetControllerCreate(projectId: string, createPromptAssetDto: CreatePromptAssetDto, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Obtiene todos los prompt assets de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApiInterface
     */
    promptAssetControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Obtiene un prompt asset por su key dentro de un proyecto
     * @param {string} assetKey Key única del asset dentro del proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApiInterface
     */
    promptAssetControllerFindOne(assetKey: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un proyecto
     * @param {string} assetKey Key única del asset a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApiInterface
     */
    promptAssetControllerRemove(assetKey: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un proyecto
     * @param {string} assetKey Key única del asset a actualizar
     * @param {string} projectId ID del proyecto
     * @param {UpdatePromptAssetDto} updatePromptAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApiInterface
     */
    promptAssetControllerUpdate(assetKey: string, projectId: string, updatePromptAssetDto: UpdatePromptAssetDto, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * PromptAssetsApi - object-oriented interface
 * @export
 * @class PromptAssetsApi
 * @extends {BaseAPI}
 */
export class PromptAssetsApi extends BaseAPI implements PromptAssetsApiInterface {
    /**
     * 
     * @summary Crea un nuevo prompt asset (y su primera versión) dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreatePromptAssetDto} createPromptAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApi
     */
    public promptAssetControllerCreate(projectId: string, createPromptAssetDto: CreatePromptAssetDto, options?: RawAxiosRequestConfig) {
        return PromptAssetsApiFp(this.configuration).promptAssetControllerCreate(projectId, createPromptAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene todos los prompt assets de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApi
     */
    public promptAssetControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetsApiFp(this.configuration).promptAssetControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene un prompt asset por su key dentro de un proyecto
     * @param {string} assetKey Key única del asset dentro del proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApi
     */
    public promptAssetControllerFindOne(assetKey: string, projectId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetsApiFp(this.configuration).promptAssetControllerFindOne(assetKey, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un proyecto
     * @param {string} assetKey Key única del asset a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApi
     */
    public promptAssetControllerRemove(assetKey: string, projectId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetsApiFp(this.configuration).promptAssetControllerRemove(assetKey, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un proyecto
     * @param {string} assetKey Key única del asset a actualizar
     * @param {string} projectId ID del proyecto
     * @param {UpdatePromptAssetDto} updatePromptAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApi
     */
    public promptAssetControllerUpdate(assetKey: string, projectId: string, updatePromptAssetDto: UpdatePromptAssetDto, options?: RawAxiosRequestConfig) {
        return PromptAssetsApiFp(this.configuration).promptAssetControllerUpdate(assetKey, projectId, updatePromptAssetDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptTranslationsWithinProjectPromptVersionApi - axios parameter creator
 * @export
 */
export const PromptTranslationsWithinProjectPromptVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a translation for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {CreatePromptTranslationDto} createPromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerCreate: async (projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerCreate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerCreate', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerCreate', 'versionTag', versionTag)
            // verify required parameter 'createPromptTranslationDto' is not null or undefined
            assertParamExists('promptTranslationControllerCreate', 'createPromptTranslationDto', createPromptTranslationDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all translations for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerFindAll: async (projectId: string, promptId: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerFindAll', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerFindAll', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerFindAll', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerFindOneByLanguage: async (projectId: string, promptId: string, versionTag: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerFindOneByLanguage', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerFindOneByLanguage', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerFindOneByLanguage', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('promptTranslationControllerFindOneByLanguage', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerRemove: async (projectId: string, promptId: string, versionTag: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerRemove', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerRemove', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerRemove', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('promptTranslationControllerRemove', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerUpdate: async (projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'languageCode', languageCode)
            // verify required parameter 'updatePromptTranslationDto' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'updatePromptTranslationDto', updatePromptTranslationDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptTranslationsWithinProjectPromptVersionApi - functional programming interface
 * @export
 */
export const PromptTranslationsWithinProjectPromptVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptTranslationsWithinProjectPromptVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a translation for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {CreatePromptTranslationDto} createPromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerCreate(projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerCreate(projectId, promptId, versionTag, createPromptTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all translations for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerFindAll(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptTranslationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerFindAll(projectId, promptId, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerFindOneByLanguage(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerFindOneByLanguage(projectId, promptId, versionTag, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerFindOneByLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerRemove(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerRemove(projectId, promptId, versionTag, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerUpdate(projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerUpdate(projectId, promptId, versionTag, languageCode, updatePromptTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptTranslationsWithinProjectPromptVersionApi - factory interface
 * @export
 */
export const PromptTranslationsWithinProjectPromptVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptTranslationsWithinProjectPromptVersionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a translation for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {CreatePromptTranslationDto} createPromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerCreate(projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptTranslationDto> {
            return localVarFp.promptTranslationControllerCreate(projectId, promptId, versionTag, createPromptTranslationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all translations for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerFindAll(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptTranslationDto>> {
            return localVarFp.promptTranslationControllerFindAll(projectId, promptId, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerFindOneByLanguage(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptTranslationDto> {
            return localVarFp.promptTranslationControllerFindOneByLanguage(projectId, promptId, versionTag, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerRemove(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptTranslationControllerRemove(projectId, promptId, versionTag, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerUpdate(projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptTranslationDto> {
            return localVarFp.promptTranslationControllerUpdate(projectId, promptId, versionTag, languageCode, updatePromptTranslationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptTranslationsWithinProjectPromptVersionApi - interface
 * @export
 * @interface PromptTranslationsWithinProjectPromptVersionApi
 */
export interface PromptTranslationsWithinProjectPromptVersionApiInterface {
    /**
     * 
     * @summary Create a translation for a specific prompt version within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {CreatePromptTranslationDto} createPromptTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApiInterface
     */
    promptTranslationControllerCreate(projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptTranslationDto>;

    /**
     * 
     * @summary Get all translations for a specific prompt version within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApiInterface
     */
    promptTranslationControllerFindAll(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptTranslationDto>>;

    /**
     * 
     * @summary Get a specific translation by language code for a prompt version
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code (e.g., es-ES)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApiInterface
     */
    promptTranslationControllerFindOneByLanguage(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptTranslationDto>;

    /**
     * 
     * @summary Delete a specific translation by language code for a prompt version
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code of the translation to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApiInterface
     */
    promptTranslationControllerRemove(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update a specific translation by language code for a prompt version
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code of the translation to update
     * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApiInterface
     */
    promptTranslationControllerUpdate(projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptTranslationDto>;

}

/**
 * PromptTranslationsWithinProjectPromptVersionApi - object-oriented interface
 * @export
 * @class PromptTranslationsWithinProjectPromptVersionApi
 * @extends {BaseAPI}
 */
export class PromptTranslationsWithinProjectPromptVersionApi extends BaseAPI implements PromptTranslationsWithinProjectPromptVersionApiInterface {
    /**
     * 
     * @summary Create a translation for a specific prompt version within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {CreatePromptTranslationDto} createPromptTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerCreate(projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerCreate(projectId, promptId, versionTag, createPromptTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all translations for a specific prompt version within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerFindAll(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerFindAll(projectId, promptId, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific translation by language code for a prompt version
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code (e.g., es-ES)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerFindOneByLanguage(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerFindOneByLanguage(projectId, promptId, versionTag, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific translation by language code for a prompt version
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code of the translation to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerRemove(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerRemove(projectId, promptId, versionTag, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific translation by language code for a prompt version
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code of the translation to update
     * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerUpdate(projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerUpdate(projectId, promptId, versionTag, languageCode, updatePromptTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptVersionsWithinProjectPromptApi - axios parameter creator
 * @export
 */
export const PromptVersionsWithinProjectPromptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new version for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {CreatePromptVersionDto} createPromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerCreate: async (projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerCreate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerCreate', 'promptId', promptId)
            // verify required parameter 'createPromptVersionDto' is not null or undefined
            assertParamExists('promptVersionControllerCreate', 'createPromptVersionDto', createPromptVersionDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all versions for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerFindAll: async (projectId: string, promptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerFindAll', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerFindAll', 'promptId', promptId)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag (e.g., v1.0.0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerFindOneByTag: async (projectId: string, promptId: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerFindOneByTag', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerFindOneByTag', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptVersionControllerFindOneByTag', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerRemove: async (projectId: string, promptId: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerRemove', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerRemove', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptVersionControllerRemove', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptVersionDto} updatePromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerUpdate: async (projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerUpdate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerUpdate', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptVersionControllerUpdate', 'versionTag', versionTag)
            // verify required parameter 'updatePromptVersionDto' is not null or undefined
            assertParamExists('promptVersionControllerUpdate', 'updatePromptVersionDto', updatePromptVersionDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptVersionsWithinProjectPromptApi - functional programming interface
 * @export
 */
export const PromptVersionsWithinProjectPromptApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptVersionsWithinProjectPromptApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new version for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {CreatePromptVersionDto} createPromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerCreate(projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerCreate(projectId, promptId, createPromptVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all versions for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerFindAll(projectId: string, promptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptVersionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerFindAll(projectId, promptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag (e.g., v1.0.0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerFindOneByTag(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerFindOneByTag(projectId, promptId, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerFindOneByTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerRemove(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerRemove(projectId, promptId, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptVersionDto} updatePromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerUpdate(projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerUpdate(projectId, promptId, versionTag, updatePromptVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptVersionsWithinProjectPromptApi - factory interface
 * @export
 */
export const PromptVersionsWithinProjectPromptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptVersionsWithinProjectPromptApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new version for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {CreatePromptVersionDto} createPromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerCreate(projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto> {
            return localVarFp.promptVersionControllerCreate(projectId, promptId, createPromptVersionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all versions for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerFindAll(projectId: string, promptId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptVersionDto>> {
            return localVarFp.promptVersionControllerFindAll(projectId, promptId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag (e.g., v1.0.0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerFindOneByTag(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto> {
            return localVarFp.promptVersionControllerFindOneByTag(projectId, promptId, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerRemove(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptVersionControllerRemove(projectId, promptId, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptVersionDto} updatePromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerUpdate(projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto> {
            return localVarFp.promptVersionControllerUpdate(projectId, promptId, versionTag, updatePromptVersionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptVersionsWithinProjectPromptApi - interface
 * @export
 * @interface PromptVersionsWithinProjectPromptApi
 */
export interface PromptVersionsWithinProjectPromptApiInterface {
    /**
     * 
     * @summary Create a new version for a specific prompt within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {CreatePromptVersionDto} createPromptVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApiInterface
     */
    promptVersionControllerCreate(projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto>;

    /**
     * 
     * @summary Get all versions for a specific prompt within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApiInterface
     */
    promptVersionControllerFindAll(projectId: string, promptId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptVersionDto>>;

    /**
     * 
     * @summary Get a specific prompt version by its tag within a project/prompt
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version tag (e.g., v1.0.0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApiInterface
     */
    promptVersionControllerFindOneByTag(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto>;

    /**
     * 
     * @summary Delete a specific prompt version by its tag within a project/prompt
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApiInterface
     */
    promptVersionControllerRemove(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update a specific prompt version by its tag within a project/prompt
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version tag to update
     * @param {UpdatePromptVersionDto} updatePromptVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApiInterface
     */
    promptVersionControllerUpdate(projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto>;

}

/**
 * PromptVersionsWithinProjectPromptApi - object-oriented interface
 * @export
 * @class PromptVersionsWithinProjectPromptApi
 * @extends {BaseAPI}
 */
export class PromptVersionsWithinProjectPromptApi extends BaseAPI implements PromptVersionsWithinProjectPromptApiInterface {
    /**
     * 
     * @summary Create a new version for a specific prompt within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {CreatePromptVersionDto} createPromptVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerCreate(projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerCreate(projectId, promptId, createPromptVersionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all versions for a specific prompt within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerFindAll(projectId: string, promptId: string, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerFindAll(projectId, promptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific prompt version by its tag within a project/prompt
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version tag (e.g., v1.0.0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerFindOneByTag(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerFindOneByTag(projectId, promptId, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific prompt version by its tag within a project/prompt
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerRemove(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerRemove(projectId, promptId, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific prompt version by its tag within a project/prompt
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version tag to update
     * @param {UpdatePromptVersionDto} updatePromptVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerUpdate(projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerUpdate(projectId, promptId, versionTag, updatePromptVersionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptsApi - axios parameter creator
 * @export
 */
export const PromptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Añadir o actualizar una traducción para una versión específica de prompt en el proyecto.
         * @param {string} versionId ID de la versión a traducir (CUID)
         * @param {string} promptName Nombre del prompt padre (contextual)
         * @param {string} projectId ID del proyecto
         * @param {CreateOrUpdatePromptTranslationDto} createOrUpdatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerAddOrUpdateTranslation: async (versionId: string, promptName: string, projectId: string, createOrUpdatePromptTranslationDto: CreateOrUpdatePromptTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('promptControllerAddOrUpdateTranslation', 'versionId', versionId)
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('promptControllerAddOrUpdateTranslation', 'promptName', promptName)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerAddOrUpdateTranslation', 'projectId', projectId)
            // verify required parameter 'createOrUpdatePromptTranslationDto' is not null or undefined
            assertParamExists('promptControllerAddOrUpdateTranslation', 'createOrUpdatePromptTranslationDto', createOrUpdatePromptTranslationDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptName}/versions/{versionId}/translations`
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)))
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdatePromptTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Crea un nuevo prompt lógico dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreatePromptDto} createPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerCreate: async (projectId: string, createPromptDto: CreatePromptDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerCreate', 'projectId', projectId)
            // verify required parameter 'createPromptDto' is not null or undefined
            assertParamExists('promptControllerCreate', 'createPromptDto', createPromptDto)
            const localVarPath = `/api/projects/{projectId}/prompts`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Crear una nueva versión para un prompt existente en el proyecto.
         * @param {string} promptName Nombre del prompt padre dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreatePromptVersionDto} createPromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerCreateVersion: async (promptName: string, projectId: string, createPromptVersionDto: CreatePromptVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('promptControllerCreateVersion', 'promptName', promptName)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerCreateVersion', 'projectId', projectId)
            // verify required parameter 'createPromptVersionDto' is not null or undefined
            assertParamExists('promptControllerCreateVersion', 'createPromptVersionDto', createPromptVersionDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptName}/versions`
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene todos los prompts lógicos de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompts`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene un prompt lógico por su nombre dentro de un proyecto
         * @param {string} promptName Nombre único del prompt dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerFindOne: async (promptName: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('promptControllerFindOne', 'promptName', promptName)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptName}`
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Elimina un prompt lógico (y sus versiones asociadas por Cascade) dentro de un proyecto
         * @param {string} promptName Nombre único del prompt a eliminar dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerRemove: async (promptName: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('promptControllerRemove', 'promptName', promptName)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptName}`
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualiza metadatos de un prompt lógico (descripción, tactic, tags) dentro de un proyecto
         * @param {string} promptName Nombre único del prompt a actualizar dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {UpdatePromptDto} updatePromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerUpdate: async (promptName: string, projectId: string, updatePromptDto: UpdatePromptDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('promptControllerUpdate', 'promptName', promptName)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updatePromptDto' is not null or undefined
            assertParamExists('promptControllerUpdate', 'updatePromptDto', updatePromptDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptName}`
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptsApi - functional programming interface
 * @export
 */
export const PromptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Añadir o actualizar una traducción para una versión específica de prompt en el proyecto.
         * @param {string} versionId ID de la versión a traducir (CUID)
         * @param {string} promptName Nombre del prompt padre (contextual)
         * @param {string} projectId ID del proyecto
         * @param {CreateOrUpdatePromptTranslationDto} createOrUpdatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerAddOrUpdateTranslation(versionId: string, promptName: string, projectId: string, createOrUpdatePromptTranslationDto: CreateOrUpdatePromptTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerAddOrUpdateTranslation(versionId, promptName, projectId, createOrUpdatePromptTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerAddOrUpdateTranslation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Crea un nuevo prompt lógico dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreatePromptDto} createPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerCreate(projectId: string, createPromptDto: CreatePromptDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerCreate(projectId, createPromptDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Crear una nueva versión para un prompt existente en el proyecto.
         * @param {string} promptName Nombre del prompt padre dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreatePromptVersionDto} createPromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerCreateVersion(promptName: string, projectId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerCreateVersion(promptName, projectId, createPromptVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerCreateVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene todos los prompts lógicos de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene un prompt lógico por su nombre dentro de un proyecto
         * @param {string} promptName Nombre único del prompt dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerFindOne(promptName: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerFindOne(promptName, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Elimina un prompt lógico (y sus versiones asociadas por Cascade) dentro de un proyecto
         * @param {string} promptName Nombre único del prompt a eliminar dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerRemove(promptName: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerRemove(promptName, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualiza metadatos de un prompt lógico (descripción, tactic, tags) dentro de un proyecto
         * @param {string} promptName Nombre único del prompt a actualizar dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {UpdatePromptDto} updatePromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerUpdate(promptName: string, projectId: string, updatePromptDto: UpdatePromptDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerUpdate(promptName, projectId, updatePromptDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptsApi - factory interface
 * @export
 */
export const PromptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptsApiFp(configuration)
    return {
        /**
         * 
         * @summary Añadir o actualizar una traducción para una versión específica de prompt en el proyecto.
         * @param {string} versionId ID de la versión a traducir (CUID)
         * @param {string} promptName Nombre del prompt padre (contextual)
         * @param {string} projectId ID del proyecto
         * @param {CreateOrUpdatePromptTranslationDto} createOrUpdatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerAddOrUpdateTranslation(versionId: string, promptName: string, projectId: string, createOrUpdatePromptTranslationDto: CreateOrUpdatePromptTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptControllerAddOrUpdateTranslation(versionId, promptName, projectId, createOrUpdatePromptTranslationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Crea un nuevo prompt lógico dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreatePromptDto} createPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerCreate(projectId: string, createPromptDto: CreatePromptDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptDto> {
            return localVarFp.promptControllerCreate(projectId, createPromptDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Crear una nueva versión para un prompt existente en el proyecto.
         * @param {string} promptName Nombre del prompt padre dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreatePromptVersionDto} createPromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerCreateVersion(promptName: string, projectId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptControllerCreateVersion(promptName, projectId, createPromptVersionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene todos los prompts lógicos de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptDto>> {
            return localVarFp.promptControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene un prompt lógico por su nombre dentro de un proyecto
         * @param {string} promptName Nombre único del prompt dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerFindOne(promptName: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptDto> {
            return localVarFp.promptControllerFindOne(promptName, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Elimina un prompt lógico (y sus versiones asociadas por Cascade) dentro de un proyecto
         * @param {string} promptName Nombre único del prompt a eliminar dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerRemove(promptName: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptControllerRemove(promptName, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualiza metadatos de un prompt lógico (descripción, tactic, tags) dentro de un proyecto
         * @param {string} promptName Nombre único del prompt a actualizar dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {UpdatePromptDto} updatePromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerUpdate(promptName: string, projectId: string, updatePromptDto: UpdatePromptDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptDto> {
            return localVarFp.promptControllerUpdate(promptName, projectId, updatePromptDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptsApi - interface
 * @export
 * @interface PromptsApi
 */
export interface PromptsApiInterface {
    /**
     * 
     * @summary Añadir o actualizar una traducción para una versión específica de prompt en el proyecto.
     * @param {string} versionId ID de la versión a traducir (CUID)
     * @param {string} promptName Nombre del prompt padre (contextual)
     * @param {string} projectId ID del proyecto
     * @param {CreateOrUpdatePromptTranslationDto} createOrUpdatePromptTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    promptControllerAddOrUpdateTranslation(versionId: string, promptName: string, projectId: string, createOrUpdatePromptTranslationDto: CreateOrUpdatePromptTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Crea un nuevo prompt lógico dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreatePromptDto} createPromptDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    promptControllerCreate(projectId: string, createPromptDto: CreatePromptDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptDto>;

    /**
     * 
     * @summary Crear una nueva versión para un prompt existente en el proyecto.
     * @param {string} promptName Nombre del prompt padre dentro del proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreatePromptVersionDto} createPromptVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    promptControllerCreateVersion(promptName: string, projectId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Obtiene todos los prompts lógicos de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    promptControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptDto>>;

    /**
     * 
     * @summary Obtiene un prompt lógico por su nombre dentro de un proyecto
     * @param {string} promptName Nombre único del prompt dentro del proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    promptControllerFindOne(promptName: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptDto>;

    /**
     * 
     * @summary Elimina un prompt lógico (y sus versiones asociadas por Cascade) dentro de un proyecto
     * @param {string} promptName Nombre único del prompt a eliminar dentro del proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    promptControllerRemove(promptName: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Actualiza metadatos de un prompt lógico (descripción, tactic, tags) dentro de un proyecto
     * @param {string} promptName Nombre único del prompt a actualizar dentro del proyecto
     * @param {string} projectId ID del proyecto
     * @param {UpdatePromptDto} updatePromptDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    promptControllerUpdate(promptName: string, projectId: string, updatePromptDto: UpdatePromptDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptDto>;

}

/**
 * PromptsApi - object-oriented interface
 * @export
 * @class PromptsApi
 * @extends {BaseAPI}
 */
export class PromptsApi extends BaseAPI implements PromptsApiInterface {
    /**
     * 
     * @summary Añadir o actualizar una traducción para una versión específica de prompt en el proyecto.
     * @param {string} versionId ID de la versión a traducir (CUID)
     * @param {string} promptName Nombre del prompt padre (contextual)
     * @param {string} projectId ID del proyecto
     * @param {CreateOrUpdatePromptTranslationDto} createOrUpdatePromptTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerAddOrUpdateTranslation(versionId: string, promptName: string, projectId: string, createOrUpdatePromptTranslationDto: CreateOrUpdatePromptTranslationDto, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerAddOrUpdateTranslation(versionId, promptName, projectId, createOrUpdatePromptTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Crea un nuevo prompt lógico dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreatePromptDto} createPromptDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerCreate(projectId: string, createPromptDto: CreatePromptDto, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerCreate(projectId, createPromptDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Crear una nueva versión para un prompt existente en el proyecto.
     * @param {string} promptName Nombre del prompt padre dentro del proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreatePromptVersionDto} createPromptVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerCreateVersion(promptName: string, projectId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerCreateVersion(promptName, projectId, createPromptVersionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene todos los prompts lógicos de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene un prompt lógico por su nombre dentro de un proyecto
     * @param {string} promptName Nombre único del prompt dentro del proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerFindOne(promptName: string, projectId: string, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerFindOne(promptName, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Elimina un prompt lógico (y sus versiones asociadas por Cascade) dentro de un proyecto
     * @param {string} promptName Nombre único del prompt a eliminar dentro del proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerRemove(promptName: string, projectId: string, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerRemove(promptName, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualiza metadatos de un prompt lógico (descripción, tactic, tags) dentro de un proyecto
     * @param {string} promptName Nombre único del prompt a actualizar dentro del proyecto
     * @param {string} projectId ID del proyecto
     * @param {UpdatePromptDto} updatePromptDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerUpdate(promptName: string, projectId: string, updatePromptDto: UpdatePromptDto, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerUpdate(promptName, projectId, updatePromptDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RAGDocumentMetadataApi - axios parameter creator
 * @export
 */
export const RAGDocumentMetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crear metadatos para un documento RAG dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerCreate: async (projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerCreate', 'projectId', projectId)
            // verify required parameter 'createRagDocumentMetadataDto' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerCreate', 'createRagDocumentMetadataDto', createRagDocumentMetadataDto)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRagDocumentMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener todos los metadatos de documentos RAG de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID de los metadatos (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerFindOne: async (metadataId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerFindOne', 'metadataId', metadataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata/{metadataId}`
                .replace(`{${"metadataId"}}`, encodeURIComponent(String(metadataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Eliminar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerRemove: async (metadataId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerRemove', 'metadataId', metadataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata/{metadataId}`
                .replace(`{${"metadataId"}}`, encodeURIComponent(String(metadataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualizar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a actualizar
         * @param {string} projectId ID del proyecto
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerUpdate: async (metadataId: string, projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerUpdate', 'metadataId', metadataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerUpdate', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerUpdate', 'body', body)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata/{metadataId}`
                .replace(`{${"metadataId"}}`, encodeURIComponent(String(metadataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RAGDocumentMetadataApi - functional programming interface
 * @export
 */
export const RAGDocumentMetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RAGDocumentMetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crear metadatos para un documento RAG dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerCreate(projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RagDocumentMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerCreate(projectId, createRagDocumentMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtener todos los metadatos de documentos RAG de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RagDocumentMetadataResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtener metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID de los metadatos (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerFindOne(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RagDocumentMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerFindOne(metadataId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Eliminar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerRemove(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerRemove(metadataId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualizar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a actualizar
         * @param {string} projectId ID del proyecto
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerUpdate(metadataId: string, projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RagDocumentMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerUpdate(metadataId, projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RAGDocumentMetadataApi - factory interface
 * @export
 */
export const RAGDocumentMetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RAGDocumentMetadataApiFp(configuration)
    return {
        /**
         * 
         * @summary Crear metadatos para un documento RAG dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerCreate(projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<RagDocumentMetadataResponse> {
            return localVarFp.ragDocumentMetadataControllerCreate(projectId, createRagDocumentMetadataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtener todos los metadatos de documentos RAG de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RagDocumentMetadataResponse>> {
            return localVarFp.ragDocumentMetadataControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtener metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID de los metadatos (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerFindOne(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<RagDocumentMetadataResponse> {
            return localVarFp.ragDocumentMetadataControllerFindOne(metadataId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Eliminar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerRemove(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ragDocumentMetadataControllerRemove(metadataId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualizar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a actualizar
         * @param {string} projectId ID del proyecto
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerUpdate(metadataId: string, projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<RagDocumentMetadataResponse> {
            return localVarFp.ragDocumentMetadataControllerUpdate(metadataId, projectId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RAGDocumentMetadataApi - interface
 * @export
 * @interface RAGDocumentMetadataApi
 */
export interface RAGDocumentMetadataApiInterface {
    /**
     * 
     * @summary Crear metadatos para un documento RAG dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApiInterface
     */
    ragDocumentMetadataControllerCreate(projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<RagDocumentMetadataResponse>;

    /**
     * 
     * @summary Obtener todos los metadatos de documentos RAG de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApiInterface
     */
    ragDocumentMetadataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RagDocumentMetadataResponse>>;

    /**
     * 
     * @summary Obtener metadatos por ID dentro de un proyecto
     * @param {string} metadataId ID de los metadatos (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApiInterface
     */
    ragDocumentMetadataControllerFindOne(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<RagDocumentMetadataResponse>;

    /**
     * 
     * @summary Eliminar metadatos por ID dentro de un proyecto
     * @param {string} metadataId ID a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApiInterface
     */
    ragDocumentMetadataControllerRemove(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Actualizar metadatos por ID dentro de un proyecto
     * @param {string} metadataId ID a actualizar
     * @param {string} projectId ID del proyecto
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApiInterface
     */
    ragDocumentMetadataControllerUpdate(metadataId: string, projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<RagDocumentMetadataResponse>;

}

/**
 * RAGDocumentMetadataApi - object-oriented interface
 * @export
 * @class RAGDocumentMetadataApi
 * @extends {BaseAPI}
 */
export class RAGDocumentMetadataApi extends BaseAPI implements RAGDocumentMetadataApiInterface {
    /**
     * 
     * @summary Crear metadatos para un documento RAG dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerCreate(projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerCreate(projectId, createRagDocumentMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtener todos los metadatos de documentos RAG de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtener metadatos por ID dentro de un proyecto
     * @param {string} metadataId ID de los metadatos (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerFindOne(metadataId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerFindOne(metadataId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Eliminar metadatos por ID dentro de un proyecto
     * @param {string} metadataId ID a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerRemove(metadataId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerRemove(metadataId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualizar metadatos por ID dentro de un proyecto
     * @param {string} metadataId ID a actualizar
     * @param {string} projectId ID del proyecto
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerUpdate(metadataId: string, projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerUpdate(metadataId, projectId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RegionsApi - axios parameter creator
 * @export
 */
export const RegionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crear una nueva región para un proyecto específico
         * @param {string} projectId ID del proyecto
         * @param {CreateRegionDto} createRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerCreate: async (projectId: string, createRegionDto: CreateRegionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerCreate', 'projectId', projectId)
            // verify required parameter 'createRegionDto' is not null or undefined
            assertParamExists('regionControllerCreate', 'createRegionDto', createRegionDto)
            const localVarPath = `/api/projects/{projectId}/regions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRegionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener todas las regiones para un proyecto específico
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/regions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener una región específica dentro de un proyecto
         * @param {string} languageCode Código de idioma (ID) de la región
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerFindOne: async (languageCode: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('regionControllerFindOne', 'languageCode', languageCode)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/regions/{languageCode}`
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Eliminar una región específica dentro de un proyecto
         * @param {string} languageCode Código de idioma (ID) de la región a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerRemove: async (languageCode: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('regionControllerRemove', 'languageCode', languageCode)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/regions/{languageCode}`
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualizar una región específica dentro de un proyecto
         * @param {string} languageCode Código de idioma (ID) de la región a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdateRegionDto} updateRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerUpdate: async (languageCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('regionControllerUpdate', 'languageCode', languageCode)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateRegionDto' is not null or undefined
            assertParamExists('regionControllerUpdate', 'updateRegionDto', updateRegionDto)
            const localVarPath = `/api/projects/{projectId}/regions/{languageCode}`
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRegionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegionsApi - functional programming interface
 * @export
 */
export const RegionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crear una nueva región para un proyecto específico
         * @param {string} projectId ID del proyecto
         * @param {CreateRegionDto} createRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerCreate(projectId: string, createRegionDto: CreateRegionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRegionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerCreate(projectId, createRegionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtener todas las regiones para un proyecto específico
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateRegionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtener una región específica dentro de un proyecto
         * @param {string} languageCode Código de idioma (ID) de la región
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerFindOne(languageCode: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRegionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerFindOne(languageCode, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Eliminar una región específica dentro de un proyecto
         * @param {string} languageCode Código de idioma (ID) de la región a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerRemove(languageCode: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerRemove(languageCode, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualizar una región específica dentro de un proyecto
         * @param {string} languageCode Código de idioma (ID) de la región a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdateRegionDto} updateRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerUpdate(languageCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRegionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerUpdate(languageCode, projectId, updateRegionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RegionsApi - factory interface
 * @export
 */
export const RegionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Crear una nueva región para un proyecto específico
         * @param {string} projectId ID del proyecto
         * @param {CreateRegionDto} createRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerCreate(projectId: string, createRegionDto: CreateRegionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateRegionDto> {
            return localVarFp.regionControllerCreate(projectId, createRegionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtener todas las regiones para un proyecto específico
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateRegionDto>> {
            return localVarFp.regionControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtener una región específica dentro de un proyecto
         * @param {string} languageCode Código de idioma (ID) de la región
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerFindOne(languageCode: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateRegionDto> {
            return localVarFp.regionControllerFindOne(languageCode, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Eliminar una región específica dentro de un proyecto
         * @param {string} languageCode Código de idioma (ID) de la región a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerRemove(languageCode: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.regionControllerRemove(languageCode, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualizar una región específica dentro de un proyecto
         * @param {string} languageCode Código de idioma (ID) de la región a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdateRegionDto} updateRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerUpdate(languageCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateRegionDto> {
            return localVarFp.regionControllerUpdate(languageCode, projectId, updateRegionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegionsApi - interface
 * @export
 * @interface RegionsApi
 */
export interface RegionsApiInterface {
    /**
     * 
     * @summary Crear una nueva región para un proyecto específico
     * @param {string} projectId ID del proyecto
     * @param {CreateRegionDto} createRegionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApiInterface
     */
    regionControllerCreate(projectId: string, createRegionDto: CreateRegionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateRegionDto>;

    /**
     * 
     * @summary Obtener todas las regiones para un proyecto específico
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApiInterface
     */
    regionControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateRegionDto>>;

    /**
     * 
     * @summary Obtener una región específica dentro de un proyecto
     * @param {string} languageCode Código de idioma (ID) de la región
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApiInterface
     */
    regionControllerFindOne(languageCode: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateRegionDto>;

    /**
     * 
     * @summary Eliminar una región específica dentro de un proyecto
     * @param {string} languageCode Código de idioma (ID) de la región a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApiInterface
     */
    regionControllerRemove(languageCode: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Actualizar una región específica dentro de un proyecto
     * @param {string} languageCode Código de idioma (ID) de la región a actualizar
     * @param {string} projectId ID del proyecto
     * @param {UpdateRegionDto} updateRegionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApiInterface
     */
    regionControllerUpdate(languageCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateRegionDto>;

}

/**
 * RegionsApi - object-oriented interface
 * @export
 * @class RegionsApi
 * @extends {BaseAPI}
 */
export class RegionsApi extends BaseAPI implements RegionsApiInterface {
    /**
     * 
     * @summary Crear una nueva región para un proyecto específico
     * @param {string} projectId ID del proyecto
     * @param {CreateRegionDto} createRegionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerCreate(projectId: string, createRegionDto: CreateRegionDto, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerCreate(projectId, createRegionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtener todas las regiones para un proyecto específico
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtener una región específica dentro de un proyecto
     * @param {string} languageCode Código de idioma (ID) de la región
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerFindOne(languageCode: string, projectId: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerFindOne(languageCode, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Eliminar una región específica dentro de un proyecto
     * @param {string} languageCode Código de idioma (ID) de la región a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerRemove(languageCode: string, projectId: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerRemove(languageCode, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualizar una región específica dentro de un proyecto
     * @param {string} languageCode Código de idioma (ID) de la región a actualizar
     * @param {string} projectId ID del proyecto
     * @param {UpdateRegionDto} updateRegionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerUpdate(languageCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerUpdate(languageCode, projectId, updateRegionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServePromptApi - axios parameter creator
 * @export
 */
export const ServePromptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assembles and prepares a specific prompt version for execution with provided variables
         * @param {string} projectId Project ID
         * @param {string} promptName The unique name of the prompt within the project
         * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;)
         * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
         * @param {string} [languageCode] Optional language code for translation (e.g., \&quot;es\&quot;)
         * @param {string} [environmentName] Optional environment context (currently informational)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servePromptControllerExecutePrompt: async (projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, languageCode?: string, environmentName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('servePromptControllerExecutePrompt', 'projectId', projectId)
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('servePromptControllerExecutePrompt', 'promptName', promptName)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('servePromptControllerExecutePrompt', 'versionTag', versionTag)
            // verify required parameter 'executePromptBodyDto' is not null or undefined
            assertParamExists('servePromptControllerExecutePrompt', 'executePromptBodyDto', executePromptBodyDto)
            const localVarPath = `/serve-prompt/execute/{projectId}/{promptName}/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (languageCode !== undefined) {
                localVarQueryParameter['languageCode'] = languageCode;
            }

            if (environmentName !== undefined) {
                localVarQueryParameter['environmentName'] = environmentName;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executePromptBodyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServePromptApi - functional programming interface
 * @export
 */
export const ServePromptApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServePromptApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assembles and prepares a specific prompt version for execution with provided variables
         * @param {string} projectId Project ID
         * @param {string} promptName The unique name of the prompt within the project
         * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;)
         * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
         * @param {string} [languageCode] Optional language code for translation (e.g., \&quot;es\&quot;)
         * @param {string} [environmentName] Optional environment context (currently informational)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servePromptControllerExecutePrompt(projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, languageCode?: string, environmentName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servePromptControllerExecutePrompt(projectId, promptName, versionTag, executePromptBodyDto, languageCode, environmentName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServePromptApi.servePromptControllerExecutePrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServePromptApi - factory interface
 * @export
 */
export const ServePromptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServePromptApiFp(configuration)
    return {
        /**
         * 
         * @summary Assembles and prepares a specific prompt version for execution with provided variables
         * @param {string} projectId Project ID
         * @param {string} promptName The unique name of the prompt within the project
         * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;)
         * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
         * @param {string} [languageCode] Optional language code for translation (e.g., \&quot;es\&quot;)
         * @param {string} [environmentName] Optional environment context (currently informational)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servePromptControllerExecutePrompt(projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, languageCode?: string, environmentName?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.servePromptControllerExecutePrompt(projectId, promptName, versionTag, executePromptBodyDto, languageCode, environmentName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServePromptApi - interface
 * @export
 * @interface ServePromptApi
 */
export interface ServePromptApiInterface {
    /**
     * 
     * @summary Assembles and prepares a specific prompt version for execution with provided variables
     * @param {string} projectId Project ID
     * @param {string} promptName The unique name of the prompt within the project
     * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;)
     * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
     * @param {string} [languageCode] Optional language code for translation (e.g., \&quot;es\&quot;)
     * @param {string} [environmentName] Optional environment context (currently informational)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServePromptApiInterface
     */
    servePromptControllerExecutePrompt(projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, languageCode?: string, environmentName?: string, options?: RawAxiosRequestConfig): AxiosPromise<any>;

}

/**
 * ServePromptApi - object-oriented interface
 * @export
 * @class ServePromptApi
 * @extends {BaseAPI}
 */
export class ServePromptApi extends BaseAPI implements ServePromptApiInterface {
    /**
     * 
     * @summary Assembles and prepares a specific prompt version for execution with provided variables
     * @param {string} projectId Project ID
     * @param {string} promptName The unique name of the prompt within the project
     * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;)
     * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
     * @param {string} [languageCode] Optional language code for translation (e.g., \&quot;es\&quot;)
     * @param {string} [environmentName] Optional environment context (currently informational)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServePromptApi
     */
    public servePromptControllerExecutePrompt(projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, languageCode?: string, environmentName?: string, options?: RawAxiosRequestConfig) {
        return ServePromptApiFp(this.configuration).servePromptControllerExecutePrompt(projectId, promptName, versionTag, executePromptBodyDto, languageCode, environmentName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TacticsApi - axios parameter creator
 * @export
 */
export const TacticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crea una nueva táctica conversacional dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateTacticDto} createTacticDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tacticControllerCreate: async (projectId: string, createTacticDto: CreateTacticDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tacticControllerCreate', 'projectId', projectId)
            // verify required parameter 'createTacticDto' is not null or undefined
            assertParamExists('tacticControllerCreate', 'createTacticDto', createTacticDto)
            const localVarPath = `/api/projects/{projectId}/tactics`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTacticDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene todas las tácticas conversacionales de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tacticControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tacticControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tactics`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene una táctica por su nombre (ID) dentro de un proyecto
         * @param {string} tacticName Nombre único de la táctica
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tacticControllerFindOne: async (tacticName: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tacticName' is not null or undefined
            assertParamExists('tacticControllerFindOne', 'tacticName', tacticName)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tacticControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tactics/{tacticName}`
                .replace(`{${"tacticName"}}`, encodeURIComponent(String(tacticName)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Elimina una táctica dentro de un proyecto
         * @param {string} tacticName Nombre único de la táctica a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tacticControllerRemove: async (tacticName: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tacticName' is not null or undefined
            assertParamExists('tacticControllerRemove', 'tacticName', tacticName)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tacticControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tactics/{tacticName}`
                .replace(`{${"tacticName"}}`, encodeURIComponent(String(tacticName)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualiza una táctica existente dentro de un proyecto
         * @param {string} tacticName Nombre único de la táctica a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdateTacticDto} updateTacticDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tacticControllerUpdate: async (tacticName: string, projectId: string, updateTacticDto: UpdateTacticDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tacticName' is not null or undefined
            assertParamExists('tacticControllerUpdate', 'tacticName', tacticName)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tacticControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateTacticDto' is not null or undefined
            assertParamExists('tacticControllerUpdate', 'updateTacticDto', updateTacticDto)
            const localVarPath = `/api/projects/{projectId}/tactics/{tacticName}`
                .replace(`{${"tacticName"}}`, encodeURIComponent(String(tacticName)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTacticDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TacticsApi - functional programming interface
 * @export
 */
export const TacticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TacticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crea una nueva táctica conversacional dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateTacticDto} createTacticDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tacticControllerCreate(projectId: string, createTacticDto: CreateTacticDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TacticResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tacticControllerCreate(projectId, createTacticDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TacticsApi.tacticControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene todas las tácticas conversacionales de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tacticControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TacticResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tacticControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TacticsApi.tacticControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene una táctica por su nombre (ID) dentro de un proyecto
         * @param {string} tacticName Nombre único de la táctica
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tacticControllerFindOne(tacticName: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TacticResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tacticControllerFindOne(tacticName, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TacticsApi.tacticControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Elimina una táctica dentro de un proyecto
         * @param {string} tacticName Nombre único de la táctica a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tacticControllerRemove(tacticName: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tacticControllerRemove(tacticName, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TacticsApi.tacticControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualiza una táctica existente dentro de un proyecto
         * @param {string} tacticName Nombre único de la táctica a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdateTacticDto} updateTacticDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tacticControllerUpdate(tacticName: string, projectId: string, updateTacticDto: UpdateTacticDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TacticResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tacticControllerUpdate(tacticName, projectId, updateTacticDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TacticsApi.tacticControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TacticsApi - factory interface
 * @export
 */
export const TacticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TacticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Crea una nueva táctica conversacional dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateTacticDto} createTacticDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tacticControllerCreate(projectId: string, createTacticDto: CreateTacticDto, options?: RawAxiosRequestConfig): AxiosPromise<TacticResponse> {
            return localVarFp.tacticControllerCreate(projectId, createTacticDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene todas las tácticas conversacionales de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tacticControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TacticResponse>> {
            return localVarFp.tacticControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene una táctica por su nombre (ID) dentro de un proyecto
         * @param {string} tacticName Nombre único de la táctica
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tacticControllerFindOne(tacticName: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<TacticResponse> {
            return localVarFp.tacticControllerFindOne(tacticName, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Elimina una táctica dentro de un proyecto
         * @param {string} tacticName Nombre único de la táctica a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tacticControllerRemove(tacticName: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tacticControllerRemove(tacticName, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualiza una táctica existente dentro de un proyecto
         * @param {string} tacticName Nombre único de la táctica a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdateTacticDto} updateTacticDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tacticControllerUpdate(tacticName: string, projectId: string, updateTacticDto: UpdateTacticDto, options?: RawAxiosRequestConfig): AxiosPromise<TacticResponse> {
            return localVarFp.tacticControllerUpdate(tacticName, projectId, updateTacticDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TacticsApi - interface
 * @export
 * @interface TacticsApi
 */
export interface TacticsApiInterface {
    /**
     * 
     * @summary Crea una nueva táctica conversacional dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateTacticDto} createTacticDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TacticsApiInterface
     */
    tacticControllerCreate(projectId: string, createTacticDto: CreateTacticDto, options?: RawAxiosRequestConfig): AxiosPromise<TacticResponse>;

    /**
     * 
     * @summary Obtiene todas las tácticas conversacionales de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TacticsApiInterface
     */
    tacticControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TacticResponse>>;

    /**
     * 
     * @summary Obtiene una táctica por su nombre (ID) dentro de un proyecto
     * @param {string} tacticName Nombre único de la táctica
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TacticsApiInterface
     */
    tacticControllerFindOne(tacticName: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<TacticResponse>;

    /**
     * 
     * @summary Elimina una táctica dentro de un proyecto
     * @param {string} tacticName Nombre único de la táctica a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TacticsApiInterface
     */
    tacticControllerRemove(tacticName: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Actualiza una táctica existente dentro de un proyecto
     * @param {string} tacticName Nombre único de la táctica a actualizar
     * @param {string} projectId ID del proyecto
     * @param {UpdateTacticDto} updateTacticDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TacticsApiInterface
     */
    tacticControllerUpdate(tacticName: string, projectId: string, updateTacticDto: UpdateTacticDto, options?: RawAxiosRequestConfig): AxiosPromise<TacticResponse>;

}

/**
 * TacticsApi - object-oriented interface
 * @export
 * @class TacticsApi
 * @extends {BaseAPI}
 */
export class TacticsApi extends BaseAPI implements TacticsApiInterface {
    /**
     * 
     * @summary Crea una nueva táctica conversacional dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateTacticDto} createTacticDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TacticsApi
     */
    public tacticControllerCreate(projectId: string, createTacticDto: CreateTacticDto, options?: RawAxiosRequestConfig) {
        return TacticsApiFp(this.configuration).tacticControllerCreate(projectId, createTacticDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene todas las tácticas conversacionales de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TacticsApi
     */
    public tacticControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return TacticsApiFp(this.configuration).tacticControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene una táctica por su nombre (ID) dentro de un proyecto
     * @param {string} tacticName Nombre único de la táctica
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TacticsApi
     */
    public tacticControllerFindOne(tacticName: string, projectId: string, options?: RawAxiosRequestConfig) {
        return TacticsApiFp(this.configuration).tacticControllerFindOne(tacticName, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Elimina una táctica dentro de un proyecto
     * @param {string} tacticName Nombre único de la táctica a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TacticsApi
     */
    public tacticControllerRemove(tacticName: string, projectId: string, options?: RawAxiosRequestConfig) {
        return TacticsApiFp(this.configuration).tacticControllerRemove(tacticName, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualiza una táctica existente dentro de un proyecto
     * @param {string} tacticName Nombre único de la táctica a actualizar
     * @param {string} projectId ID del proyecto
     * @param {UpdateTacticDto} updateTacticDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TacticsApi
     */
    public tacticControllerUpdate(tacticName: string, projectId: string, updateTacticDto: UpdateTacticDto, options?: RawAxiosRequestConfig) {
        return TacticsApiFp(this.configuration).tacticControllerUpdate(tacticName, projectId, updateTacticDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crea una nueva etiqueta para un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCreate: async (projectId: string, createTagDto: CreateTagDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerCreate', 'projectId', projectId)
            // verify required parameter 'createTagDto' is not null or undefined
            assertParamExists('tagControllerCreate', 'createTagDto', createTagDto)
            const localVarPath = `/api/projects/{projectId}/tags`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene todas las etiquetas de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tags`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
         * @param {string} name Nombre único de la etiqueta en el proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindByName: async (name: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagControllerFindByName', 'name', name)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerFindByName', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tags/by-name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su ID dentro de un proyecto
         * @param {string} tagId ID único de la etiqueta (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindOne: async (tagId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagControllerFindOne', 'tagId', tagId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Elimina una etiqueta de un proyecto
         * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerRemove: async (tagId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagControllerRemove', 'tagId', tagId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualiza una etiqueta existente en un proyecto
         * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdate: async (tagId: string, projectId: string, updateTagDto: UpdateTagDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagControllerUpdate', 'tagId', tagId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateTagDto' is not null or undefined
            assertParamExists('tagControllerUpdate', 'updateTagDto', updateTagDto)
            const localVarPath = `/api/projects/{projectId}/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crea una nueva etiqueta para un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerCreate(projectId: string, createTagDto: CreateTagDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerCreate(projectId, createTagDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene todas las etiquetas de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateTagDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
         * @param {string} name Nombre único de la etiqueta en el proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerFindByName(name, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerFindByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su ID dentro de un proyecto
         * @param {string} tagId ID único de la etiqueta (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerFindOne(tagId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerFindOne(tagId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Elimina una etiqueta de un proyecto
         * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerRemove(tagId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerRemove(tagId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualiza una etiqueta existente en un proyecto
         * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerUpdate(tagId: string, projectId: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerUpdate(tagId, projectId, updateTagDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Crea una nueva etiqueta para un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCreate(projectId: string, createTagDto: CreateTagDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateTagDto> {
            return localVarFp.tagControllerCreate(projectId, createTagDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene todas las etiquetas de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateTagDto>> {
            return localVarFp.tagControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
         * @param {string} name Nombre único de la etiqueta en el proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateTagDto> {
            return localVarFp.tagControllerFindByName(name, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su ID dentro de un proyecto
         * @param {string} tagId ID único de la etiqueta (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindOne(tagId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateTagDto> {
            return localVarFp.tagControllerFindOne(tagId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Elimina una etiqueta de un proyecto
         * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerRemove(tagId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateTagDto> {
            return localVarFp.tagControllerRemove(tagId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualiza una etiqueta existente en un proyecto
         * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdate(tagId: string, projectId: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateTagDto> {
            return localVarFp.tagControllerUpdate(tagId, projectId, updateTagDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - interface
 * @export
 * @interface TagsApi
 */
export interface TagsApiInterface {
    /**
     * 
     * @summary Crea una nueva etiqueta para un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateTagDto} createTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagControllerCreate(projectId: string, createTagDto: CreateTagDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateTagDto>;

    /**
     * 
     * @summary Obtiene todas las etiquetas de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateTagDto>>;

    /**
     * 
     * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
     * @param {string} name Nombre único de la etiqueta en el proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateTagDto>;

    /**
     * 
     * @summary Obtiene una etiqueta por su ID dentro de un proyecto
     * @param {string} tagId ID único de la etiqueta (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagControllerFindOne(tagId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateTagDto>;

    /**
     * 
     * @summary Elimina una etiqueta de un proyecto
     * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagControllerRemove(tagId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateTagDto>;

    /**
     * 
     * @summary Actualiza una etiqueta existente en un proyecto
     * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
     * @param {string} projectId ID del proyecto
     * @param {UpdateTagDto} updateTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagControllerUpdate(tagId: string, projectId: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateTagDto>;

}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI implements TagsApiInterface {
    /**
     * 
     * @summary Crea una nueva etiqueta para un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateTagDto} createTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerCreate(projectId: string, createTagDto: CreateTagDto, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerCreate(projectId, createTagDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene todas las etiquetas de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
     * @param {string} name Nombre único de la etiqueta en el proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerFindByName(name, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene una etiqueta por su ID dentro de un proyecto
     * @param {string} tagId ID único de la etiqueta (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerFindOne(tagId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerFindOne(tagId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Elimina una etiqueta de un proyecto
     * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerRemove(tagId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerRemove(tagId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualiza una etiqueta existente en un proyecto
     * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
     * @param {string} projectId ID del proyecto
     * @param {UpdateTagDto} updateTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerUpdate(tagId: string, projectId: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerUpdate(tagId, projectId, updateTagDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crear un nuevo usuario
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate: async (createUserDto: CreateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('userControllerCreate', 'createUserDto', createUserDto)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener todos los usuarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener un usuario por ID
         * @param {string} id ID del usuario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerFindOne', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Eliminar un usuario por ID
         * @param {string} id ID del usuario a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerRemove', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualizar un usuario por ID
         * @param {string} id ID del usuario a actualizar
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userControllerUpdate', 'body', body)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crear un nuevo usuario
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerCreate(createUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtener todos los usuarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateUserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtener un usuario por ID
         * @param {string} id ID del usuario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Eliminar un usuario por ID
         * @param {string} id ID del usuario a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualizar un usuario por ID
         * @param {string} id ID del usuario a actualizar
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdate(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Crear un nuevo usuario
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto> {
            return localVarFp.userControllerCreate(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtener todos los usuarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateUserDto>> {
            return localVarFp.userControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtener un usuario por ID
         * @param {string} id ID del usuario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto> {
            return localVarFp.userControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Eliminar un usuario por ID
         * @param {string} id ID del usuario a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualizar un usuario por ID
         * @param {string} id ID del usuario a actualizar
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto> {
            return localVarFp.userControllerUpdate(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * 
     * @summary Crear un nuevo usuario
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto>;

    /**
     * 
     * @summary Obtener todos los usuarios
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    userControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateUserDto>>;

    /**
     * 
     * @summary Obtener un usuario por ID
     * @param {string} id ID del usuario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    userControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto>;

    /**
     * 
     * @summary Eliminar un usuario por ID
     * @param {string} id ID del usuario a eliminar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    userControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Actualizar un usuario por ID
     * @param {string} id ID del usuario a actualizar
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    userControllerUpdate(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * 
     * @summary Crear un nuevo usuario
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerCreate(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtener todos los usuarios
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindAll(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtener un usuario por ID
     * @param {string} id ID del usuario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Eliminar un usuario por ID
     * @param {string} id ID del usuario a eliminar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualizar un usuario por ID
     * @param {string} id ID del usuario a actualizar
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUpdate(id: string, body: object, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



