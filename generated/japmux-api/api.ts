/* tslint:disable */
/* eslint-disable */
/**
 * japm.app API
 * API for the japm.app Prompt Engineering application
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AiModelResponseDto
 */
export interface AiModelResponseDto {
    /**
     * Unique CUID of the AI model
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'id': string;
    /**
     * Unique name for the AI model within the project
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'name': string;
    /**
     * Provider of the AI model
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'provider'?: string | null;
    /**
     * Optional description for the AI model
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'description'?: string | null;
    /**
     * Identifier used for API calls
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'apiIdentifier'?: string | null;
    /**
     * Environment variable name for the API Key
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'apiKeyEnvVar'?: string | null;
    /**
     * Default temperature setting
     * @type {number}
     * @memberof AiModelResponseDto
     */
    'temperature'?: number | null;
    /**
     * Default max tokens setting
     * @type {number}
     * @memberof AiModelResponseDto
     */
    'maxTokens'?: number | null;
    /**
     * Whether the model reliably supports JSON output mode
     * @type {boolean}
     * @memberof AiModelResponseDto
     */
    'supportsJson'?: boolean;
    /**
     * Maximum context window size in tokens
     * @type {number}
     * @memberof AiModelResponseDto
     */
    'contextWindow'?: number | null;
    /**
     * Timestamp of creation
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'createdAt': string;
    /**
     * ID of the project this model belongs to
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface AssetTranslationStructureDto
 */
export interface AssetTranslationStructureDto {
    /**
     * Language code for the asset value translation.
     * @type {string}
     * @memberof AssetTranslationStructureDto
     */
    'languageCode': string;
    /**
     * Translated value of the asset.
     * @type {string}
     * @memberof AssetTranslationStructureDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface CreateAiModelDto
 */
export interface CreateAiModelDto {
    /**
     * Unique name for the AI model
     * @type {string}
     * @memberof CreateAiModelDto
     */
    'name': string;
    /**
     * Provider of the AI model
     * @type {string}
     * @memberof CreateAiModelDto
     */
    'provider'?: string;
    /**
     * Optional description for the AI model
     * @type {string}
     * @memberof CreateAiModelDto
     */
    'description'?: string;
    /**
     * Identifier used for API calls
     * @type {string}
     * @memberof CreateAiModelDto
     */
    'apiIdentifier'?: string;
}
/**
 * 
 * @export
 * @interface CreateAssetTranslationDto
 */
export interface CreateAssetTranslationDto {
    /**
     * Código de idioma para esta traducción (formato xx-XX)
     * @type {string}
     * @memberof CreateAssetTranslationDto
     */
    'languageCode': string;
    /**
     * Valor del asset traducido a este idioma
     * @type {string}
     * @memberof CreateAssetTranslationDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface CreateCulturalDataDto
 */
export interface CreateCulturalDataDto {
    /**
     * Unique key for the cultural data within the project
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'key': string;
    /**
     * ID (CUID) of the Region this data applies to
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'regionId': string;
    /**
     * The style of communication
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'style': string;
    /**
     * Additional notes
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface CreateEnvironmentDto
 */
export interface CreateEnvironmentDto {
    /**
     * Unique name of the environment
     * @type {string}
     * @memberof CreateEnvironmentDto
     */
    'name': string;
    /**
     * Optional description of the environment
     * @type {string}
     * @memberof CreateEnvironmentDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateOrUpdatePromptTranslationDto
 */
export interface CreateOrUpdatePromptTranslationDto {
    /**
     * Language code for the translation (e.g., es-ES, fr-FR, en). Valid BCP 47 language tag.
     * @type {string}
     * @memberof CreateOrUpdatePromptTranslationDto
     */
    'languageCode': string;
    /**
     * Translated prompt text for this version and language. Cannot be empty.
     * @type {string}
     * @memberof CreateOrUpdatePromptTranslationDto
     */
    'promptText': string;
}
/**
 * 
 * @export
 * @interface CreateProjectDto
 */
export interface CreateProjectDto {
    /**
     * Name of the project
     * @type {string}
     * @memberof CreateProjectDto
     */
    'name': string;
    /**
     * Optional description for the project
     * @type {string}
     * @memberof CreateProjectDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreatePromptAssetDto
 */
export interface CreatePromptAssetDto {
    /**
     * Clave única identificadora del asset (e.g., saludo_formal_es)
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'key': string;
    /**
     * Nombre descriptivo del asset
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'name': string;
    /**
     * Categoría para organizar assets (e.g., Saludos, Despedidas)
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'category'?: string;
    /**
     * Valor inicial del asset para la primera versión (1.0.0)
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'initialValue': string;
    /**
     * Mensaje de cambio para la primera versión
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'initialChangeMessage'?: string;
    /**
     * ID del tenant al que pertenece este asset
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'tenantId': string;
    /**
     * Traducciones iniciales para diferentes idiomas
     * @type {Array<InitialTranslationDto>}
     * @memberof CreatePromptAssetDto
     */
    'initialTranslations'?: Array<InitialTranslationDto>;
}
/**
 * 
 * @export
 * @interface CreatePromptAssetVersionDto
 */
export interface CreatePromptAssetVersionDto {
    /**
     * El valor del asset para esta nueva versión
     * @type {string}
     * @memberof CreatePromptAssetVersionDto
     */
    'value': string;
    /**
     * Etiqueta de versión (e.g., 1.0.1, 1.1.0). Si no se provee, se podría auto-incrementar o requerir.
     * @type {string}
     * @memberof CreatePromptAssetVersionDto
     */
    'versionTag'?: string;
    /**
     * Mensaje describiendo los cambios en esta versión.
     * @type {string}
     * @memberof CreatePromptAssetVersionDto
     */
    'changeMessage'?: string;
    /**
     * Código de idioma para la versión del asset (e.g., en-US, es-ES). Se obtiene del listado de regiones del proyecto.
     * @type {string}
     * @memberof CreatePromptAssetVersionDto
     */
    'languageCode': string;
}
/**
 * 
 * @export
 * @interface CreatePromptBackupRequestDto
 */
export interface CreatePromptBackupRequestDto {
    /**
     * Razón opcional para el borrado
     * @type {string}
     * @memberof CreatePromptBackupRequestDto
     */
    'deletionReason'?: string;
    /**
     * Incluir logs de ejecución en el backup (puede ser pesado)
     * @type {boolean}
     * @memberof CreatePromptBackupRequestDto
     */
    'includeExecutionLogs'?: boolean;
    /**
     * Límite de logs de ejecución a incluir
     * @type {number}
     * @memberof CreatePromptBackupRequestDto
     */
    'executionLogsLimit'?: number;
}
/**
 * 
 * @export
 * @interface CreatePromptDto
 */
export interface CreatePromptDto {
    /**
     * Name for the prompt. This will be slugified by the system to create a unique identifier.
     * @type {string}
     * @memberof CreatePromptDto
     */
    'name': string;
    /**
     * Description of the prompt\'s purpose.
     * @type {string}
     * @memberof CreatePromptDto
     */
    'description'?: string;
    /**
     * List of tag names to associate.
     * @type {Set<string>}
     * @memberof CreatePromptDto
     */
    'tags'?: Set<string>;
    /**
     * The type of prompt
     * @type {object}
     * @memberof CreatePromptDto
     */
    'type': object;
    /**
     * Base prompt text for the first version (1.0.0)
     * @type {string}
     * @memberof CreatePromptDto
     */
    'promptText': string;
    /**
     * Código de idioma para la primera versión (e.g., en-US, es-ES). Se obtiene del listado de regiones del proyecto.
     * @type {string}
     * @memberof CreatePromptDto
     */
    'languageCode': string;
    /**
     * Optional initial translations for the first version
     * @type {Array<InitialTranslationDto>}
     * @memberof CreatePromptDto
     */
    'initialTranslations'?: Array<InitialTranslationDto>;
}
/**
 * 
 * @export
 * @interface CreatePromptTranslationDto
 */
export interface CreatePromptTranslationDto {
    /**
     * Código de idioma para esta traducción (formato xx-XX)
     * @type {string}
     * @memberof CreatePromptTranslationDto
     */
    'languageCode': string;
    /**
     * Texto del prompt traducido a este idioma
     * @type {string}
     * @memberof CreatePromptTranslationDto
     */
    'promptText': string;
}
/**
 * 
 * @export
 * @interface CreatePromptVersionDto
 */
export interface CreatePromptVersionDto {
    /**
     * El valor/texto del prompt para esta nueva versión
     * @type {string}
     * @memberof CreatePromptVersionDto
     */
    'promptText': string;
    /**
     * Tag de versión para esta nueva versión (e.g., 1.0.0, 1.0.0-beta.1). Debe ser único por prompt.
     * @type {string}
     * @memberof CreatePromptVersionDto
     */
    'versionTag': string;
    /**
     * Código de idioma para esta versión (e.g., en-US, es-ES). Se obtiene del listado de regiones del proyecto.
     * @type {string}
     * @memberof CreatePromptVersionDto
     */
    'languageCode': string;
    /**
     * Mensaje describiendo los cambios en esta versión.
     * @type {string}
     * @memberof CreatePromptVersionDto
     */
    'changeMessage'?: string;
    /**
     * Optional initial translations for this new version.
     * @type {Array<InitialTranslationDto>}
     * @memberof CreatePromptVersionDto
     */
    'initialTranslations'?: Array<InitialTranslationDto>;
}
/**
 * 
 * @export
 * @interface CreateRagDocumentMetadataDto
 */
export interface CreateRagDocumentMetadataDto {
    /**
     * ID de la región asociada (opcional)
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'regionId'?: string;
    /**
     * Nombre del documento RAG
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'documentName': string;
    /**
     * Categoría (opcional)
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'category'?: string;
    /**
     * Indica si ha sido revisado por compliance
     * @type {boolean}
     * @memberof CreateRagDocumentMetadataDto
     */
    'complianceReviewed'?: boolean;
    /**
     * Nivel de riesgo PII (Información Personal Identificable) (opcional)
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'piiRiskLevel'?: string;
    /**
     * Identificador de quién lo revisó por última vez (opcional)
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'lastReviewedBy'?: string;
}
/**
 * 
 * @export
 * @interface CreateRegionDto
 */
export interface CreateRegionDto {
    /**
     * Unique language code acting as ID
     * @type {string}
     * @memberof CreateRegionDto
     */
    'languageCode': string;
    /**
     * Name of the region
     * @type {string}
     * @memberof CreateRegionDto
     */
    'name': string;
    /**
     * languageCode of the parent region (optional)
     * @type {string}
     * @memberof CreateRegionDto
     */
    'parentRegionId'?: string;
    /**
     * Time zone
     * @type {string}
     * @memberof CreateRegionDto
     */
    'timeZone'?: string;
    /**
     * Default formality level (optional)
     * @type {string}
     * @memberof CreateRegionDto
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface CreateSystemPromptDto
 */
export interface CreateSystemPromptDto {
    /**
     * Unique name/identifier for the system prompt
     * @type {string}
     * @memberof CreateSystemPromptDto
     */
    'name': string;
    /**
     * Optional description of the prompt\'s purpose
     * @type {string}
     * @memberof CreateSystemPromptDto
     */
    'description'?: string;
    /**
     * The actual text content of the system prompt
     * @type {string}
     * @memberof CreateSystemPromptDto
     */
    'promptText': string;
    /**
     * Optional category for grouping prompts
     * @type {string}
     * @memberof CreateSystemPromptDto
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface CreateTagDto
 */
export interface CreateTagDto {
    /**
     * Nombre único de la etiqueta
     * @type {string}
     * @memberof CreateTagDto
     */
    'name': string;
    /**
     * Descripción opcional de la etiqueta
     * @type {string}
     * @memberof CreateTagDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateTenantAdminUserDto
 */
export interface CreateTenantAdminUserDto {
    /**
     * Email for the initial tenant admin user.
     * @type {string}
     * @memberof CreateTenantAdminUserDto
     */
    'email': string;
    /**
     * Password for the initial tenant admin user.
     * @type {string}
     * @memberof CreateTenantAdminUserDto
     */
    'password': string;
    /**
     * Name for the initial tenant admin user.
     * @type {string}
     * @memberof CreateTenantAdminUserDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateTenantDto
 */
export interface CreateTenantDto {
    /**
     * The name of the tenant.
     * @type {string}
     * @memberof CreateTenantDto
     */
    'name': string;
    /**
     * Indicates if marketplace prompt versions require approval for this tenant. Defaults to true.
     * @type {boolean}
     * @memberof CreateTenantDto
     */
    'marketplaceRequiresApproval'?: boolean;
    /**
     * Details for creating an initial admin user for this tenant.
     * @type {CreateTenantAdminUserDto}
     * @memberof CreateTenantDto
     */
    'initialAdminUser': CreateTenantAdminUserDto;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * User\'s name
     * @type {string}
     * @memberof CreateUserDto
     */
    'name'?: string;
    /**
     * Unique user email
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * User\'s password
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
    /**
     * Role of the user
     * @type {string}
     * @memberof CreateUserDto
     */
    'role'?: CreateUserDtoRoleEnum;
}

export const CreateUserDtoRoleEnum = {
    User: 'user',
    Admin: 'admin',
    TenantAdmin: 'tenant_admin',
    PromptConsumer: 'prompt_consumer'
} as const;

export type CreateUserDtoRoleEnum = typeof CreateUserDtoRoleEnum[keyof typeof CreateUserDtoRoleEnum];

/**
 * 
 * @export
 * @interface CulturalDataResponse
 */
export interface CulturalDataResponse {
    /**
     * Unique key for the cultural data within the project
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'key': string;
    /**
     * ID (CUID) of the Region this data applies to
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'regionId': string;
    /**
     * The style of communication
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'style': string;
    /**
     * Additional notes
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'notes'?: string;
    /**
     * 
     * @type {CreateRegionDto}
     * @memberof CulturalDataResponse
     */
    'region': CreateRegionDto;
    /**
     * 
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface ExecuteLlmDto
 */
export interface ExecuteLlmDto {
    /**
     * ID del modelo de IA a utilizar
     * @type {string}
     * @memberof ExecuteLlmDto
     */
    'modelId': string;
    /**
     * ID del prompt a ejecutar
     * @type {string}
     * @memberof ExecuteLlmDto
     */
    'promptId'?: string;
    /**
     * ID del proyecto al que pertenece el prompt
     * @type {string}
     * @memberof ExecuteLlmDto
     */
    'projectId'?: string;
    /**
     * Versión del prompt a ejecutar
     * @type {string}
     * @memberof ExecuteLlmDto
     */
    'versionTag'?: string;
    /**
     * Código de idioma para el prompt
     * @type {string}
     * @memberof ExecuteLlmDto
     */
    'languageCode'?: string;
    /**
     * Variables para sustituir en el prompt
     * @type {object}
     * @memberof ExecuteLlmDto
     */
    'variables'?: object;
    /**
     * Texto del prompt a ejecutar (solo si no se proporciona promptId)
     * @type {string}
     * @memberof ExecuteLlmDto
     */
    'promptText'?: string;
}
/**
 * 
 * @export
 * @interface ExecutePromptBodyDto
 */
export interface ExecutePromptBodyDto {
    /**
     * 
     * @type {object}
     * @memberof ExecutePromptBodyDto
     */
    'variables': object;
}
/**
 * 
 * @export
 * @interface ExecuteRawDto
 */
export interface ExecuteRawDto {
    /**
     * The raw text input from the user.
     * @type {string}
     * @memberof ExecuteRawDto
     */
    'userText': string;
    /**
     * The unique name of the SystemPrompt to use.
     * @type {string}
     * @memberof ExecuteRawDto
     */
    'systemPromptName': string;
    /**
     * The unique ID (CUID) of the AIModel to use for execution.
     * @type {string}
     * @memberof ExecuteRawDto
     */
    'aiModelId': string;
    /**
     * Optional variables to substitute in the system prompt.
     * @type {object}
     * @memberof ExecuteRawDto
     */
    'variables'?: object;
}
/**
 * 
 * @export
 * @interface GeneratePromptStructureDto
 */
export interface GeneratePromptStructureDto {
    /**
     * The user prompt text to be analyzed and structured.
     * @type {string}
     * @memberof GeneratePromptStructureDto
     */
    'userPrompt': string;
}
/**
 * 
 * @export
 * @interface HealthControllerCheck200Response
 */
export interface HealthControllerCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'info'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'error'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'details'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface HealthControllerCheck200ResponseInfoValue
 */
export interface HealthControllerCheck200ResponseInfoValue {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200ResponseInfoValue
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface HealthControllerCheck503Response
 */
export interface HealthControllerCheck503Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck503Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'info'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'error'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'details'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface InitialTranslationDto
 */
export interface InitialTranslationDto {
    /**
     * ISO language code (e.g., es, en)
     * @type {string}
     * @memberof InitialTranslationDto
     */
    'languageCode': string;
    /**
     * Translated prompt text
     * @type {string}
     * @memberof InitialTranslationDto
     */
    'promptText': string;
}
/**
 * 
 * @export
 * @interface LoadPromptStructureDto
 */
export interface LoadPromptStructureDto {
    /**
     * Metadata for the prompt to be created.
     * @type {PromptMetaDto}
     * @memberof LoadPromptStructureDto
     */
    'prompt': PromptMetaDto;
    /**
     * Structure for the initial prompt version.
     * @type {PromptVersionStructureDto}
     * @memberof LoadPromptStructureDto
     */
    'version': PromptVersionStructureDto;
    /**
     * Código de idioma para la versión inicial (e.g., en-US, es-ES). Se obtiene del listado de regiones del proyecto.
     * @type {string}
     * @memberof LoadPromptStructureDto
     */
    'languageCode': string;
    /**
     * List of assets to be created and associated with the prompt (conceptually via placeholders).
     * @type {Array<PromptAssetStructureDto>}
     * @memberof LoadPromptStructureDto
     */
    'assets': Array<PromptAssetStructureDto>;
    /**
     * Optional list of tag names to associate with the prompt.
     * @type {Array<string>}
     * @memberof LoadPromptStructureDto
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * User email address
     * @type {string}
     * @memberof LoginDto
     */
    'email': string;
    /**
     * User password
     * @type {string}
     * @memberof LoginDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * JWT access token for authentication
     * @type {string}
     * @memberof LoginResponse
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
    /**
     * Unique identifier for the project
     * @type {string}
     * @memberof ProjectDto
     */
    'id': string;
    /**
     * Name of the project
     * @type {string}
     * @memberof ProjectDto
     */
    'name': string;
    /**
     * Optional description of the project
     * @type {string}
     * @memberof ProjectDto
     */
    'description'?: string;
    /**
     * ID of the tenant this project belongs to
     * @type {string}
     * @memberof ProjectDto
     */
    'tenantId': string;
    /**
     * ID of the user who owns this project
     * @type {string}
     * @memberof ProjectDto
     */
    'ownerUserId': string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof ProjectDto
     */
    'createdAt': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof ProjectDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface PromptAssetStructureDto
 */
export interface PromptAssetStructureDto {
    /**
     * Unique key for the asset in slug-case format. This key is used in {{placeholders}}.
     * @type {string}
     * @memberof PromptAssetStructureDto
     */
    'key': string;
    /**
     * Descriptive name for the asset.
     * @type {string}
     * @memberof PromptAssetStructureDto
     */
    'name': string;
    /**
     * The original extracted value for the asset.
     * @type {string}
     * @memberof PromptAssetStructureDto
     */
    'value': string;
    /**
     * Change message for this asset version.
     * @type {string}
     * @memberof PromptAssetStructureDto
     */
    'changeMessage': string;
    /**
     * Translations for the asset value.
     * @type {Array<AssetTranslationStructureDto>}
     * @memberof PromptAssetStructureDto
     */
    'translations': Array<AssetTranslationStructureDto>;
}
/**
 * 
 * @export
 * @interface PromptControllerGenerateStructure200Response
 */
export interface PromptControllerGenerateStructure200Response {
    /**
     * Estructura sugerida para el prompt
     * @type {object}
     * @memberof PromptControllerGenerateStructure200Response
     */
    'structure'?: object;
    /**
     * Explicación de la estructura sugerida
     * @type {string}
     * @memberof PromptControllerGenerateStructure200Response
     */
    'explanation'?: string;
}
/**
 * 
 * @export
 * @interface PromptControllerGenerateStructureAIRequest
 */
export interface PromptControllerGenerateStructureAIRequest {
    /**
     * The basic prompt text to analyze and structure
     * @type {string}
     * @memberof PromptControllerGenerateStructureAIRequest
     */
    'userOriginalPrompt': string;
    /**
     * AI model to use for generation
     * @type {string}
     * @memberof PromptControllerGenerateStructureAIRequest
     */
    'targetAiModel'?: string;
}
/**
 * 
 * @export
 * @interface PromptDto
 */
export interface PromptDto {
    /**
     * The unique identifier (slug) of the prompt.
     * @type {string}
     * @memberof PromptDto
     */
    'id': string;
    /**
     * The name of the prompt.
     * @type {string}
     * @memberof PromptDto
     */
    'name': string;
    /**
     * Optional description for the prompt.
     * @type {string}
     * @memberof PromptDto
     */
    'description'?: string;
    /**
     * The ID of the project this prompt belongs to.
     * @type {string}
     * @memberof PromptDto
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface PromptMetaDto
 */
export interface PromptMetaDto {
    /**
     * Suggested name for the prompt.
     * @type {string}
     * @memberof PromptMetaDto
     */
    'name': string;
    /**
     * Suggested description for the prompt.
     * @type {string}
     * @memberof PromptMetaDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface PromptVersionStructureDto
 */
export interface PromptVersionStructureDto {
    /**
     * Core prompt text, potentially including {{asset_key}} placeholders.
     * @type {string}
     * @memberof PromptVersionStructureDto
     */
    'promptText': string;
    /**
     * Change message for this version.
     * @type {string}
     * @memberof PromptVersionStructureDto
     */
    'changeMessage': string;
    /**
     * Array of asset keys (slug-case) used in this prompt version. These keys must correspond to assets defined in the main \"assets\" list.
     * @type {Array<string>}
     * @memberof PromptVersionStructureDto
     */
    'assets': Array<string>;
    /**
     * Translations for the prompt text.
     * @type {Array<PromptVersionTranslationDto>}
     * @memberof PromptVersionStructureDto
     */
    'translations': Array<PromptVersionTranslationDto>;
}
/**
 * 
 * @export
 * @interface PromptVersionTranslationDto
 */
export interface PromptVersionTranslationDto {
    /**
     * Language code for the translation.
     * @type {string}
     * @memberof PromptVersionTranslationDto
     */
    'languageCode': string;
    /**
     * Translated prompt text, potentially including {{asset_key}} placeholders.
     * @type {string}
     * @memberof PromptVersionTranslationDto
     */
    'promptText': string;
}
/**
 * 
 * @export
 * @interface RagDocumentMetadataResponse
 */
export interface RagDocumentMetadataResponse {
    /**
     * ID de la región asociada (opcional)
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'regionId'?: string;
    /**
     * Nombre del documento RAG
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'documentName': string;
    /**
     * Categoría (opcional)
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'category'?: string;
    /**
     * Indica si ha sido revisado por compliance
     * @type {boolean}
     * @memberof RagDocumentMetadataResponse
     */
    'complianceReviewed'?: boolean;
    /**
     * Nivel de riesgo PII (Información Personal Identificable) (opcional)
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'piiRiskLevel'?: string;
    /**
     * Identificador de quién lo revisó por última vez (opcional)
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'lastReviewedBy'?: string;
    /**
     * 
     * @type {CreateRegionDto}
     * @memberof RagDocumentMetadataResponse
     */
    'region'?: CreateRegionDto;
    /**
     * 
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface RegionDto
 */
export interface RegionDto {
    /**
     * Unique identifier for the region
     * @type {string}
     * @memberof RegionDto
     */
    'id': string;
    /**
     * Name of the region
     * @type {string}
     * @memberof RegionDto
     */
    'name': string;
    /**
     * Optional description of the region
     * @type {string}
     * @memberof RegionDto
     */
    'description'?: string;
    /**
     * ID of the project this region belongs to
     * @type {string}
     * @memberof RegionDto
     */
    'projectId': string;
    /**
     * Language code for the region
     * @type {string}
     * @memberof RegionDto
     */
    'languageCode': string;
    /**
     * ID of the parent region, if any
     * @type {string}
     * @memberof RegionDto
     */
    'parentRegionId'?: string | null;
    /**
     * Time zone for the region
     * @type {string}
     * @memberof RegionDto
     */
    'timeZone': string;
    /**
     * Optional notes about the region
     * @type {string}
     * @memberof RegionDto
     */
    'notes'?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof RegionDto
     */
    'createdAt': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof RegionDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface RegisterDto
 */
export interface RegisterDto {
    /**
     * User email address
     * @type {string}
     * @memberof RegisterDto
     */
    'email': string;
    /**
     * User password
     * @type {string}
     * @memberof RegisterDto
     */
    'password': string;
    /**
     * User full name
     * @type {string}
     * @memberof RegisterDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TagDto
 */
export interface TagDto {
    /**
     * Unique ID of the tag (CUID)
     * @type {string}
     * @memberof TagDto
     */
    'id': string;
    /**
     * Unique tag name within the project
     * @type {string}
     * @memberof TagDto
     */
    'name': string;
    /**
     * Description of the tag
     * @type {string}
     * @memberof TagDto
     */
    'description': string;
    /**
     * ID of the project this tag belongs to (CUID)
     * @type {string}
     * @memberof TagDto
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface TenantDto
 */
export interface TenantDto {
    /**
     * The unique identifier of the tenant.
     * @type {string}
     * @memberof TenantDto
     */
    'id': string;
    /**
     * The name of the tenant.
     * @type {string}
     * @memberof TenantDto
     */
    'name': string;
    /**
     * Indicates if marketplace prompt versions require approval for this tenant.
     * @type {boolean}
     * @memberof TenantDto
     */
    'marketplaceRequiresApproval': boolean;
    /**
     * The date and time the tenant was created.
     * @type {string}
     * @memberof TenantDto
     */
    'createdAt': string;
    /**
     * The date and time the tenant was last updated.
     * @type {string}
     * @memberof TenantDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface UpdateAiModelDto
 */
export interface UpdateAiModelDto {
    /**
     * Unique name for the AI model
     * @type {string}
     * @memberof UpdateAiModelDto
     */
    'name'?: string;
    /**
     * Provider of the AI model
     * @type {string}
     * @memberof UpdateAiModelDto
     */
    'provider'?: string;
    /**
     * Optional description for the AI model
     * @type {string}
     * @memberof UpdateAiModelDto
     */
    'description'?: string;
    /**
     * Identifier used for API calls
     * @type {string}
     * @memberof UpdateAiModelDto
     */
    'apiIdentifier'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAssetTranslationDto
 */
export interface UpdateAssetTranslationDto {
    /**
     * Valor del asset traducido a este idioma
     * @type {string}
     * @memberof UpdateAssetTranslationDto
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCulturalDataDto
 */
export interface UpdateCulturalDataDto {
    /**
     * The style of communication
     * @type {string}
     * @memberof UpdateCulturalDataDto
     */
    'style'?: string;
    /**
     * Additional notes
     * @type {string}
     * @memberof UpdateCulturalDataDto
     */
    'notes'?: string;
    /**
     * The key identifier for the cultural data
     * @type {string}
     * @memberof UpdateCulturalDataDto
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface UpdateEnvironmentDto
 */
export interface UpdateEnvironmentDto {
    /**
     * New unique name for the environment (optional)
     * @type {string}
     * @memberof UpdateEnvironmentDto
     */
    'name'?: string;
    /**
     * New optional description for the environment
     * @type {string}
     * @memberof UpdateEnvironmentDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProjectDto
 */
export interface UpdateProjectDto {
    /**
     * Name of the project
     * @type {string}
     * @memberof UpdateProjectDto
     */
    'name'?: string;
    /**
     * Optional description for the project
     * @type {string}
     * @memberof UpdateProjectDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePromptAssetDto
 */
export interface UpdatePromptAssetDto {
    /**
     * Categoría para organizar assets (e.g., Saludos, Despedidas)
     * @type {string}
     * @memberof UpdatePromptAssetDto
     */
    'category'?: string;
    /**
     * ID del tenant al que pertenece este asset
     * @type {string}
     * @memberof UpdatePromptAssetDto
     */
    'tenantId'?: string;
    /**
     * Traducciones iniciales para diferentes idiomas
     * @type {Array<InitialTranslationDto>}
     * @memberof UpdatePromptAssetDto
     */
    'initialTranslations'?: Array<InitialTranslationDto>;
    /**
     * Activa o desactiva el asset
     * @type {boolean}
     * @memberof UpdatePromptAssetDto
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdatePromptAssetVersionDto
 */
export interface UpdatePromptAssetVersionDto {
    /**
     * Nuevo valor/contenido del asset para esta versión.
     * @type {string}
     * @memberof UpdatePromptAssetVersionDto
     */
    'value'?: string;
    /**
     * Nuevo mensaje describiendo los cambios.
     * @type {string}
     * @memberof UpdatePromptAssetVersionDto
     */
    'changeMessage'?: string;
    /**
     * Código de idioma para la versión del asset (ej: en-US, es-ES).
     * @type {string}
     * @memberof UpdatePromptAssetVersionDto
     */
    'languageCode'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePromptDto
 */
export interface UpdatePromptDto {
    /**
     * New description of the prompt\'s purpose.
     * @type {string}
     * @memberof UpdatePromptDto
     */
    'description'?: string;
    /**
     * Complete list of Tag IDs to associate (replaces existing ones). Empty array to remove all.
     * @type {Array<string>}
     * @memberof UpdatePromptDto
     */
    'tagIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdatePromptTranslationDto
 */
export interface UpdatePromptTranslationDto {
    /**
     * Texto del prompt traducido a este idioma
     * @type {string}
     * @memberof UpdatePromptTranslationDto
     */
    'promptText'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePromptVersionDto
 */
export interface UpdatePromptVersionDto {
    /**
     * El valor/texto del prompt para esta nueva versión
     * @type {string}
     * @memberof UpdatePromptVersionDto
     */
    'promptText'?: string;
    /**
     * Tag de versión para esta nueva versión (e.g., 1.0.0, 1.0.0-beta.1). Debe ser único por prompt.
     * @type {string}
     * @memberof UpdatePromptVersionDto
     */
    'versionTag'?: string;
    /**
     * Código de idioma para esta versión (e.g., en-US, es-ES). Se obtiene del listado de regiones del proyecto.
     * @type {string}
     * @memberof UpdatePromptVersionDto
     */
    'languageCode'?: string;
    /**
     * Mensaje describiendo los cambios en esta versión.
     * @type {string}
     * @memberof UpdatePromptVersionDto
     */
    'changeMessage'?: string;
    /**
     * Optional initial translations for this new version.
     * @type {Array<InitialTranslationDto>}
     * @memberof UpdatePromptVersionDto
     */
    'initialTranslations'?: Array<InitialTranslationDto>;
}
/**
 * 
 * @export
 * @interface UpdateRegionDto
 */
export interface UpdateRegionDto {
    /**
     * Name of the region
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'name'?: string;
    /**
     * languageCode of the parent region (optional)
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'parentRegionId'?: string;
    /**
     * Time zone
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'timeZone'?: string;
    /**
     * Default formality level (optional)
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface UpdateSystemPromptDto
 */
export interface UpdateSystemPromptDto {
    /**
     * Unique name/identifier for the system prompt
     * @type {string}
     * @memberof UpdateSystemPromptDto
     */
    'name'?: string;
    /**
     * Optional description of the prompt\'s purpose
     * @type {string}
     * @memberof UpdateSystemPromptDto
     */
    'description'?: string;
    /**
     * The actual text content of the system prompt
     * @type {string}
     * @memberof UpdateSystemPromptDto
     */
    'promptText'?: string;
    /**
     * Optional category for grouping prompts
     * @type {string}
     * @memberof UpdateSystemPromptDto
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTagDto
 */
export interface UpdateTagDto {
    /**
     * Nuevo nombre único de la etiqueta (opcional)
     * @type {string}
     * @memberof UpdateTagDto
     */
    'name'?: string;
    /**
     * Nueva descripción opcional de la etiqueta
     * @type {string}
     * @memberof UpdateTagDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTenantDto
 */
export interface UpdateTenantDto {
    /**
     * The new name of the tenant.
     * @type {string}
     * @memberof UpdateTenantDto
     */
    'name'?: string;
    /**
     * Set if marketplace prompt versions require approval for this tenant.
     * @type {boolean}
     * @memberof UpdateTenantDto
     */
    'marketplaceRequiresApproval'?: boolean;
}
/**
 * 
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * Unique user identifier
     * @type {string}
     * @memberof UserProfileResponse
     */
    'id': string;
    /**
     * User\'s email address
     * @type {string}
     * @memberof UserProfileResponse
     */
    'email': string;
    /**
     * User\'s full name
     * @type {string}
     * @memberof UserProfileResponse
     */
    'name': string;
    /**
     * Account creation timestamp
     * @type {string}
     * @memberof UserProfileResponse
     */
    'createdAt': string;
}

/**
 * AIModelsProjectSpecificApi - axios parameter creator
 * @export
 */
export const AIModelsProjectSpecificApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new AI model for this project
         * @param {string} projectId 
         * @param {CreateAiModelDto} createAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerCreate: async (projectId: string, createAiModelDto: CreateAiModelDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerCreate', 'projectId', projectId)
            // verify required parameter 'createAiModelDto' is not null or undefined
            assertParamExists('aiModelControllerCreate', 'createAiModelDto', createAiModelDto)
            const localVarPath = `/api/projects/{projectId}/aimodels`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAiModelDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all AI models for this project (includes global models)
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/aimodels`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific AI model by ID (must belong to project or be global)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerFindOne: async (projectId: string, aiModelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerFindOne', 'projectId', projectId)
            // verify required parameter 'aiModelId' is not null or undefined
            assertParamExists('aiModelControllerFindOne', 'aiModelId', aiModelId)
            const localVarPath = `/api/projects/{projectId}/aimodels/{aiModelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"aiModelId"}}`, encodeURIComponent(String(aiModelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available Langchain provider types
         * @param {string} projectId The ID of the project (used for context/authorization, though the list is global)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerGetProviderTypes: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerGetProviderTypes', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/aimodels/providers/types`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerRemove: async (projectId: string, aiModelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerRemove', 'projectId', projectId)
            // verify required parameter 'aiModelId' is not null or undefined
            assertParamExists('aiModelControllerRemove', 'aiModelId', aiModelId)
            const localVarPath = `/api/projects/{projectId}/aimodels/{aiModelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"aiModelId"}}`, encodeURIComponent(String(aiModelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {UpdateAiModelDto} updateAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerUpdate: async (projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerUpdate', 'projectId', projectId)
            // verify required parameter 'aiModelId' is not null or undefined
            assertParamExists('aiModelControllerUpdate', 'aiModelId', aiModelId)
            // verify required parameter 'updateAiModelDto' is not null or undefined
            assertParamExists('aiModelControllerUpdate', 'updateAiModelDto', updateAiModelDto)
            const localVarPath = `/api/projects/{projectId}/aimodels/{aiModelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"aiModelId"}}`, encodeURIComponent(String(aiModelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAiModelDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIModelsProjectSpecificApi - functional programming interface
 * @export
 */
export const AIModelsProjectSpecificApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIModelsProjectSpecificApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new AI model for this project
         * @param {string} projectId 
         * @param {CreateAiModelDto} createAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerCreate(projectId: string, createAiModelDto: CreateAiModelDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AiModelResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerCreate(projectId, createAiModelDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all AI models for this project (includes global models)
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AiModelResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific AI model by ID (must belong to project or be global)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerFindOne(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AiModelResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerFindOne(projectId, aiModelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List available Langchain provider types
         * @param {string} projectId The ID of the project (used for context/authorization, though the list is global)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerGetProviderTypes(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerGetProviderTypes(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerGetProviderTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerRemove(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AiModelResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerRemove(projectId, aiModelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {UpdateAiModelDto} updateAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerUpdate(projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AiModelResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerUpdate(projectId, aiModelId, updateAiModelDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AIModelsProjectSpecificApi - factory interface
 * @export
 */
export const AIModelsProjectSpecificApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIModelsProjectSpecificApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new AI model for this project
         * @param {string} projectId 
         * @param {CreateAiModelDto} createAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerCreate(projectId: string, createAiModelDto: CreateAiModelDto, options?: RawAxiosRequestConfig): AxiosPromise<AiModelResponseDto> {
            return localVarFp.aiModelControllerCreate(projectId, createAiModelDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all AI models for this project (includes global models)
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AiModelResponseDto>> {
            return localVarFp.aiModelControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific AI model by ID (must belong to project or be global)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerFindOne(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): AxiosPromise<AiModelResponseDto> {
            return localVarFp.aiModelControllerFindOne(projectId, aiModelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List available Langchain provider types
         * @param {string} projectId The ID of the project (used for context/authorization, though the list is global)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerGetProviderTypes(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.aiModelControllerGetProviderTypes(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerRemove(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): AxiosPromise<AiModelResponseDto> {
            return localVarFp.aiModelControllerRemove(projectId, aiModelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {UpdateAiModelDto} updateAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerUpdate(projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options?: RawAxiosRequestConfig): AxiosPromise<AiModelResponseDto> {
            return localVarFp.aiModelControllerUpdate(projectId, aiModelId, updateAiModelDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIModelsProjectSpecificApi - object-oriented interface
 * @export
 * @class AIModelsProjectSpecificApi
 * @extends {BaseAPI}
 */
export class AIModelsProjectSpecificApi extends BaseAPI {
    /**
     * 
     * @summary Create a new AI model for this project
     * @param {string} projectId 
     * @param {CreateAiModelDto} createAiModelDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerCreate(projectId: string, createAiModelDto: CreateAiModelDto, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerCreate(projectId, createAiModelDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all AI models for this project (includes global models)
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific AI model by ID (must belong to project or be global)
     * @param {string} projectId Project ID
     * @param {string} aiModelId AI Model CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerFindOne(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerFindOne(projectId, aiModelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List available Langchain provider types
     * @param {string} projectId The ID of the project (used for context/authorization, though the list is global)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerGetProviderTypes(projectId: string, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerGetProviderTypes(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an AI model by ID (must belong to project)
     * @param {string} projectId Project ID
     * @param {string} aiModelId AI Model CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerRemove(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerRemove(projectId, aiModelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an AI model by ID (must belong to project)
     * @param {string} projectId Project ID
     * @param {string} aiModelId AI Model CUID
     * @param {UpdateAiModelDto} updateAiModelDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerUpdate(projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerUpdate(projectId, aiModelId, updateAiModelDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AssetTranslationsProjectPromptAssetVersionTranslationApi - axios parameter creator
 * @export
 */
export const AssetTranslationsProjectPromptAssetVersionTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a translation for a specific asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {CreateAssetTranslationDto} createAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerCreate: async (projectId: string, promptId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'promptId', promptId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'versionTag', versionTag)
            // verify required parameter 'createAssetTranslationDto' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'createAssetTranslationDto', createAssetTranslationDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}/versions/{versionTag}/translations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAssetTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all translations for a specific asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerFindAll: async (projectId: string, promptId: string, assetKey: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerFindAll', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('assetTranslationControllerFindAll', 'promptId', promptId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerFindAll', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerFindAll', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}/versions/{versionTag}/translations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific translation by language code for an asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerFindOneByLanguage: async (projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'promptId', promptId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific translation by language code for an asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerRemove: async (projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'promptId', promptId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific translation by language code for an asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerUpdate: async (projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'promptId', promptId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'languageCode', languageCode)
            // verify required parameter 'updateAssetTranslationDto' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'updateAssetTranslationDto', updateAssetTranslationDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAssetTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetTranslationsProjectPromptAssetVersionTranslationApi - functional programming interface
 * @export
 */
export const AssetTranslationsProjectPromptAssetVersionTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetTranslationsProjectPromptAssetVersionTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a translation for a specific asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {CreateAssetTranslationDto} createAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerCreate(projectId: string, promptId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerCreate(projectId, promptId, assetKey, versionTag, createAssetTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsProjectPromptAssetVersionTranslationApi.assetTranslationControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all translations for a specific asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerFindAll(projectId: string, promptId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateAssetTranslationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerFindAll(projectId, promptId, assetKey, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsProjectPromptAssetVersionTranslationApi.assetTranslationControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific translation by language code for an asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerFindOneByLanguage(projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerFindOneByLanguage(projectId, promptId, assetKey, versionTag, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsProjectPromptAssetVersionTranslationApi.assetTranslationControllerFindOneByLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific translation by language code for an asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerRemove(projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerRemove(projectId, promptId, assetKey, versionTag, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsProjectPromptAssetVersionTranslationApi.assetTranslationControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific translation by language code for an asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerUpdate(projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerUpdate(projectId, promptId, assetKey, versionTag, languageCode, updateAssetTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsProjectPromptAssetVersionTranslationApi.assetTranslationControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetTranslationsProjectPromptAssetVersionTranslationApi - factory interface
 * @export
 */
export const AssetTranslationsProjectPromptAssetVersionTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetTranslationsProjectPromptAssetVersionTranslationApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a translation for a specific asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {CreateAssetTranslationDto} createAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerCreate(projectId: string, promptId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetTranslationDto> {
            return localVarFp.assetTranslationControllerCreate(projectId, promptId, assetKey, versionTag, createAssetTranslationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all translations for a specific asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerFindAll(projectId: string, promptId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateAssetTranslationDto>> {
            return localVarFp.assetTranslationControllerFindAll(projectId, promptId, assetKey, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific translation by language code for an asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerFindOneByLanguage(projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetTranslationDto> {
            return localVarFp.assetTranslationControllerFindOneByLanguage(projectId, promptId, assetKey, versionTag, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific translation by language code for an asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerRemove(projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.assetTranslationControllerRemove(projectId, promptId, assetKey, versionTag, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific translation by language code for an asset version
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Tag of the PromptAssetVersion
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerUpdate(projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetTranslationDto> {
            return localVarFp.assetTranslationControllerUpdate(projectId, promptId, assetKey, versionTag, languageCode, updateAssetTranslationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetTranslationsProjectPromptAssetVersionTranslationApi - object-oriented interface
 * @export
 * @class AssetTranslationsProjectPromptAssetVersionTranslationApi
 * @extends {BaseAPI}
 */
export class AssetTranslationsProjectPromptAssetVersionTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Create a translation for a specific asset version
     * @param {string} projectId ID of the Project the Prompt belongs to
     * @param {string} promptId ID (slug) of the Prompt
     * @param {string} assetKey Key of the PromptAsset
     * @param {string} versionTag Tag of the PromptAssetVersion
     * @param {CreateAssetTranslationDto} createAssetTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsProjectPromptAssetVersionTranslationApi
     */
    public assetTranslationControllerCreate(projectId: string, promptId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options?: RawAxiosRequestConfig) {
        return AssetTranslationsProjectPromptAssetVersionTranslationApiFp(this.configuration).assetTranslationControllerCreate(projectId, promptId, assetKey, versionTag, createAssetTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all translations for a specific asset version
     * @param {string} projectId ID of the Project the Prompt belongs to
     * @param {string} promptId ID (slug) of the Prompt
     * @param {string} assetKey Key of the PromptAsset
     * @param {string} versionTag Tag of the PromptAssetVersion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsProjectPromptAssetVersionTranslationApi
     */
    public assetTranslationControllerFindAll(projectId: string, promptId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return AssetTranslationsProjectPromptAssetVersionTranslationApiFp(this.configuration).assetTranslationControllerFindAll(projectId, promptId, assetKey, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific translation by language code for an asset version
     * @param {string} projectId ID of the Project the Prompt belongs to
     * @param {string} promptId ID (slug) of the Prompt
     * @param {string} assetKey Key of the PromptAsset
     * @param {string} versionTag Tag of the PromptAssetVersion
     * @param {string} languageCode Language code (e.g., es-ES)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsProjectPromptAssetVersionTranslationApi
     */
    public assetTranslationControllerFindOneByLanguage(projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return AssetTranslationsProjectPromptAssetVersionTranslationApiFp(this.configuration).assetTranslationControllerFindOneByLanguage(projectId, promptId, assetKey, versionTag, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific translation by language code for an asset version
     * @param {string} projectId ID of the Project the Prompt belongs to
     * @param {string} promptId ID (slug) of the Prompt
     * @param {string} assetKey Key of the PromptAsset
     * @param {string} versionTag Tag of the PromptAssetVersion
     * @param {string} languageCode Language code of the translation to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsProjectPromptAssetVersionTranslationApi
     */
    public assetTranslationControllerRemove(projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return AssetTranslationsProjectPromptAssetVersionTranslationApiFp(this.configuration).assetTranslationControllerRemove(projectId, promptId, assetKey, versionTag, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific translation by language code for an asset version
     * @param {string} projectId ID of the Project the Prompt belongs to
     * @param {string} promptId ID (slug) of the Prompt
     * @param {string} assetKey Key of the PromptAsset
     * @param {string} versionTag Tag of the PromptAssetVersion
     * @param {string} languageCode Language code of the translation to update
     * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsProjectPromptAssetVersionTranslationApi
     */
    public assetTranslationControllerUpdate(projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options?: RawAxiosRequestConfig) {
        return AssetTranslationsProjectPromptAssetVersionTranslationApiFp(this.configuration).assetTranslationControllerUpdate(projectId, promptId, assetKey, versionTag, languageCode, updateAssetTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AutenticacinYRolesApi - axios parameter creator
 * @export
 */
export const AutenticacinYRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint para verificar si el usuario tiene rol de administrador
         * @summary Verificar acceso de administrador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerAdminCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint para verificar si el usuario está autenticado (sin requerir rol específico)
         * @summary Verificar autenticación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerAnyAuthenticatedCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/any-authenticated-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint para verificar si el usuario tiene rol de administrador de tenant
         * @summary Verificar acceso de administrador de tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerTenantAdminCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenant-admin-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint para verificar si el usuario tiene rol de usuario básico
         * @summary Verificar acceso de usuario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerUserCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutenticacinYRolesApi - functional programming interface
 * @export
 */
export const AutenticacinYRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutenticacinYRolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint para verificar si el usuario tiene rol de administrador
         * @summary Verificar acceso de administrador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerAdminCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerAdminCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutenticacinYRolesApi.appControllerAdminCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint para verificar si el usuario está autenticado (sin requerir rol específico)
         * @summary Verificar autenticación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerAnyAuthenticatedCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerAnyAuthenticatedCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutenticacinYRolesApi.appControllerAnyAuthenticatedCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint para verificar si el usuario tiene rol de administrador de tenant
         * @summary Verificar acceso de administrador de tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerTenantAdminCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerTenantAdminCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutenticacinYRolesApi.appControllerTenantAdminCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint para verificar si el usuario tiene rol de usuario básico
         * @summary Verificar acceso de usuario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerUserCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerUserCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutenticacinYRolesApi.appControllerUserCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AutenticacinYRolesApi - factory interface
 * @export
 */
export const AutenticacinYRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutenticacinYRolesApiFp(configuration)
    return {
        /**
         * Endpoint para verificar si el usuario tiene rol de administrador
         * @summary Verificar acceso de administrador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerAdminCheck(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appControllerAdminCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint para verificar si el usuario está autenticado (sin requerir rol específico)
         * @summary Verificar autenticación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerAnyAuthenticatedCheck(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appControllerAnyAuthenticatedCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint para verificar si el usuario tiene rol de administrador de tenant
         * @summary Verificar acceso de administrador de tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerTenantAdminCheck(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appControllerTenantAdminCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint para verificar si el usuario tiene rol de usuario básico
         * @summary Verificar acceso de usuario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerUserCheck(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appControllerUserCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutenticacinYRolesApi - object-oriented interface
 * @export
 * @class AutenticacinYRolesApi
 * @extends {BaseAPI}
 */
export class AutenticacinYRolesApi extends BaseAPI {
    /**
     * Endpoint para verificar si el usuario tiene rol de administrador
     * @summary Verificar acceso de administrador
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutenticacinYRolesApi
     */
    public appControllerAdminCheck(options?: RawAxiosRequestConfig) {
        return AutenticacinYRolesApiFp(this.configuration).appControllerAdminCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint para verificar si el usuario está autenticado (sin requerir rol específico)
     * @summary Verificar autenticación
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutenticacinYRolesApi
     */
    public appControllerAnyAuthenticatedCheck(options?: RawAxiosRequestConfig) {
        return AutenticacinYRolesApiFp(this.configuration).appControllerAnyAuthenticatedCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint para verificar si el usuario tiene rol de administrador de tenant
     * @summary Verificar acceso de administrador de tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutenticacinYRolesApi
     */
    public appControllerTenantAdminCheck(options?: RawAxiosRequestConfig) {
        return AutenticacinYRolesApiFp(this.configuration).appControllerTenantAdminCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint para verificar si el usuario tiene rol de usuario básico
     * @summary Verificar acceso de usuario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutenticacinYRolesApi
     */
    public appControllerUserCheck(options?: RawAxiosRequestConfig) {
        return AutenticacinYRolesApiFp(this.configuration).appControllerUserCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the profile information of the currently authenticated user
         * @summary Get user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticates a user and returns a JWT token for subsequent API calls
         * @summary User login
         * @param {LoginDto} loginDto User credentials for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user account in the system. This endpoint is publicly accessible.
         * @summary Register new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerDto: RegisterDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authControllerRegister', 'registerDto', registerDto)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the profile information of the currently authenticated user
         * @summary Get user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticates a user and returns a JWT token for subsequent API calls
         * @summary User login
         * @param {LoginDto} loginDto User credentials for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user account in the system. This endpoint is publicly accessible.
         * @summary Register new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Retrieves the profile information of the currently authenticated user
         * @summary Get user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile(options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticates a user and returns a JWT token for subsequent API calls
         * @summary User login
         * @param {LoginDto} loginDto User credentials for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user account in the system. This endpoint is publicly accessible.
         * @summary Register new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.authControllerRegister(registerDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Retrieves the profile information of the currently authenticated user
     * @summary Get user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerGetProfile(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticates a user and returns a JWT token for subsequent API calls
     * @summary User login
     * @param {LoginDto} loginDto User credentials for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user account in the system. This endpoint is publicly accessible.
     * @summary Register new user
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRegister(registerDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CulturalDataApi - axios parameter creator
 * @export
 */
export const CulturalDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates new cultural data within a project
         * @param {string} projectId Project ID
         * @param {CreateCulturalDataDto} createCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerCreate: async (projectId: string, createCulturalDataDto: CreateCulturalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerCreate', 'projectId', projectId)
            // verify required parameter 'createCulturalDataDto' is not null or undefined
            assertParamExists('culturalDataControllerCreate', 'createCulturalDataDto', createCulturalDataDto)
            const localVarPath = `/api/projects/{projectId}/cultural-data`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCulturalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all cultural data for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/cultural-data`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets cultural data by ID within a project
         * @param {string} culturalDataId Key of the cultural data (e.g., direct-and-formal)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerFindOne: async (culturalDataId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culturalDataId' is not null or undefined
            assertParamExists('culturalDataControllerFindOne', 'culturalDataId', culturalDataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/cultural-data/{culturalDataId}`
                .replace(`{${"culturalDataId"}}`, encodeURIComponent(String(culturalDataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes cultural data by ID within a project
         * @param {string} culturalDataId Key of the cultural data to delete (e.g., direct-and-formal)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerRemove: async (culturalDataId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culturalDataId' is not null or undefined
            assertParamExists('culturalDataControllerRemove', 'culturalDataId', culturalDataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/cultural-data/{culturalDataId}`
                .replace(`{${"culturalDataId"}}`, encodeURIComponent(String(culturalDataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates cultural data by ID within a project
         * @param {string} culturalDataId Key of the cultural data to update (e.g., direct-and-formal)
         * @param {string} projectId Project ID
         * @param {UpdateCulturalDataDto} updateCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerUpdate: async (culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culturalDataId' is not null or undefined
            assertParamExists('culturalDataControllerUpdate', 'culturalDataId', culturalDataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateCulturalDataDto' is not null or undefined
            assertParamExists('culturalDataControllerUpdate', 'updateCulturalDataDto', updateCulturalDataDto)
            const localVarPath = `/api/projects/{projectId}/cultural-data/{culturalDataId}`
                .replace(`{${"culturalDataId"}}`, encodeURIComponent(String(culturalDataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCulturalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CulturalDataApi - functional programming interface
 * @export
 */
export const CulturalDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CulturalDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates new cultural data within a project
         * @param {string} projectId Project ID
         * @param {CreateCulturalDataDto} createCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerCreate(projectId: string, createCulturalDataDto: CreateCulturalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CulturalDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerCreate(projectId, createCulturalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets all cultural data for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CulturalDataResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets cultural data by ID within a project
         * @param {string} culturalDataId Key of the cultural data (e.g., direct-and-formal)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerFindOne(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CulturalDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerFindOne(culturalDataId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes cultural data by ID within a project
         * @param {string} culturalDataId Key of the cultural data to delete (e.g., direct-and-formal)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerRemove(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerRemove(culturalDataId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates cultural data by ID within a project
         * @param {string} culturalDataId Key of the cultural data to update (e.g., direct-and-formal)
         * @param {string} projectId Project ID
         * @param {UpdateCulturalDataDto} updateCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerUpdate(culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CulturalDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerUpdate(culturalDataId, projectId, updateCulturalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CulturalDataApi - factory interface
 * @export
 */
export const CulturalDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CulturalDataApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates new cultural data within a project
         * @param {string} projectId Project ID
         * @param {CreateCulturalDataDto} createCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerCreate(projectId: string, createCulturalDataDto: CreateCulturalDataDto, options?: RawAxiosRequestConfig): AxiosPromise<CulturalDataResponse> {
            return localVarFp.culturalDataControllerCreate(projectId, createCulturalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all cultural data for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CulturalDataResponse>> {
            return localVarFp.culturalDataControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets cultural data by ID within a project
         * @param {string} culturalDataId Key of the cultural data (e.g., direct-and-formal)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerFindOne(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CulturalDataResponse> {
            return localVarFp.culturalDataControllerFindOne(culturalDataId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes cultural data by ID within a project
         * @param {string} culturalDataId Key of the cultural data to delete (e.g., direct-and-formal)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerRemove(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.culturalDataControllerRemove(culturalDataId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates cultural data by ID within a project
         * @param {string} culturalDataId Key of the cultural data to update (e.g., direct-and-formal)
         * @param {string} projectId Project ID
         * @param {UpdateCulturalDataDto} updateCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerUpdate(culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options?: RawAxiosRequestConfig): AxiosPromise<CulturalDataResponse> {
            return localVarFp.culturalDataControllerUpdate(culturalDataId, projectId, updateCulturalDataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CulturalDataApi - object-oriented interface
 * @export
 * @class CulturalDataApi
 * @extends {BaseAPI}
 */
export class CulturalDataApi extends BaseAPI {
    /**
     * 
     * @summary Creates new cultural data within a project
     * @param {string} projectId Project ID
     * @param {CreateCulturalDataDto} createCulturalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerCreate(projectId: string, createCulturalDataDto: CreateCulturalDataDto, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerCreate(projectId, createCulturalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all cultural data for a project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets cultural data by ID within a project
     * @param {string} culturalDataId Key of the cultural data (e.g., direct-and-formal)
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerFindOne(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerFindOne(culturalDataId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes cultural data by ID within a project
     * @param {string} culturalDataId Key of the cultural data to delete (e.g., direct-and-formal)
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerRemove(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerRemove(culturalDataId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates cultural data by ID within a project
     * @param {string} culturalDataId Key of the cultural data to update (e.g., direct-and-formal)
     * @param {string} projectId Project ID
     * @param {UpdateCulturalDataDto} updateCulturalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerUpdate(culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerUpdate(culturalDataId, projectId, updateCulturalDataDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new environment for a project
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentDto} createEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerCreate: async (projectId: string, createEnvironmentDto: CreateEnvironmentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerCreate', 'projectId', projectId)
            // verify required parameter 'createEnvironmentDto' is not null or undefined
            assertParamExists('environmentControllerCreate', 'createEnvironmentDto', createEnvironmentDto)
            const localVarPath = `/api/projects/{projectId}/environments`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEnvironmentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all environments for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/environments`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an environment by its name within a project
         * @param {string} name Unique environment name in the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindByName: async (name: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('environmentControllerFindByName', 'name', name)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerFindByName', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/environments/by-name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an environment by its ID within a project
         * @param {string} environmentId Unique environment ID (CUID)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindOne: async (environmentId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('environmentControllerFindOne', 'environmentId', environmentId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/environments/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an environment from a project
         * @param {string} environmentId Unique ID of the environment to delete (CUID)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerRemove: async (environmentId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('environmentControllerRemove', 'environmentId', environmentId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/environments/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing environment in a project
         * @param {string} environmentId Unique ID of the environment to update (CUID)
         * @param {string} projectId Project ID
         * @param {UpdateEnvironmentDto} updateEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerUpdate: async (environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('environmentControllerUpdate', 'environmentId', environmentId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateEnvironmentDto' is not null or undefined
            assertParamExists('environmentControllerUpdate', 'updateEnvironmentDto', updateEnvironmentDto)
            const localVarPath = `/api/projects/{projectId}/environments/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEnvironmentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new environment for a project
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentDto} createEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerCreate(projectId: string, createEnvironmentDto: CreateEnvironmentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerCreate(projectId, createEnvironmentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets all environments for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateEnvironmentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets an environment by its name within a project
         * @param {string} name Unique environment name in the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerFindByName(name, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerFindByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets an environment by its ID within a project
         * @param {string} environmentId Unique environment ID (CUID)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerFindOne(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerFindOne(environmentId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes an environment from a project
         * @param {string} environmentId Unique ID of the environment to delete (CUID)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerRemove(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerRemove(environmentId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an existing environment in a project
         * @param {string} environmentId Unique ID of the environment to update (CUID)
         * @param {string} projectId Project ID
         * @param {UpdateEnvironmentDto} updateEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerUpdate(environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerUpdate(environmentId, projectId, updateEnvironmentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new environment for a project
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentDto} createEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerCreate(projectId: string, createEnvironmentDto: CreateEnvironmentDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerCreate(projectId, createEnvironmentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all environments for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateEnvironmentDto>> {
            return localVarFp.environmentControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an environment by its name within a project
         * @param {string} name Unique environment name in the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerFindByName(name, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an environment by its ID within a project
         * @param {string} environmentId Unique environment ID (CUID)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindOne(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerFindOne(environmentId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an environment from a project
         * @param {string} environmentId Unique ID of the environment to delete (CUID)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerRemove(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerRemove(environmentId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an existing environment in a project
         * @param {string} environmentId Unique ID of the environment to update (CUID)
         * @param {string} projectId Project ID
         * @param {UpdateEnvironmentDto} updateEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerUpdate(environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerUpdate(environmentId, projectId, updateEnvironmentDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new environment for a project
     * @param {string} projectId Project ID
     * @param {CreateEnvironmentDto} createEnvironmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerCreate(projectId: string, createEnvironmentDto: CreateEnvironmentDto, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerCreate(projectId, createEnvironmentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all environments for a project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an environment by its name within a project
     * @param {string} name Unique environment name in the project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerFindByName(name, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an environment by its ID within a project
     * @param {string} environmentId Unique environment ID (CUID)
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerFindOne(environmentId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerFindOne(environmentId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an environment from a project
     * @param {string} environmentId Unique ID of the environment to delete (CUID)
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerRemove(environmentId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerRemove(environmentId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an existing environment in a project
     * @param {string} environmentId Unique ID of the environment to update (CUID)
     * @param {string} projectId Project ID
     * @param {UpdateEnvironmentDto} updateEnvironmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerUpdate(environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerUpdate(environmentId, projectId, updateEnvironmentDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthControllerCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthControllerCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck(options?: RawAxiosRequestConfig): AxiosPromise<HealthControllerCheck200Response> {
            return localVarFp.healthControllerCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LLMExecutionApi - axios parameter creator
 * @export
 */
export const LLMExecutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
         * @param {ExecuteLlmDto} executeLlmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        llmExecutionControllerExecuteLlm: async (executeLlmDto: ExecuteLlmDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'executeLlmDto' is not null or undefined
            assertParamExists('llmExecutionControllerExecuteLlm', 'executeLlmDto', executeLlmDto)
            const localVarPath = `/api/llm-execution/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeLlmDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LLMExecutionApi - functional programming interface
 * @export
 */
export const LLMExecutionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LLMExecutionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
         * @param {ExecuteLlmDto} executeLlmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async llmExecutionControllerExecuteLlm(executeLlmDto: ExecuteLlmDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.llmExecutionControllerExecuteLlm(executeLlmDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMExecutionApi.llmExecutionControllerExecuteLlm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LLMExecutionApi - factory interface
 * @export
 */
export const LLMExecutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LLMExecutionApiFp(configuration)
    return {
        /**
         * 
         * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
         * @param {ExecuteLlmDto} executeLlmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        llmExecutionControllerExecuteLlm(executeLlmDto: ExecuteLlmDto, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.llmExecutionControllerExecuteLlm(executeLlmDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LLMExecutionApi - object-oriented interface
 * @export
 * @class LLMExecutionApi
 * @extends {BaseAPI}
 */
export class LLMExecutionApi extends BaseAPI {
    /**
     * 
     * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
     * @param {ExecuteLlmDto} executeLlmDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMExecutionApi
     */
    public llmExecutionControllerExecuteLlm(executeLlmDto: ExecuteLlmDto, options?: RawAxiosRequestConfig) {
        return LLMExecutionApiFp(this.configuration).llmExecutionControllerExecuteLlm(executeLlmDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarketplaceApi - axios parameter creator
 * @export
 */
export const MarketplaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a paginated list of published assets for the current tenant. Results can be filtered, sorted and searched.
         * @summary Get published assets
         * @param {string} [search] Search term to filter assets by name or description
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [sortBy] Field to sort by (e.g. name, createdAt)
         * @param {MarketplaceControllerGetPublishedAssetsSortOrderEnum} [sortOrder] Sort order direction
         * @param {string} [languageCode] Language code to filter assets (e.g., en-US, es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerGetPublishedAssets: async (search?: string, page?: number, limit?: number, sortBy?: string, sortOrder?: MarketplaceControllerGetPublishedAssetsSortOrderEnum, languageCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/marketplace/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['languageCode'] = languageCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of published prompts for the current tenant. Results can be filtered, sorted and searched.
         * @summary Get published prompts
         * @param {string} [search] Search term to filter prompts by name or description
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [sortBy] Field to sort by (e.g. name, createdAt)
         * @param {MarketplaceControllerGetPublishedPromptsSortOrderEnum} [sortOrder] Sort order direction
         * @param {string} [languageCode] Language code to filter prompts (e.g., en-US, es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerGetPublishedPrompts: async (search?: string, page?: number, limit?: number, sortBy?: string, sortOrder?: MarketplaceControllerGetPublishedPromptsSortOrderEnum, languageCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/marketplace/prompts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['languageCode'] = languageCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketplaceApi - functional programming interface
 * @export
 */
export const MarketplaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketplaceApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a paginated list of published assets for the current tenant. Results can be filtered, sorted and searched.
         * @summary Get published assets
         * @param {string} [search] Search term to filter assets by name or description
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [sortBy] Field to sort by (e.g. name, createdAt)
         * @param {MarketplaceControllerGetPublishedAssetsSortOrderEnum} [sortOrder] Sort order direction
         * @param {string} [languageCode] Language code to filter assets (e.g., en-US, es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerGetPublishedAssets(search?: string, page?: number, limit?: number, sortBy?: string, sortOrder?: MarketplaceControllerGetPublishedAssetsSortOrderEnum, languageCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerGetPublishedAssets(search, page, limit, sortBy, sortOrder, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.marketplaceControllerGetPublishedAssets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of published prompts for the current tenant. Results can be filtered, sorted and searched.
         * @summary Get published prompts
         * @param {string} [search] Search term to filter prompts by name or description
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [sortBy] Field to sort by (e.g. name, createdAt)
         * @param {MarketplaceControllerGetPublishedPromptsSortOrderEnum} [sortOrder] Sort order direction
         * @param {string} [languageCode] Language code to filter prompts (e.g., en-US, es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerGetPublishedPrompts(search?: string, page?: number, limit?: number, sortBy?: string, sortOrder?: MarketplaceControllerGetPublishedPromptsSortOrderEnum, languageCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerGetPublishedPrompts(search, page, limit, sortBy, sortOrder, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.marketplaceControllerGetPublishedPrompts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarketplaceApi - factory interface
 * @export
 */
export const MarketplaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketplaceApiFp(configuration)
    return {
        /**
         * Retrieves a paginated list of published assets for the current tenant. Results can be filtered, sorted and searched.
         * @summary Get published assets
         * @param {string} [search] Search term to filter assets by name or description
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [sortBy] Field to sort by (e.g. name, createdAt)
         * @param {MarketplaceControllerGetPublishedAssetsSortOrderEnum} [sortOrder] Sort order direction
         * @param {string} [languageCode] Language code to filter assets (e.g., en-US, es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerGetPublishedAssets(search?: string, page?: number, limit?: number, sortBy?: string, sortOrder?: MarketplaceControllerGetPublishedAssetsSortOrderEnum, languageCode?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.marketplaceControllerGetPublishedAssets(search, page, limit, sortBy, sortOrder, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of published prompts for the current tenant. Results can be filtered, sorted and searched.
         * @summary Get published prompts
         * @param {string} [search] Search term to filter prompts by name or description
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [sortBy] Field to sort by (e.g. name, createdAt)
         * @param {MarketplaceControllerGetPublishedPromptsSortOrderEnum} [sortOrder] Sort order direction
         * @param {string} [languageCode] Language code to filter prompts (e.g., en-US, es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerGetPublishedPrompts(search?: string, page?: number, limit?: number, sortBy?: string, sortOrder?: MarketplaceControllerGetPublishedPromptsSortOrderEnum, languageCode?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.marketplaceControllerGetPublishedPrompts(search, page, limit, sortBy, sortOrder, languageCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketplaceApi - object-oriented interface
 * @export
 * @class MarketplaceApi
 * @extends {BaseAPI}
 */
export class MarketplaceApi extends BaseAPI {
    /**
     * Retrieves a paginated list of published assets for the current tenant. Results can be filtered, sorted and searched.
     * @summary Get published assets
     * @param {string} [search] Search term to filter assets by name or description
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {string} [sortBy] Field to sort by (e.g. name, createdAt)
     * @param {MarketplaceControllerGetPublishedAssetsSortOrderEnum} [sortOrder] Sort order direction
     * @param {string} [languageCode] Language code to filter assets (e.g., en-US, es-ES)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerGetPublishedAssets(search?: string, page?: number, limit?: number, sortBy?: string, sortOrder?: MarketplaceControllerGetPublishedAssetsSortOrderEnum, languageCode?: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerGetPublishedAssets(search, page, limit, sortBy, sortOrder, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of published prompts for the current tenant. Results can be filtered, sorted and searched.
     * @summary Get published prompts
     * @param {string} [search] Search term to filter prompts by name or description
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {string} [sortBy] Field to sort by (e.g. name, createdAt)
     * @param {MarketplaceControllerGetPublishedPromptsSortOrderEnum} [sortOrder] Sort order direction
     * @param {string} [languageCode] Language code to filter prompts (e.g., en-US, es-ES)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerGetPublishedPrompts(search?: string, page?: number, limit?: number, sortBy?: string, sortOrder?: MarketplaceControllerGetPublishedPromptsSortOrderEnum, languageCode?: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerGetPublishedPrompts(search, page, limit, sortBy, sortOrder, languageCode, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MarketplaceControllerGetPublishedAssetsSortOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type MarketplaceControllerGetPublishedAssetsSortOrderEnum = typeof MarketplaceControllerGetPublishedAssetsSortOrderEnum[keyof typeof MarketplaceControllerGetPublishedAssetsSortOrderEnum];
/**
 * @export
 */
export const MarketplaceControllerGetPublishedPromptsSortOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type MarketplaceControllerGetPublishedPromptsSortOrderEnum = typeof MarketplaceControllerGetPublishedPromptsSortOrderEnum[keyof typeof MarketplaceControllerGetPublishedPromptsSortOrderEnum];


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new project for the current tenant. Accessible by global admins or tenant admins.
         * @summary Create new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreate: async (createProjectDto: CreateProjectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectDto' is not null or undefined
            assertParamExists('projectControllerCreate', 'createProjectDto', createProjectDto)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all projects for the current tenant. Results are cached for 1 hour.
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna todos los proyectos a los que tiene acceso el usuario autenticado
         * @summary Obtener proyectos del usuario actual
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindMine: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects/mine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific project by its unique ID. Results are cached for 1 hour.
         * @summary Get project by ID
         * @param {string} id Unique project identifier (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerFindOne', 'id', id)
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a project. This is a destructive operation that requires admin privileges.
         * @summary Delete project
         * @param {string} id Unique project identifier to delete (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerRemove', 'id', id)
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing project\'s information. Accessible by global admins or tenant admins.
         * @summary Update project
         * @param {string} id Unique project identifier to update (UUID)
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdate: async (id: string, updateProjectDto: UpdateProjectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerUpdate', 'id', id)
            // verify required parameter 'updateProjectDto' is not null or undefined
            assertParamExists('projectControllerUpdate', 'updateProjectDto', updateProjectDto)
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new project for the current tenant. Accessible by global admins or tenant admins.
         * @summary Create new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerCreate(createProjectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all projects for the current tenant. Results are cached for 1 hour.
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna todos los proyectos a los que tiene acceso el usuario autenticado
         * @summary Obtener proyectos del usuario actual
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerFindMine(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateProjectDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerFindMine(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerFindMine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific project by its unique ID. Results are cached for 1 hour.
         * @summary Get project by ID
         * @param {string} id Unique project identifier (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a project. This is a destructive operation that requires admin privileges.
         * @summary Delete project
         * @param {string} id Unique project identifier to delete (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing project\'s information. Accessible by global admins or tenant admins.
         * @summary Update project
         * @param {string} id Unique project identifier to update (UUID)
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerUpdate(id, updateProjectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Creates a new project for the current tenant. Accessible by global admins or tenant admins.
         * @summary Create new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<ProjectDto> {
            return localVarFp.projectControllerCreate(createProjectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all projects for the current tenant. Results are cached for 1 hour.
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProjectDto>> {
            return localVarFp.projectControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna todos los proyectos a los que tiene acceso el usuario autenticado
         * @summary Obtener proyectos del usuario actual
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindMine(options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateProjectDto>> {
            return localVarFp.projectControllerFindMine(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific project by its unique ID. Results are cached for 1 hour.
         * @summary Get project by ID
         * @param {string} id Unique project identifier (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectDto> {
            return localVarFp.projectControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a project. This is a destructive operation that requires admin privileges.
         * @summary Delete project
         * @param {string} id Unique project identifier to delete (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing project\'s information. Accessible by global admins or tenant admins.
         * @summary Update project
         * @param {string} id Unique project identifier to update (UUID)
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<ProjectDto> {
            return localVarFp.projectControllerUpdate(id, updateProjectDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Creates a new project for the current tenant. Accessible by global admins or tenant admins.
     * @summary Create new project
     * @param {CreateProjectDto} createProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerCreate(createProjectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all projects for the current tenant. Results are cached for 1 hour.
     * @summary Get all projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerFindAll(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna todos los proyectos a los que tiene acceso el usuario autenticado
     * @summary Obtener proyectos del usuario actual
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerFindMine(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerFindMine(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific project by its unique ID. Results are cached for 1 hour.
     * @summary Get project by ID
     * @param {string} id Unique project identifier (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a project. This is a destructive operation that requires admin privileges.
     * @summary Delete project
     * @param {string} id Unique project identifier to delete (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing project\'s information. Accessible by global admins or tenant admins.
     * @summary Update project
     * @param {string} id Unique project identifier to update (UUID)
     * @param {UpdateProjectDto} updateProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerUpdate(id, updateProjectDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptAssetVersionsApi - axios parameter creator
 * @export
 */
export const PromptAssetVersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new version for a specific prompt asset
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerCreate: async (projectId: string, promptId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerCreate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptAssetVersionControllerCreate', 'promptId', promptId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerCreate', 'assetKey', assetKey)
            // verify required parameter 'createPromptAssetVersionDto' is not null or undefined
            assertParamExists('promptAssetVersionControllerCreate', 'createPromptAssetVersionDto', createPromptAssetVersionDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}/versions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptAssetVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all versions for a specific prompt asset
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} languageCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerFindAll: async (projectId: string, promptId: string, assetKey: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindAll', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindAll', 'promptId', promptId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindAll', 'assetKey', assetKey)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindAll', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}/versions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (languageCode !== undefined) {
                localVarQueryParameter['languageCode'] = languageCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific prompt asset version by its tag
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag (e.g., 1.0.0)
         * @param {string} languageCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerFindOneByTag: async (projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindOneByTag', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindOneByTag', 'promptId', promptId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindOneByTag', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindOneByTag', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindOneByTag', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (languageCode !== undefined) {
                localVarQueryParameter['languageCode'] = languageCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific prompt asset version by its tag
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerRemove: async (projectId: string, promptId: string, assetKey: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerRemove', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptAssetVersionControllerRemove', 'promptId', promptId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerRemove', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptAssetVersionControllerRemove', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request to publish an asset version to the marketplace
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerRequestPublish: async (projectId: string, promptId: string, assetKey: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerRequestPublish', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptAssetVersionControllerRequestPublish', 'promptId', promptId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerRequestPublish', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptAssetVersionControllerRequestPublish', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}/versions/{versionTag}/request-publish`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unpublish an asset version from the marketplace
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerUnpublish: async (projectId: string, promptId: string, assetKey: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerUnpublish', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptAssetVersionControllerUnpublish', 'promptId', promptId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerUnpublish', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptAssetVersionControllerUnpublish', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}/versions/{versionTag}/unpublish`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific prompt asset version by its tag
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerUpdate: async (projectId: string, promptId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'promptId', promptId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'versionTag', versionTag)
            // verify required parameter 'updatePromptAssetVersionDto' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'updatePromptAssetVersionDto', updatePromptAssetVersionDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptAssetVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptAssetVersionsApi - functional programming interface
 * @export
 */
export const PromptAssetVersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptAssetVersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new version for a specific prompt asset
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerCreate(projectId: string, promptId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerCreate(projectId, promptId, assetKey, createPromptAssetVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsApi.promptAssetVersionControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all versions for a specific prompt asset
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} languageCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerFindAll(projectId: string, promptId: string, assetKey: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptAssetVersionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerFindAll(projectId, promptId, assetKey, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsApi.promptAssetVersionControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific prompt asset version by its tag
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag (e.g., 1.0.0)
         * @param {string} languageCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerFindOneByTag(projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerFindOneByTag(projectId, promptId, assetKey, versionTag, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsApi.promptAssetVersionControllerFindOneByTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific prompt asset version by its tag
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerRemove(projectId: string, promptId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerRemove(projectId, promptId, assetKey, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsApi.promptAssetVersionControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request to publish an asset version to the marketplace
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerRequestPublish(projectId: string, promptId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerRequestPublish(projectId, promptId, assetKey, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsApi.promptAssetVersionControllerRequestPublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unpublish an asset version from the marketplace
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerUnpublish(projectId: string, promptId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerUnpublish(projectId, promptId, assetKey, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsApi.promptAssetVersionControllerUnpublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific prompt asset version by its tag
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerUpdate(projectId: string, promptId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerUpdate(projectId, promptId, assetKey, versionTag, updatePromptAssetVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsApi.promptAssetVersionControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptAssetVersionsApi - factory interface
 * @export
 */
export const PromptAssetVersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptAssetVersionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new version for a specific prompt asset
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerCreate(projectId: string, promptId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto> {
            return localVarFp.promptAssetVersionControllerCreate(projectId, promptId, assetKey, createPromptAssetVersionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all versions for a specific prompt asset
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} languageCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerFindAll(projectId: string, promptId: string, assetKey: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptAssetVersionDto>> {
            return localVarFp.promptAssetVersionControllerFindAll(projectId, promptId, assetKey, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific prompt asset version by its tag
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag (e.g., 1.0.0)
         * @param {string} languageCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerFindOneByTag(projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto> {
            return localVarFp.promptAssetVersionControllerFindOneByTag(projectId, promptId, assetKey, versionTag, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific prompt asset version by its tag
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerRemove(projectId: string, promptId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetVersionControllerRemove(projectId, promptId, assetKey, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request to publish an asset version to the marketplace
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerRequestPublish(projectId: string, promptId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto> {
            return localVarFp.promptAssetVersionControllerRequestPublish(projectId, promptId, assetKey, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unpublish an asset version from the marketplace
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerUnpublish(projectId: string, promptId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto> {
            return localVarFp.promptAssetVersionControllerUnpublish(projectId, promptId, assetKey, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific prompt asset version by its tag
         * @param {string} projectId ID of the Project the Prompt belongs to
         * @param {string} promptId ID (slug) of the Prompt
         * @param {string} assetKey Key of the PromptAsset
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerUpdate(projectId: string, promptId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto> {
            return localVarFp.promptAssetVersionControllerUpdate(projectId, promptId, assetKey, versionTag, updatePromptAssetVersionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptAssetVersionsApi - object-oriented interface
 * @export
 * @class PromptAssetVersionsApi
 * @extends {BaseAPI}
 */
export class PromptAssetVersionsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new version for a specific prompt asset
     * @param {string} projectId ID of the Project the Prompt belongs to
     * @param {string} promptId ID (slug) of the Prompt
     * @param {string} assetKey Key of the PromptAsset
     * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsApi
     */
    public promptAssetVersionControllerCreate(projectId: string, promptId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsApiFp(this.configuration).promptAssetVersionControllerCreate(projectId, promptId, assetKey, createPromptAssetVersionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all versions for a specific prompt asset
     * @param {string} projectId ID of the Project the Prompt belongs to
     * @param {string} promptId ID (slug) of the Prompt
     * @param {string} assetKey Key of the PromptAsset
     * @param {string} languageCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsApi
     */
    public promptAssetVersionControllerFindAll(projectId: string, promptId: string, assetKey: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsApiFp(this.configuration).promptAssetVersionControllerFindAll(projectId, promptId, assetKey, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific prompt asset version by its tag
     * @param {string} projectId ID of the Project the Prompt belongs to
     * @param {string} promptId ID (slug) of the Prompt
     * @param {string} assetKey Key of the PromptAsset
     * @param {string} versionTag Version tag (e.g., 1.0.0)
     * @param {string} languageCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsApi
     */
    public promptAssetVersionControllerFindOneByTag(projectId: string, promptId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsApiFp(this.configuration).promptAssetVersionControllerFindOneByTag(projectId, promptId, assetKey, versionTag, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific prompt asset version by its tag
     * @param {string} projectId ID of the Project the Prompt belongs to
     * @param {string} promptId ID (slug) of the Prompt
     * @param {string} assetKey Key of the PromptAsset
     * @param {string} versionTag Version tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsApi
     */
    public promptAssetVersionControllerRemove(projectId: string, promptId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsApiFp(this.configuration).promptAssetVersionControllerRemove(projectId, promptId, assetKey, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request to publish an asset version to the marketplace
     * @param {string} projectId ID of the Project the Prompt belongs to
     * @param {string} promptId ID (slug) of the Prompt
     * @param {string} assetKey Key of the PromptAsset
     * @param {string} versionTag Version tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsApi
     */
    public promptAssetVersionControllerRequestPublish(projectId: string, promptId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsApiFp(this.configuration).promptAssetVersionControllerRequestPublish(projectId, promptId, assetKey, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unpublish an asset version from the marketplace
     * @param {string} projectId ID of the Project the Prompt belongs to
     * @param {string} promptId ID (slug) of the Prompt
     * @param {string} assetKey Key of the PromptAsset
     * @param {string} versionTag Version tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsApi
     */
    public promptAssetVersionControllerUnpublish(projectId: string, promptId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsApiFp(this.configuration).promptAssetVersionControllerUnpublish(projectId, promptId, assetKey, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific prompt asset version by its tag
     * @param {string} projectId ID of the Project the Prompt belongs to
     * @param {string} promptId ID (slug) of the Prompt
     * @param {string} assetKey Key of the PromptAsset
     * @param {string} versionTag Version tag to update
     * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsApi
     */
    public promptAssetVersionControllerUpdate(projectId: string, promptId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsApiFp(this.configuration).promptAssetVersionControllerUpdate(projectId, promptId, assetKey, versionTag, updatePromptAssetVersionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptAssetsForASpecificPromptApi - axios parameter creator
 * @export
 */
export const PromptAssetsForASpecificPromptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crea un nuevo prompt asset (y su primera versión) para un prompt específico
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto al que pertenece el prompt
         * @param {CreatePromptAssetDto} createPromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerCreate: async (promptId: string, projectId: string, createPromptAssetDto: CreatePromptAssetDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptAssetControllerCreate', 'promptId', promptId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerCreate', 'projectId', projectId)
            // verify required parameter 'createPromptAssetDto' is not null or undefined
            assertParamExists('promptAssetControllerCreate', 'createPromptAssetDto', createPromptAssetDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets`
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene todos los prompt assets de un prompt específico
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto al que pertenece el prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerFindAll: async (promptId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptAssetControllerFindAll', 'promptId', promptId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets`
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene un prompt asset por su key dentro de un prompt específico
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto
         * @param {string} assetKey Key única del asset dentro del prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerFindOne: async (promptId: string, projectId: string, assetKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptAssetControllerFindOne', 'promptId', promptId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerFindOne', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetControllerFindOne', 'assetKey', assetKey)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}`
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un prompt
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto
         * @param {string} assetKey Key única del asset a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerRemove: async (promptId: string, projectId: string, assetKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptAssetControllerRemove', 'promptId', promptId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerRemove', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetControllerRemove', 'assetKey', assetKey)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}`
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un prompt
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto
         * @param {string} assetKey Key única del asset a actualizar
         * @param {UpdatePromptAssetDto} updatePromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerUpdate: async (promptId: string, projectId: string, assetKey: string, updatePromptAssetDto: UpdatePromptAssetDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptAssetControllerUpdate', 'promptId', promptId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerUpdate', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetControllerUpdate', 'assetKey', assetKey)
            // verify required parameter 'updatePromptAssetDto' is not null or undefined
            assertParamExists('promptAssetControllerUpdate', 'updatePromptAssetDto', updatePromptAssetDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/assets/{assetKey}`
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptAssetsForASpecificPromptApi - functional programming interface
 * @export
 */
export const PromptAssetsForASpecificPromptApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptAssetsForASpecificPromptApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crea un nuevo prompt asset (y su primera versión) para un prompt específico
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto al que pertenece el prompt
         * @param {CreatePromptAssetDto} createPromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerCreate(promptId: string, projectId: string, createPromptAssetDto: CreatePromptAssetDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerCreate(promptId, projectId, createPromptAssetDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsForASpecificPromptApi.promptAssetControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene todos los prompt assets de un prompt específico
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto al que pertenece el prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerFindAll(promptId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerFindAll(promptId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsForASpecificPromptApi.promptAssetControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene un prompt asset por su key dentro de un prompt específico
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto
         * @param {string} assetKey Key única del asset dentro del prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerFindOne(promptId: string, projectId: string, assetKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerFindOne(promptId, projectId, assetKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsForASpecificPromptApi.promptAssetControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un prompt
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto
         * @param {string} assetKey Key única del asset a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerRemove(promptId: string, projectId: string, assetKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerRemove(promptId, projectId, assetKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsForASpecificPromptApi.promptAssetControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un prompt
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto
         * @param {string} assetKey Key única del asset a actualizar
         * @param {UpdatePromptAssetDto} updatePromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerUpdate(promptId: string, projectId: string, assetKey: string, updatePromptAssetDto: UpdatePromptAssetDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerUpdate(promptId, projectId, assetKey, updatePromptAssetDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsForASpecificPromptApi.promptAssetControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptAssetsForASpecificPromptApi - factory interface
 * @export
 */
export const PromptAssetsForASpecificPromptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptAssetsForASpecificPromptApiFp(configuration)
    return {
        /**
         * 
         * @summary Crea un nuevo prompt asset (y su primera versión) para un prompt específico
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto al que pertenece el prompt
         * @param {CreatePromptAssetDto} createPromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerCreate(promptId: string, projectId: string, createPromptAssetDto: CreatePromptAssetDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerCreate(promptId, projectId, createPromptAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene todos los prompt assets de un prompt específico
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto al que pertenece el prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerFindAll(promptId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerFindAll(promptId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene un prompt asset por su key dentro de un prompt específico
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto
         * @param {string} assetKey Key única del asset dentro del prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerFindOne(promptId: string, projectId: string, assetKey: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerFindOne(promptId, projectId, assetKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un prompt
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto
         * @param {string} assetKey Key única del asset a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerRemove(promptId: string, projectId: string, assetKey: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerRemove(promptId, projectId, assetKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un prompt
         * @param {string} promptId ID (slug) del prompt padre
         * @param {string} projectId ID del proyecto
         * @param {string} assetKey Key única del asset a actualizar
         * @param {UpdatePromptAssetDto} updatePromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerUpdate(promptId: string, projectId: string, assetKey: string, updatePromptAssetDto: UpdatePromptAssetDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerUpdate(promptId, projectId, assetKey, updatePromptAssetDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptAssetsForASpecificPromptApi - object-oriented interface
 * @export
 * @class PromptAssetsForASpecificPromptApi
 * @extends {BaseAPI}
 */
export class PromptAssetsForASpecificPromptApi extends BaseAPI {
    /**
     * 
     * @summary Crea un nuevo prompt asset (y su primera versión) para un prompt específico
     * @param {string} promptId ID (slug) del prompt padre
     * @param {string} projectId ID del proyecto al que pertenece el prompt
     * @param {CreatePromptAssetDto} createPromptAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsForASpecificPromptApi
     */
    public promptAssetControllerCreate(promptId: string, projectId: string, createPromptAssetDto: CreatePromptAssetDto, options?: RawAxiosRequestConfig) {
        return PromptAssetsForASpecificPromptApiFp(this.configuration).promptAssetControllerCreate(promptId, projectId, createPromptAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene todos los prompt assets de un prompt específico
     * @param {string} promptId ID (slug) del prompt padre
     * @param {string} projectId ID del proyecto al que pertenece el prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsForASpecificPromptApi
     */
    public promptAssetControllerFindAll(promptId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetsForASpecificPromptApiFp(this.configuration).promptAssetControllerFindAll(promptId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene un prompt asset por su key dentro de un prompt específico
     * @param {string} promptId ID (slug) del prompt padre
     * @param {string} projectId ID del proyecto
     * @param {string} assetKey Key única del asset dentro del prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsForASpecificPromptApi
     */
    public promptAssetControllerFindOne(promptId: string, projectId: string, assetKey: string, options?: RawAxiosRequestConfig) {
        return PromptAssetsForASpecificPromptApiFp(this.configuration).promptAssetControllerFindOne(promptId, projectId, assetKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un prompt
     * @param {string} promptId ID (slug) del prompt padre
     * @param {string} projectId ID del proyecto
     * @param {string} assetKey Key única del asset a eliminar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsForASpecificPromptApi
     */
    public promptAssetControllerRemove(promptId: string, projectId: string, assetKey: string, options?: RawAxiosRequestConfig) {
        return PromptAssetsForASpecificPromptApiFp(this.configuration).promptAssetControllerRemove(promptId, projectId, assetKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un prompt
     * @param {string} promptId ID (slug) del prompt padre
     * @param {string} projectId ID del proyecto
     * @param {string} assetKey Key única del asset a actualizar
     * @param {UpdatePromptAssetDto} updatePromptAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsForASpecificPromptApi
     */
    public promptAssetControllerUpdate(promptId: string, projectId: string, assetKey: string, updatePromptAssetDto: UpdatePromptAssetDto, options?: RawAxiosRequestConfig) {
        return PromptAssetsForASpecificPromptApiFp(this.configuration).promptAssetControllerUpdate(promptId, projectId, assetKey, updatePromptAssetDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptTranslationsWithinProjectPromptVersionApi - axios parameter creator
 * @export
 */
export const PromptTranslationsWithinProjectPromptVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a translation for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {CreatePromptTranslationDto} createPromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerCreate: async (projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerCreate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerCreate', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerCreate', 'versionTag', versionTag)
            // verify required parameter 'createPromptTranslationDto' is not null or undefined
            assertParamExists('promptTranslationControllerCreate', 'createPromptTranslationDto', createPromptTranslationDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all translations for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerFindAll: async (projectId: string, promptId: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerFindAll', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerFindAll', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerFindAll', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific translation by language code for a prompt version. Allows resolving assets.
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {boolean} [resolveAssets] Whether to resolve asset placeholders. Defaults to false.
         * @param {string} [environmentId] Environment ID for context.
         * @param {string} [regionCode] Region code for context (e.g., for asset translations - overrides languageCode for assets if provided).
         * @param {string} [variables] JSON stringified object of variables for substitution.
         * @param {boolean} [processed] Whether to return the processed prompt with all references and variables resolved. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerFindOneByLanguage: async (projectId: string, promptId: string, versionTag: string, languageCode: string, resolveAssets?: boolean, environmentId?: string, regionCode?: string, variables?: string, processed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerFindOneByLanguage', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerFindOneByLanguage', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerFindOneByLanguage', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('promptTranslationControllerFindOneByLanguage', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resolveAssets !== undefined) {
                localVarQueryParameter['resolveAssets'] = resolveAssets;
            }

            if (environmentId !== undefined) {
                localVarQueryParameter['environmentId'] = environmentId;
            }

            if (regionCode !== undefined) {
                localVarQueryParameter['regionCode'] = regionCode;
            }

            if (variables !== undefined) {
                localVarQueryParameter['variables'] = variables;
            }

            if (processed !== undefined) {
                localVarQueryParameter['processed'] = processed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerRemove: async (projectId: string, promptId: string, versionTag: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerRemove', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerRemove', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerRemove', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('promptTranslationControllerRemove', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerUpdate: async (projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'languageCode', languageCode)
            // verify required parameter 'updatePromptTranslationDto' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'updatePromptTranslationDto', updatePromptTranslationDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptTranslationsWithinProjectPromptVersionApi - functional programming interface
 * @export
 */
export const PromptTranslationsWithinProjectPromptVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptTranslationsWithinProjectPromptVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a translation for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {CreatePromptTranslationDto} createPromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerCreate(projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerCreate(projectId, promptId, versionTag, createPromptTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all translations for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerFindAll(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptTranslationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerFindAll(projectId, promptId, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific translation by language code for a prompt version. Allows resolving assets.
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {boolean} [resolveAssets] Whether to resolve asset placeholders. Defaults to false.
         * @param {string} [environmentId] Environment ID for context.
         * @param {string} [regionCode] Region code for context (e.g., for asset translations - overrides languageCode for assets if provided).
         * @param {string} [variables] JSON stringified object of variables for substitution.
         * @param {boolean} [processed] Whether to return the processed prompt with all references and variables resolved. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerFindOneByLanguage(projectId: string, promptId: string, versionTag: string, languageCode: string, resolveAssets?: boolean, environmentId?: string, regionCode?: string, variables?: string, processed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerFindOneByLanguage(projectId, promptId, versionTag, languageCode, resolveAssets, environmentId, regionCode, variables, processed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerFindOneByLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerRemove(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerRemove(projectId, promptId, versionTag, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerUpdate(projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerUpdate(projectId, promptId, versionTag, languageCode, updatePromptTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptTranslationsWithinProjectPromptVersionApi - factory interface
 * @export
 */
export const PromptTranslationsWithinProjectPromptVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptTranslationsWithinProjectPromptVersionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a translation for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {CreatePromptTranslationDto} createPromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerCreate(projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptTranslationDto> {
            return localVarFp.promptTranslationControllerCreate(projectId, promptId, versionTag, createPromptTranslationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all translations for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerFindAll(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptTranslationDto>> {
            return localVarFp.promptTranslationControllerFindAll(projectId, promptId, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific translation by language code for a prompt version. Allows resolving assets.
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {boolean} [resolveAssets] Whether to resolve asset placeholders. Defaults to false.
         * @param {string} [environmentId] Environment ID for context.
         * @param {string} [regionCode] Region code for context (e.g., for asset translations - overrides languageCode for assets if provided).
         * @param {string} [variables] JSON stringified object of variables for substitution.
         * @param {boolean} [processed] Whether to return the processed prompt with all references and variables resolved. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerFindOneByLanguage(projectId: string, promptId: string, versionTag: string, languageCode: string, resolveAssets?: boolean, environmentId?: string, regionCode?: string, variables?: string, processed?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptTranslationDto> {
            return localVarFp.promptTranslationControllerFindOneByLanguage(projectId, promptId, versionTag, languageCode, resolveAssets, environmentId, regionCode, variables, processed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerRemove(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptTranslationControllerRemove(projectId, promptId, versionTag, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerUpdate(projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptTranslationDto> {
            return localVarFp.promptTranslationControllerUpdate(projectId, promptId, versionTag, languageCode, updatePromptTranslationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptTranslationsWithinProjectPromptVersionApi - object-oriented interface
 * @export
 * @class PromptTranslationsWithinProjectPromptVersionApi
 * @extends {BaseAPI}
 */
export class PromptTranslationsWithinProjectPromptVersionApi extends BaseAPI {
    /**
     * 
     * @summary Create a translation for a specific prompt version within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
     * @param {CreatePromptTranslationDto} createPromptTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerCreate(projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerCreate(projectId, promptId, versionTag, createPromptTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all translations for a specific prompt version within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerFindAll(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerFindAll(projectId, promptId, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific translation by language code for a prompt version. Allows resolving assets.
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
     * @param {string} languageCode Language code (e.g., es-ES)
     * @param {boolean} [resolveAssets] Whether to resolve asset placeholders. Defaults to false.
     * @param {string} [environmentId] Environment ID for context.
     * @param {string} [regionCode] Region code for context (e.g., for asset translations - overrides languageCode for assets if provided).
     * @param {string} [variables] JSON stringified object of variables for substitution.
     * @param {boolean} [processed] Whether to return the processed prompt with all references and variables resolved. Defaults to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerFindOneByLanguage(projectId: string, promptId: string, versionTag: string, languageCode: string, resolveAssets?: boolean, environmentId?: string, regionCode?: string, variables?: string, processed?: boolean, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerFindOneByLanguage(projectId, promptId, versionTag, languageCode, resolveAssets, environmentId, regionCode, variables, processed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific translation by language code for a prompt version
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
     * @param {string} languageCode Language code of the translation to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerRemove(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerRemove(projectId, promptId, versionTag, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific translation by language code for a prompt version
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
     * @param {string} languageCode Language code of the translation to update
     * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerUpdate(projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerUpdate(projectId, promptId, versionTag, languageCode, updatePromptTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptVersionsWithinProjectPromptApi - axios parameter creator
 * @export
 */
export const PromptVersionsWithinProjectPromptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new version for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {CreatePromptVersionDto} createPromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerCreate: async (projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerCreate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerCreate', 'promptId', promptId)
            // verify required parameter 'createPromptVersionDto' is not null or undefined
            assertParamExists('promptVersionControllerCreate', 'createPromptVersionDto', createPromptVersionDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all versions for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerFindAll: async (projectId: string, promptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerFindAll', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerFindAll', 'promptId', promptId)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific prompt version by its tag within a project/prompt. Allows resolving assets.
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {boolean} [resolveAssets] Whether to resolve asset placeholders. Defaults to false.
         * @param {string} [environmentId] Environment ID for context.
         * @param {string} [regionCode] Region code for context (e.g., for asset translations).
         * @param {string} [variables] JSON stringified object of variables for substitution.
         * @param {boolean} [processed] Whether to return the processed prompt with all references and variables resolved. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerFindOneByTag: async (projectId: string, promptId: string, versionTag: string, resolveAssets?: boolean, environmentId?: string, regionCode?: string, variables?: string, processed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerFindOneByTag', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerFindOneByTag', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptVersionControllerFindOneByTag', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resolveAssets !== undefined) {
                localVarQueryParameter['resolveAssets'] = resolveAssets;
            }

            if (environmentId !== undefined) {
                localVarQueryParameter['environmentId'] = environmentId;
            }

            if (regionCode !== undefined) {
                localVarQueryParameter['regionCode'] = regionCode;
            }

            if (variables !== undefined) {
                localVarQueryParameter['variables'] = variables;
            }

            if (processed !== undefined) {
                localVarQueryParameter['processed'] = processed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerRemove: async (projectId: string, promptId: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerRemove', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerRemove', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptVersionControllerRemove', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request to publish a prompt version to the marketplace
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt ID (slug)
         * @param {string} versionTag Version tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerRequestPublish: async (projectId: string, promptId: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerRequestPublish', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerRequestPublish', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptVersionControllerRequestPublish', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/request-publish`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unpublish a prompt version from the marketplace
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt ID (slug)
         * @param {string} versionTag Version tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerUnpublish: async (projectId: string, promptId: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerUnpublish', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerUnpublish', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptVersionControllerUnpublish', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/unpublish`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptVersionDto} updatePromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerUpdate: async (projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerUpdate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerUpdate', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptVersionControllerUpdate', 'versionTag', versionTag)
            // verify required parameter 'updatePromptVersionDto' is not null or undefined
            assertParamExists('promptVersionControllerUpdate', 'updatePromptVersionDto', updatePromptVersionDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptVersionsWithinProjectPromptApi - functional programming interface
 * @export
 */
export const PromptVersionsWithinProjectPromptApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptVersionsWithinProjectPromptApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new version for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {CreatePromptVersionDto} createPromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerCreate(projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerCreate(projectId, promptId, createPromptVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all versions for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerFindAll(projectId: string, promptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptVersionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerFindAll(projectId, promptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific prompt version by its tag within a project/prompt. Allows resolving assets.
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {boolean} [resolveAssets] Whether to resolve asset placeholders. Defaults to false.
         * @param {string} [environmentId] Environment ID for context.
         * @param {string} [regionCode] Region code for context (e.g., for asset translations).
         * @param {string} [variables] JSON stringified object of variables for substitution.
         * @param {boolean} [processed] Whether to return the processed prompt with all references and variables resolved. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerFindOneByTag(projectId: string, promptId: string, versionTag: string, resolveAssets?: boolean, environmentId?: string, regionCode?: string, variables?: string, processed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerFindOneByTag(projectId, promptId, versionTag, resolveAssets, environmentId, regionCode, variables, processed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerFindOneByTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerRemove(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerRemove(projectId, promptId, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request to publish a prompt version to the marketplace
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt ID (slug)
         * @param {string} versionTag Version tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerRequestPublish(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerRequestPublish(projectId, promptId, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerRequestPublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unpublish a prompt version from the marketplace
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt ID (slug)
         * @param {string} versionTag Version tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerUnpublish(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerUnpublish(projectId, promptId, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerUnpublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptVersionDto} updatePromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerUpdate(projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerUpdate(projectId, promptId, versionTag, updatePromptVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptVersionsWithinProjectPromptApi - factory interface
 * @export
 */
export const PromptVersionsWithinProjectPromptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptVersionsWithinProjectPromptApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new version for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {CreatePromptVersionDto} createPromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerCreate(projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto> {
            return localVarFp.promptVersionControllerCreate(projectId, promptId, createPromptVersionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all versions for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerFindAll(projectId: string, promptId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptVersionDto>> {
            return localVarFp.promptVersionControllerFindAll(projectId, promptId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific prompt version by its tag within a project/prompt. Allows resolving assets.
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
         * @param {boolean} [resolveAssets] Whether to resolve asset placeholders. Defaults to false.
         * @param {string} [environmentId] Environment ID for context.
         * @param {string} [regionCode] Region code for context (e.g., for asset translations).
         * @param {string} [variables] JSON stringified object of variables for substitution.
         * @param {boolean} [processed] Whether to return the processed prompt with all references and variables resolved. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerFindOneByTag(projectId: string, promptId: string, versionTag: string, resolveAssets?: boolean, environmentId?: string, regionCode?: string, variables?: string, processed?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto> {
            return localVarFp.promptVersionControllerFindOneByTag(projectId, promptId, versionTag, resolveAssets, environmentId, regionCode, variables, processed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerRemove(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptVersionControllerRemove(projectId, promptId, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request to publish a prompt version to the marketplace
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt ID (slug)
         * @param {string} versionTag Version tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerRequestPublish(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto> {
            return localVarFp.promptVersionControllerRequestPublish(projectId, promptId, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unpublish a prompt version from the marketplace
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt ID (slug)
         * @param {string} versionTag Version tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerUnpublish(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto> {
            return localVarFp.promptVersionControllerUnpublish(projectId, promptId, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptVersionDto} updatePromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerUpdate(projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto> {
            return localVarFp.promptVersionControllerUpdate(projectId, promptId, versionTag, updatePromptVersionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptVersionsWithinProjectPromptApi - object-oriented interface
 * @export
 * @class PromptVersionsWithinProjectPromptApi
 * @extends {BaseAPI}
 */
export class PromptVersionsWithinProjectPromptApi extends BaseAPI {
    /**
     * 
     * @summary Create a new version for a specific prompt within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {CreatePromptVersionDto} createPromptVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerCreate(projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerCreate(projectId, promptId, createPromptVersionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all versions for a specific prompt within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerFindAll(projectId: string, promptId: string, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerFindAll(projectId, promptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific prompt version by its tag within a project/prompt. Allows resolving assets.
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version tag (e.g., 1.0.0) or \&quot;latest\&quot; to get the most recent version
     * @param {boolean} [resolveAssets] Whether to resolve asset placeholders. Defaults to false.
     * @param {string} [environmentId] Environment ID for context.
     * @param {string} [regionCode] Region code for context (e.g., for asset translations).
     * @param {string} [variables] JSON stringified object of variables for substitution.
     * @param {boolean} [processed] Whether to return the processed prompt with all references and variables resolved. Defaults to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerFindOneByTag(projectId: string, promptId: string, versionTag: string, resolveAssets?: boolean, environmentId?: string, regionCode?: string, variables?: string, processed?: boolean, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerFindOneByTag(projectId, promptId, versionTag, resolveAssets, environmentId, regionCode, variables, processed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific prompt version by its tag within a project/prompt
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerRemove(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerRemove(projectId, promptId, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request to publish a prompt version to the marketplace
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt ID (slug)
     * @param {string} versionTag Version tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerRequestPublish(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerRequestPublish(projectId, promptId, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unpublish a prompt version from the marketplace
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt ID (slug)
     * @param {string} versionTag Version tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerUnpublish(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerUnpublish(projectId, promptId, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific prompt version by its tag within a project/prompt
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version tag to update
     * @param {UpdatePromptVersionDto} updatePromptVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerUpdate(projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerUpdate(projectId, promptId, versionTag, updatePromptVersionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptsApi - axios parameter creator
 * @export
 */
export const PromptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new prompt for the current tenant. Accessible by global admins or tenant admins.
         * @summary Create new prompt
         * @param {string} projectId 
         * @param {CreatePromptDto} createPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerCreate: async (projectId: string, createPromptDto: CreatePromptDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerCreate', 'projectId', projectId)
            // verify required parameter 'createPromptDto' is not null or undefined
            assertParamExists('promptControllerCreate', 'createPromptDto', createPromptDto)
            const localVarPath = `/api/projects/{projectId}/prompts`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a complete backup of a prompt without deleting it.
         * @summary Create prompt backup
         * @param {string} projectId ID of the project the prompt belongs to
         * @param {string} id Unique prompt identifier to backup
         * @param {CreatePromptBackupRequestDto} createPromptBackupRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerCreateBackup: async (projectId: string, id: string, createPromptBackupRequestDto: CreatePromptBackupRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerCreateBackup', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('promptControllerCreateBackup', 'id', id)
            // verify required parameter 'createPromptBackupRequestDto' is not null or undefined
            assertParamExists('promptControllerCreateBackup', 'createPromptBackupRequestDto', createPromptBackupRequestDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{id}/backup`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptBackupRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all prompts for the current tenant. Results are cached for 1 hour.
         * @summary Get all prompts
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompts`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific prompt by its unique ID. Results are cached for 1 hour.
         * @summary Get prompt by ID
         * @param {string} projectId 
         * @param {string} id Unique prompt identifier (slug)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerFindOne: async (projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerFindOne', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('promptControllerFindOne', 'id', id)
            const localVarPath = `/api/projects/{projectId}/prompts/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analiza un prompt de usuario usando un LLM y sugiere una estructura basada en las entidades del proyecto.
         * @summary Genera estructura de prompt
         * @param {string} projectId ID del proyecto
         * @param {GeneratePromptStructureDto} generatePromptStructureDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerGenerateStructure: async (projectId: string, generatePromptStructureDto: GeneratePromptStructureDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerGenerateStructure', 'projectId', projectId)
            // verify required parameter 'generatePromptStructureDto' is not null or undefined
            assertParamExists('promptControllerGenerateStructure', 'generatePromptStructureDto', generatePromptStructureDto)
            const localVarPath = `/api/projects/{projectId}/prompts/generate-structure`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generatePromptStructureDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uses AI to analyze a basic prompt and suggest a complete structure with versions, translations, and assets.
         * @summary Generate prompt structure using AI
         * @param {string} projectId ID of the project for context
         * @param {any} id Base prompt text or identifier
         * @param {PromptControllerGenerateStructureAIRequest} promptControllerGenerateStructureAIRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerGenerateStructureAI: async (projectId: string, id: any, promptControllerGenerateStructureAIRequest: PromptControllerGenerateStructureAIRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerGenerateStructureAI', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('promptControllerGenerateStructureAI', 'id', id)
            // verify required parameter 'promptControllerGenerateStructureAIRequest' is not null or undefined
            assertParamExists('promptControllerGenerateStructureAI', 'promptControllerGenerateStructureAIRequest', promptControllerGenerateStructureAIRequest)
            const localVarPath = `/api/projects/{projectId}/prompts/{id}/generate-structure`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptControllerGenerateStructureAIRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all available prompt backups for the project.
         * @summary List prompt backups
         * @param {string} projectId ID of the project to list backups for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerListBackups: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerListBackups', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompts/backups/list`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load prompt structure
         * @param {string} id ID of the prompt
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerLoadStructure: async (id: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('promptControllerLoadStructure', 'id', id)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerLoadStructure', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompts/{id}/load-structure`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a complete prompt with all its components (versions, translations, assets) from a structured input.
         * @summary Load complete prompt structure
         * @param {string} projectId ID of the project where the structure will be loaded
         * @param {LoadPromptStructureDto} loadPromptStructureDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerLoadStructureComplete: async (projectId: string, loadPromptStructureDto: LoadPromptStructureDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerLoadStructureComplete', 'projectId', projectId)
            // verify required parameter 'loadPromptStructureDto' is not null or undefined
            assertParamExists('promptControllerLoadStructureComplete', 'loadPromptStructureDto', loadPromptStructureDto)
            const localVarPath = `/api/projects/{projectId}/prompts/load-structure`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loadPromptStructureDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a prompt. This is a destructive operation that requires admin privileges.
         * @summary Delete prompt
         * @param {string} projectId 
         * @param {string} id Unique prompt identifier to delete (slug or UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerRemove: async (projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerRemove', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('promptControllerRemove', 'id', id)
            const localVarPath = `/api/projects/{projectId}/prompts/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing prompt\'s information. Accessible by global admins or tenant admins.
         * @summary Update prompt
         * @param {string} projectId 
         * @param {string} id Unique prompt identifier to update (slug or UUID)
         * @param {UpdatePromptDto} updatePromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerUpdate: async (projectId: string, id: string, updatePromptDto: UpdatePromptDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerUpdate', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('promptControllerUpdate', 'id', id)
            // verify required parameter 'updatePromptDto' is not null or undefined
            assertParamExists('promptControllerUpdate', 'updatePromptDto', updatePromptDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptsApi - functional programming interface
 * @export
 */
export const PromptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new prompt for the current tenant. Accessible by global admins or tenant admins.
         * @summary Create new prompt
         * @param {string} projectId 
         * @param {CreatePromptDto} createPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerCreate(projectId: string, createPromptDto: CreatePromptDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerCreate(projectId, createPromptDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a complete backup of a prompt without deleting it.
         * @summary Create prompt backup
         * @param {string} projectId ID of the project the prompt belongs to
         * @param {string} id Unique prompt identifier to backup
         * @param {CreatePromptBackupRequestDto} createPromptBackupRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerCreateBackup(projectId: string, id: string, createPromptBackupRequestDto: CreatePromptBackupRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerCreateBackup(projectId, id, createPromptBackupRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerCreateBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all prompts for the current tenant. Results are cached for 1 hour.
         * @summary Get all prompts
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromptDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific prompt by its unique ID. Results are cached for 1 hour.
         * @summary Get prompt by ID
         * @param {string} projectId 
         * @param {string} id Unique prompt identifier (slug)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerFindOne(projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerFindOne(projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analiza un prompt de usuario usando un LLM y sugiere una estructura basada en las entidades del proyecto.
         * @summary Genera estructura de prompt
         * @param {string} projectId ID del proyecto
         * @param {GeneratePromptStructureDto} generatePromptStructureDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerGenerateStructure(projectId: string, generatePromptStructureDto: GeneratePromptStructureDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptControllerGenerateStructure200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerGenerateStructure(projectId, generatePromptStructureDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerGenerateStructure']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uses AI to analyze a basic prompt and suggest a complete structure with versions, translations, and assets.
         * @summary Generate prompt structure using AI
         * @param {string} projectId ID of the project for context
         * @param {any} id Base prompt text or identifier
         * @param {PromptControllerGenerateStructureAIRequest} promptControllerGenerateStructureAIRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerGenerateStructureAI(projectId: string, id: any, promptControllerGenerateStructureAIRequest: PromptControllerGenerateStructureAIRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerGenerateStructureAI(projectId, id, promptControllerGenerateStructureAIRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerGenerateStructureAI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all available prompt backups for the project.
         * @summary List prompt backups
         * @param {string} projectId ID of the project to list backups for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerListBackups(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerListBackups(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerListBackups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Load prompt structure
         * @param {string} id ID of the prompt
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerLoadStructure(id: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerLoadStructure(id, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerLoadStructure']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a complete prompt with all its components (versions, translations, assets) from a structured input.
         * @summary Load complete prompt structure
         * @param {string} projectId ID of the project where the structure will be loaded
         * @param {LoadPromptStructureDto} loadPromptStructureDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerLoadStructureComplete(projectId: string, loadPromptStructureDto: LoadPromptStructureDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerLoadStructureComplete(projectId, loadPromptStructureDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerLoadStructureComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a prompt. This is a destructive operation that requires admin privileges.
         * @summary Delete prompt
         * @param {string} projectId 
         * @param {string} id Unique prompt identifier to delete (slug or UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerRemove(projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerRemove(projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing prompt\'s information. Accessible by global admins or tenant admins.
         * @summary Update prompt
         * @param {string} projectId 
         * @param {string} id Unique prompt identifier to update (slug or UUID)
         * @param {UpdatePromptDto} updatePromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerUpdate(projectId: string, id: string, updatePromptDto: UpdatePromptDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerUpdate(projectId, id, updatePromptDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptsApi - factory interface
 * @export
 */
export const PromptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptsApiFp(configuration)
    return {
        /**
         * Creates a new prompt for the current tenant. Accessible by global admins or tenant admins.
         * @summary Create new prompt
         * @param {string} projectId 
         * @param {CreatePromptDto} createPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerCreate(projectId: string, createPromptDto: CreatePromptDto, options?: RawAxiosRequestConfig): AxiosPromise<PromptDto> {
            return localVarFp.promptControllerCreate(projectId, createPromptDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a complete backup of a prompt without deleting it.
         * @summary Create prompt backup
         * @param {string} projectId ID of the project the prompt belongs to
         * @param {string} id Unique prompt identifier to backup
         * @param {CreatePromptBackupRequestDto} createPromptBackupRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerCreateBackup(projectId: string, id: string, createPromptBackupRequestDto: CreatePromptBackupRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptControllerCreateBackup(projectId, id, createPromptBackupRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all prompts for the current tenant. Results are cached for 1 hour.
         * @summary Get all prompts
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PromptDto>> {
            return localVarFp.promptControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific prompt by its unique ID. Results are cached for 1 hour.
         * @summary Get prompt by ID
         * @param {string} projectId 
         * @param {string} id Unique prompt identifier (slug)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerFindOne(projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<PromptDto> {
            return localVarFp.promptControllerFindOne(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Analiza un prompt de usuario usando un LLM y sugiere una estructura basada en las entidades del proyecto.
         * @summary Genera estructura de prompt
         * @param {string} projectId ID del proyecto
         * @param {GeneratePromptStructureDto} generatePromptStructureDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerGenerateStructure(projectId: string, generatePromptStructureDto: GeneratePromptStructureDto, options?: RawAxiosRequestConfig): AxiosPromise<PromptControllerGenerateStructure200Response> {
            return localVarFp.promptControllerGenerateStructure(projectId, generatePromptStructureDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Uses AI to analyze a basic prompt and suggest a complete structure with versions, translations, and assets.
         * @summary Generate prompt structure using AI
         * @param {string} projectId ID of the project for context
         * @param {any} id Base prompt text or identifier
         * @param {PromptControllerGenerateStructureAIRequest} promptControllerGenerateStructureAIRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerGenerateStructureAI(projectId: string, id: any, promptControllerGenerateStructureAIRequest: PromptControllerGenerateStructureAIRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptControllerGenerateStructureAI(projectId, id, promptControllerGenerateStructureAIRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all available prompt backups for the project.
         * @summary List prompt backups
         * @param {string} projectId ID of the project to list backups for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerListBackups(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptControllerListBackups(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Load prompt structure
         * @param {string} id ID of the prompt
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerLoadStructure(id: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptControllerLoadStructure(id, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a complete prompt with all its components (versions, translations, assets) from a structured input.
         * @summary Load complete prompt structure
         * @param {string} projectId ID of the project where the structure will be loaded
         * @param {LoadPromptStructureDto} loadPromptStructureDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerLoadStructureComplete(projectId: string, loadPromptStructureDto: LoadPromptStructureDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptControllerLoadStructureComplete(projectId, loadPromptStructureDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a prompt. This is a destructive operation that requires admin privileges.
         * @summary Delete prompt
         * @param {string} projectId 
         * @param {string} id Unique prompt identifier to delete (slug or UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerRemove(projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptControllerRemove(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing prompt\'s information. Accessible by global admins or tenant admins.
         * @summary Update prompt
         * @param {string} projectId 
         * @param {string} id Unique prompt identifier to update (slug or UUID)
         * @param {UpdatePromptDto} updatePromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerUpdate(projectId: string, id: string, updatePromptDto: UpdatePromptDto, options?: RawAxiosRequestConfig): AxiosPromise<PromptDto> {
            return localVarFp.promptControllerUpdate(projectId, id, updatePromptDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptsApi - object-oriented interface
 * @export
 * @class PromptsApi
 * @extends {BaseAPI}
 */
export class PromptsApi extends BaseAPI {
    /**
     * Creates a new prompt for the current tenant. Accessible by global admins or tenant admins.
     * @summary Create new prompt
     * @param {string} projectId 
     * @param {CreatePromptDto} createPromptDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerCreate(projectId: string, createPromptDto: CreatePromptDto, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerCreate(projectId, createPromptDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a complete backup of a prompt without deleting it.
     * @summary Create prompt backup
     * @param {string} projectId ID of the project the prompt belongs to
     * @param {string} id Unique prompt identifier to backup
     * @param {CreatePromptBackupRequestDto} createPromptBackupRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerCreateBackup(projectId: string, id: string, createPromptBackupRequestDto: CreatePromptBackupRequestDto, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerCreateBackup(projectId, id, createPromptBackupRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all prompts for the current tenant. Results are cached for 1 hour.
     * @summary Get all prompts
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific prompt by its unique ID. Results are cached for 1 hour.
     * @summary Get prompt by ID
     * @param {string} projectId 
     * @param {string} id Unique prompt identifier (slug)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerFindOne(projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerFindOne(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analiza un prompt de usuario usando un LLM y sugiere una estructura basada en las entidades del proyecto.
     * @summary Genera estructura de prompt
     * @param {string} projectId ID del proyecto
     * @param {GeneratePromptStructureDto} generatePromptStructureDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerGenerateStructure(projectId: string, generatePromptStructureDto: GeneratePromptStructureDto, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerGenerateStructure(projectId, generatePromptStructureDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uses AI to analyze a basic prompt and suggest a complete structure with versions, translations, and assets.
     * @summary Generate prompt structure using AI
     * @param {string} projectId ID of the project for context
     * @param {any} id Base prompt text or identifier
     * @param {PromptControllerGenerateStructureAIRequest} promptControllerGenerateStructureAIRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerGenerateStructureAI(projectId: string, id: any, promptControllerGenerateStructureAIRequest: PromptControllerGenerateStructureAIRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerGenerateStructureAI(projectId, id, promptControllerGenerateStructureAIRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all available prompt backups for the project.
     * @summary List prompt backups
     * @param {string} projectId ID of the project to list backups for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerListBackups(projectId: string, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerListBackups(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Load prompt structure
     * @param {string} id ID of the prompt
     * @param {string} projectId ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerLoadStructure(id: string, projectId: string, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerLoadStructure(id, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a complete prompt with all its components (versions, translations, assets) from a structured input.
     * @summary Load complete prompt structure
     * @param {string} projectId ID of the project where the structure will be loaded
     * @param {LoadPromptStructureDto} loadPromptStructureDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerLoadStructureComplete(projectId: string, loadPromptStructureDto: LoadPromptStructureDto, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerLoadStructureComplete(projectId, loadPromptStructureDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a prompt. This is a destructive operation that requires admin privileges.
     * @summary Delete prompt
     * @param {string} projectId 
     * @param {string} id Unique prompt identifier to delete (slug or UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerRemove(projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerRemove(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing prompt\'s information. Accessible by global admins or tenant admins.
     * @summary Update prompt
     * @param {string} projectId 
     * @param {string} id Unique prompt identifier to update (slug or UUID)
     * @param {UpdatePromptDto} updatePromptDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerUpdate(projectId: string, id: string, updatePromptDto: UpdatePromptDto, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerUpdate(projectId, id, updatePromptDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RAGDocumentMetadataApi - axios parameter creator
 * @export
 */
export const RAGDocumentMetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crear metadatos para un documento RAG dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerCreate: async (projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerCreate', 'projectId', projectId)
            // verify required parameter 'createRagDocumentMetadataDto' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerCreate', 'createRagDocumentMetadataDto', createRagDocumentMetadataDto)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRagDocumentMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener todos los metadatos de documentos RAG de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID de los metadatos (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerFindOne: async (metadataId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerFindOne', 'metadataId', metadataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata/{metadataId}`
                .replace(`{${"metadataId"}}`, encodeURIComponent(String(metadataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Eliminar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerRemove: async (metadataId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerRemove', 'metadataId', metadataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata/{metadataId}`
                .replace(`{${"metadataId"}}`, encodeURIComponent(String(metadataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualizar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a actualizar
         * @param {string} projectId ID del proyecto
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerUpdate: async (metadataId: string, projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerUpdate', 'metadataId', metadataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerUpdate', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerUpdate', 'body', body)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata/{metadataId}`
                .replace(`{${"metadataId"}}`, encodeURIComponent(String(metadataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RAGDocumentMetadataApi - functional programming interface
 * @export
 */
export const RAGDocumentMetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RAGDocumentMetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crear metadatos para un documento RAG dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerCreate(projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RagDocumentMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerCreate(projectId, createRagDocumentMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtener todos los metadatos de documentos RAG de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RagDocumentMetadataResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtener metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID de los metadatos (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerFindOne(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RagDocumentMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerFindOne(metadataId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Eliminar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerRemove(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerRemove(metadataId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualizar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a actualizar
         * @param {string} projectId ID del proyecto
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerUpdate(metadataId: string, projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RagDocumentMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerUpdate(metadataId, projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RAGDocumentMetadataApi - factory interface
 * @export
 */
export const RAGDocumentMetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RAGDocumentMetadataApiFp(configuration)
    return {
        /**
         * 
         * @summary Crear metadatos para un documento RAG dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerCreate(projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<RagDocumentMetadataResponse> {
            return localVarFp.ragDocumentMetadataControllerCreate(projectId, createRagDocumentMetadataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtener todos los metadatos de documentos RAG de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RagDocumentMetadataResponse>> {
            return localVarFp.ragDocumentMetadataControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtener metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID de los metadatos (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerFindOne(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<RagDocumentMetadataResponse> {
            return localVarFp.ragDocumentMetadataControllerFindOne(metadataId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Eliminar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerRemove(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ragDocumentMetadataControllerRemove(metadataId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualizar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a actualizar
         * @param {string} projectId ID del proyecto
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerUpdate(metadataId: string, projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<RagDocumentMetadataResponse> {
            return localVarFp.ragDocumentMetadataControllerUpdate(metadataId, projectId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RAGDocumentMetadataApi - object-oriented interface
 * @export
 * @class RAGDocumentMetadataApi
 * @extends {BaseAPI}
 */
export class RAGDocumentMetadataApi extends BaseAPI {
    /**
     * 
     * @summary Crear metadatos para un documento RAG dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerCreate(projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerCreate(projectId, createRagDocumentMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtener todos los metadatos de documentos RAG de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtener metadatos por ID dentro de un proyecto
     * @param {string} metadataId ID de los metadatos (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerFindOne(metadataId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerFindOne(metadataId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Eliminar metadatos por ID dentro de un proyecto
     * @param {string} metadataId ID a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerRemove(metadataId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerRemove(metadataId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualizar metadatos por ID dentro de un proyecto
     * @param {string} metadataId ID a actualizar
     * @param {string} projectId ID del proyecto
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerUpdate(metadataId: string, projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerUpdate(metadataId, projectId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RawExecutionApi - axios parameter creator
 * @export
 */
export const RawExecutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Executes raw text using a specified System Prompt and AI Model ID.
         * @param {ExecuteRawDto} executeRawDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawExecutionControllerExecuteRawText: async (executeRawDto: ExecuteRawDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'executeRawDto' is not null or undefined
            assertParamExists('rawExecutionControllerExecuteRawText', 'executeRawDto', executeRawDto)
            const localVarPath = `/api/execute-raw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeRawDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RawExecutionApi - functional programming interface
 * @export
 */
export const RawExecutionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RawExecutionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Executes raw text using a specified System Prompt and AI Model ID.
         * @param {ExecuteRawDto} executeRawDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rawExecutionControllerExecuteRawText(executeRawDto: ExecuteRawDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rawExecutionControllerExecuteRawText(executeRawDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RawExecutionApi.rawExecutionControllerExecuteRawText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RawExecutionApi - factory interface
 * @export
 */
export const RawExecutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RawExecutionApiFp(configuration)
    return {
        /**
         * 
         * @summary Executes raw text using a specified System Prompt and AI Model ID.
         * @param {ExecuteRawDto} executeRawDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawExecutionControllerExecuteRawText(executeRawDto: ExecuteRawDto, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.rawExecutionControllerExecuteRawText(executeRawDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RawExecutionApi - object-oriented interface
 * @export
 * @class RawExecutionApi
 * @extends {BaseAPI}
 */
export class RawExecutionApi extends BaseAPI {
    /**
     * 
     * @summary Executes raw text using a specified System Prompt and AI Model ID.
     * @param {ExecuteRawDto} executeRawDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExecutionApi
     */
    public rawExecutionControllerExecuteRawText(executeRawDto: ExecuteRawDto, options?: RawAxiosRequestConfig) {
        return RawExecutionApiFp(this.configuration).rawExecutionControllerExecuteRawText(executeRawDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RegionsApi - axios parameter creator
 * @export
 */
export const RegionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new region for the current tenant. Accessible by global admins or tenant admins.
         * @summary Create new region
         * @param {string} projectId ID of the project
         * @param {CreateRegionDto} createRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerCreate: async (projectId: string, createRegionDto: CreateRegionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerCreate', 'projectId', projectId)
            // verify required parameter 'createRegionDto' is not null or undefined
            assertParamExists('regionControllerCreate', 'createRegionDto', createRegionDto)
            const localVarPath = `/api/projects/{projectId}/regions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRegionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all regions for the current tenant. Results are cached for 1 hour.
         * @summary Get all regions
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/regions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific region by its language code (e.g., en-US, es-ES). Results are cached for 1 hour.
         * @summary Get region by language code
         * @param {string} langCode Language code of the region (e.g., en-US, es-ES)
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerFindOne: async (langCode: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'langCode' is not null or undefined
            assertParamExists('regionControllerFindOne', 'langCode', langCode)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/regions/{langCode}`
                .replace(`{${"langCode"}}`, encodeURIComponent(String(langCode)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a region by its language code. Accessible by global admins or tenant admins.
         * @summary Delete region
         * @param {string} langCode Language code of the region to delete (e.g., en-US, es-ES)
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerRemove: async (langCode: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'langCode' is not null or undefined
            assertParamExists('regionControllerRemove', 'langCode', langCode)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/regions/{langCode}`
                .replace(`{${"langCode"}}`, encodeURIComponent(String(langCode)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing region\'s information. Accessible by global admins or tenant admins.
         * @summary Update region
         * @param {string} langCode Language code of the region to update (e.g., en-US, es-ES)
         * @param {string} projectId ID of the project
         * @param {UpdateRegionDto} updateRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerUpdate: async (langCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'langCode' is not null or undefined
            assertParamExists('regionControllerUpdate', 'langCode', langCode)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateRegionDto' is not null or undefined
            assertParamExists('regionControllerUpdate', 'updateRegionDto', updateRegionDto)
            const localVarPath = `/api/projects/{projectId}/regions/{langCode}`
                .replace(`{${"langCode"}}`, encodeURIComponent(String(langCode)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRegionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegionsApi - functional programming interface
 * @export
 */
export const RegionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new region for the current tenant. Accessible by global admins or tenant admins.
         * @summary Create new region
         * @param {string} projectId ID of the project
         * @param {CreateRegionDto} createRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerCreate(projectId: string, createRegionDto: CreateRegionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerCreate(projectId, createRegionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all regions for the current tenant. Results are cached for 1 hour.
         * @summary Get all regions
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific region by its language code (e.g., en-US, es-ES). Results are cached for 1 hour.
         * @summary Get region by language code
         * @param {string} langCode Language code of the region (e.g., en-US, es-ES)
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerFindOne(langCode: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerFindOne(langCode, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a region by its language code. Accessible by global admins or tenant admins.
         * @summary Delete region
         * @param {string} langCode Language code of the region to delete (e.g., en-US, es-ES)
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerRemove(langCode: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerRemove(langCode, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing region\'s information. Accessible by global admins or tenant admins.
         * @summary Update region
         * @param {string} langCode Language code of the region to update (e.g., en-US, es-ES)
         * @param {string} projectId ID of the project
         * @param {UpdateRegionDto} updateRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerUpdate(langCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerUpdate(langCode, projectId, updateRegionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RegionsApi - factory interface
 * @export
 */
export const RegionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegionsApiFp(configuration)
    return {
        /**
         * Creates a new region for the current tenant. Accessible by global admins or tenant admins.
         * @summary Create new region
         * @param {string} projectId ID of the project
         * @param {CreateRegionDto} createRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerCreate(projectId: string, createRegionDto: CreateRegionDto, options?: RawAxiosRequestConfig): AxiosPromise<RegionDto> {
            return localVarFp.regionControllerCreate(projectId, createRegionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all regions for the current tenant. Results are cached for 1 hour.
         * @summary Get all regions
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RegionDto>> {
            return localVarFp.regionControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific region by its language code (e.g., en-US, es-ES). Results are cached for 1 hour.
         * @summary Get region by language code
         * @param {string} langCode Language code of the region (e.g., en-US, es-ES)
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerFindOne(langCode: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<RegionDto> {
            return localVarFp.regionControllerFindOne(langCode, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a region by its language code. Accessible by global admins or tenant admins.
         * @summary Delete region
         * @param {string} langCode Language code of the region to delete (e.g., en-US, es-ES)
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerRemove(langCode: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.regionControllerRemove(langCode, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing region\'s information. Accessible by global admins or tenant admins.
         * @summary Update region
         * @param {string} langCode Language code of the region to update (e.g., en-US, es-ES)
         * @param {string} projectId ID of the project
         * @param {UpdateRegionDto} updateRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerUpdate(langCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options?: RawAxiosRequestConfig): AxiosPromise<RegionDto> {
            return localVarFp.regionControllerUpdate(langCode, projectId, updateRegionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegionsApi - object-oriented interface
 * @export
 * @class RegionsApi
 * @extends {BaseAPI}
 */
export class RegionsApi extends BaseAPI {
    /**
     * Creates a new region for the current tenant. Accessible by global admins or tenant admins.
     * @summary Create new region
     * @param {string} projectId ID of the project
     * @param {CreateRegionDto} createRegionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerCreate(projectId: string, createRegionDto: CreateRegionDto, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerCreate(projectId, createRegionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all regions for the current tenant. Results are cached for 1 hour.
     * @summary Get all regions
     * @param {string} projectId ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific region by its language code (e.g., en-US, es-ES). Results are cached for 1 hour.
     * @summary Get region by language code
     * @param {string} langCode Language code of the region (e.g., en-US, es-ES)
     * @param {string} projectId ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerFindOne(langCode: string, projectId: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerFindOne(langCode, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a region by its language code. Accessible by global admins or tenant admins.
     * @summary Delete region
     * @param {string} langCode Language code of the region to delete (e.g., en-US, es-ES)
     * @param {string} projectId ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerRemove(langCode: string, projectId: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerRemove(langCode, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing region\'s information. Accessible by global admins or tenant admins.
     * @summary Update region
     * @param {string} langCode Language code of the region to update (e.g., en-US, es-ES)
     * @param {string} projectId ID of the project
     * @param {UpdateRegionDto} updateRegionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerUpdate(langCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerUpdate(langCode, projectId, updateRegionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServePromptApi - axios parameter creator
 * @export
 */
export const ServePromptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assembles and prepares a specific prompt version (specific language) for execution with provided variables
         * @param {string} projectId Project ID
         * @param {string} promptName The unique name of the prompt within the project
         * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;) or \&quot;latest\&quot; to use the most recent version
         * @param {string} languageCode Language code for translation (e.g., \&quot;es\&quot;)
         * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servePromptControllerExecutePromptWithLanguage: async (projectId: string, promptName: string, versionTag: string, languageCode: string, executePromptBodyDto: ExecutePromptBodyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('servePromptControllerExecutePromptWithLanguage', 'projectId', projectId)
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('servePromptControllerExecutePromptWithLanguage', 'promptName', promptName)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('servePromptControllerExecutePromptWithLanguage', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('servePromptControllerExecutePromptWithLanguage', 'languageCode', languageCode)
            // verify required parameter 'executePromptBodyDto' is not null or undefined
            assertParamExists('servePromptControllerExecutePromptWithLanguage', 'executePromptBodyDto', executePromptBodyDto)
            const localVarPath = `/api/serve-prompt/execute/{projectId}/{promptName}/{versionTag}/lang/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executePromptBodyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assembles and prepares a specific prompt version (base language) for execution with provided variables
         * @param {string} projectId Project ID
         * @param {string} promptName The unique name of the prompt within the project
         * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;) or \&quot;latest\&quot; to use the most recent version
         * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servePromptControllerExecutePromptWithoutLanguage: async (projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('servePromptControllerExecutePromptWithoutLanguage', 'projectId', projectId)
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('servePromptControllerExecutePromptWithoutLanguage', 'promptName', promptName)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('servePromptControllerExecutePromptWithoutLanguage', 'versionTag', versionTag)
            // verify required parameter 'executePromptBodyDto' is not null or undefined
            assertParamExists('servePromptControllerExecutePromptWithoutLanguage', 'executePromptBodyDto', executePromptBodyDto)
            const localVarPath = `/api/serve-prompt/execute/{projectId}/{promptName}/{versionTag}/base`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executePromptBodyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServePromptApi - functional programming interface
 * @export
 */
export const ServePromptApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServePromptApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assembles and prepares a specific prompt version (specific language) for execution with provided variables
         * @param {string} projectId Project ID
         * @param {string} promptName The unique name of the prompt within the project
         * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;) or \&quot;latest\&quot; to use the most recent version
         * @param {string} languageCode Language code for translation (e.g., \&quot;es\&quot;)
         * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servePromptControllerExecutePromptWithLanguage(projectId: string, promptName: string, versionTag: string, languageCode: string, executePromptBodyDto: ExecutePromptBodyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servePromptControllerExecutePromptWithLanguage(projectId, promptName, versionTag, languageCode, executePromptBodyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServePromptApi.servePromptControllerExecutePromptWithLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Assembles and prepares a specific prompt version (base language) for execution with provided variables
         * @param {string} projectId Project ID
         * @param {string} promptName The unique name of the prompt within the project
         * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;) or \&quot;latest\&quot; to use the most recent version
         * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servePromptControllerExecutePromptWithoutLanguage(projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servePromptControllerExecutePromptWithoutLanguage(projectId, promptName, versionTag, executePromptBodyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServePromptApi.servePromptControllerExecutePromptWithoutLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServePromptApi - factory interface
 * @export
 */
export const ServePromptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServePromptApiFp(configuration)
    return {
        /**
         * 
         * @summary Assembles and prepares a specific prompt version (specific language) for execution with provided variables
         * @param {string} projectId Project ID
         * @param {string} promptName The unique name of the prompt within the project
         * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;) or \&quot;latest\&quot; to use the most recent version
         * @param {string} languageCode Language code for translation (e.g., \&quot;es\&quot;)
         * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servePromptControllerExecutePromptWithLanguage(projectId: string, promptName: string, versionTag: string, languageCode: string, executePromptBodyDto: ExecutePromptBodyDto, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.servePromptControllerExecutePromptWithLanguage(projectId, promptName, versionTag, languageCode, executePromptBodyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assembles and prepares a specific prompt version (base language) for execution with provided variables
         * @param {string} projectId Project ID
         * @param {string} promptName The unique name of the prompt within the project
         * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;) or \&quot;latest\&quot; to use the most recent version
         * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servePromptControllerExecutePromptWithoutLanguage(projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.servePromptControllerExecutePromptWithoutLanguage(projectId, promptName, versionTag, executePromptBodyDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServePromptApi - object-oriented interface
 * @export
 * @class ServePromptApi
 * @extends {BaseAPI}
 */
export class ServePromptApi extends BaseAPI {
    /**
     * 
     * @summary Assembles and prepares a specific prompt version (specific language) for execution with provided variables
     * @param {string} projectId Project ID
     * @param {string} promptName The unique name of the prompt within the project
     * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;) or \&quot;latest\&quot; to use the most recent version
     * @param {string} languageCode Language code for translation (e.g., \&quot;es\&quot;)
     * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServePromptApi
     */
    public servePromptControllerExecutePromptWithLanguage(projectId: string, promptName: string, versionTag: string, languageCode: string, executePromptBodyDto: ExecutePromptBodyDto, options?: RawAxiosRequestConfig) {
        return ServePromptApiFp(this.configuration).servePromptControllerExecutePromptWithLanguage(projectId, promptName, versionTag, languageCode, executePromptBodyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assembles and prepares a specific prompt version (base language) for execution with provided variables
     * @param {string} projectId Project ID
     * @param {string} promptName The unique name of the prompt within the project
     * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;) or \&quot;latest\&quot; to use the most recent version
     * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServePromptApi
     */
    public servePromptControllerExecutePromptWithoutLanguage(projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, options?: RawAxiosRequestConfig) {
        return ServePromptApiFp(this.configuration).servePromptControllerExecutePromptWithoutLanguage(projectId, promptName, versionTag, executePromptBodyDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemPromptsApi - axios parameter creator
 * @export
 */
export const SystemPromptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new system prompt (Admin Only)
         * @param {CreateSystemPromptDto} createSystemPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerCreate: async (createSystemPromptDto: CreateSystemPromptDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSystemPromptDto' is not null or undefined
            assertParamExists('systemPromptControllerCreate', 'createSystemPromptDto', createSystemPromptDto)
            const localVarPath = `/api/system-prompts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSystemPromptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all system prompts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/system-prompts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific system prompt by name
         * @param {string} name Unique name of the system prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerFindOne: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('systemPromptControllerFindOne', 'name', name)
            const localVarPath = `/api/system-prompts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a system prompt (Admin Only)
         * @param {string} name Unique name of the system prompt to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerRemove: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('systemPromptControllerRemove', 'name', name)
            const localVarPath = `/api/system-prompts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing system prompt (Admin Only)
         * @param {string} name Unique name of the system prompt to update
         * @param {UpdateSystemPromptDto} updateSystemPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerUpdate: async (name: string, updateSystemPromptDto: UpdateSystemPromptDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('systemPromptControllerUpdate', 'name', name)
            // verify required parameter 'updateSystemPromptDto' is not null or undefined
            assertParamExists('systemPromptControllerUpdate', 'updateSystemPromptDto', updateSystemPromptDto)
            const localVarPath = `/api/system-prompts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSystemPromptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemPromptsApi - functional programming interface
 * @export
 */
export const SystemPromptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemPromptsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new system prompt (Admin Only)
         * @param {CreateSystemPromptDto} createSystemPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPromptControllerCreate(createSystemPromptDto: CreateSystemPromptDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPromptControllerCreate(createSystemPromptDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemPromptsApi.systemPromptControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all system prompts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPromptControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPromptControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemPromptsApi.systemPromptControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific system prompt by name
         * @param {string} name Unique name of the system prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPromptControllerFindOne(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPromptControllerFindOne(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemPromptsApi.systemPromptControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a system prompt (Admin Only)
         * @param {string} name Unique name of the system prompt to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPromptControllerRemove(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPromptControllerRemove(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemPromptsApi.systemPromptControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing system prompt (Admin Only)
         * @param {string} name Unique name of the system prompt to update
         * @param {UpdateSystemPromptDto} updateSystemPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPromptControllerUpdate(name: string, updateSystemPromptDto: UpdateSystemPromptDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPromptControllerUpdate(name, updateSystemPromptDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemPromptsApi.systemPromptControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemPromptsApi - factory interface
 * @export
 */
export const SystemPromptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemPromptsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new system prompt (Admin Only)
         * @param {CreateSystemPromptDto} createSystemPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerCreate(createSystemPromptDto: CreateSystemPromptDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.systemPromptControllerCreate(createSystemPromptDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all system prompts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.systemPromptControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific system prompt by name
         * @param {string} name Unique name of the system prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerFindOne(name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.systemPromptControllerFindOne(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a system prompt (Admin Only)
         * @param {string} name Unique name of the system prompt to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerRemove(name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.systemPromptControllerRemove(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing system prompt (Admin Only)
         * @param {string} name Unique name of the system prompt to update
         * @param {UpdateSystemPromptDto} updateSystemPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerUpdate(name: string, updateSystemPromptDto: UpdateSystemPromptDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.systemPromptControllerUpdate(name, updateSystemPromptDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemPromptsApi - object-oriented interface
 * @export
 * @class SystemPromptsApi
 * @extends {BaseAPI}
 */
export class SystemPromptsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new system prompt (Admin Only)
     * @param {CreateSystemPromptDto} createSystemPromptDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemPromptsApi
     */
    public systemPromptControllerCreate(createSystemPromptDto: CreateSystemPromptDto, options?: RawAxiosRequestConfig) {
        return SystemPromptsApiFp(this.configuration).systemPromptControllerCreate(createSystemPromptDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all system prompts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemPromptsApi
     */
    public systemPromptControllerFindAll(options?: RawAxiosRequestConfig) {
        return SystemPromptsApiFp(this.configuration).systemPromptControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific system prompt by name
     * @param {string} name Unique name of the system prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemPromptsApi
     */
    public systemPromptControllerFindOne(name: string, options?: RawAxiosRequestConfig) {
        return SystemPromptsApiFp(this.configuration).systemPromptControllerFindOne(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a system prompt (Admin Only)
     * @param {string} name Unique name of the system prompt to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemPromptsApi
     */
    public systemPromptControllerRemove(name: string, options?: RawAxiosRequestConfig) {
        return SystemPromptsApiFp(this.configuration).systemPromptControllerRemove(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing system prompt (Admin Only)
     * @param {string} name Unique name of the system prompt to update
     * @param {UpdateSystemPromptDto} updateSystemPromptDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemPromptsApi
     */
    public systemPromptControllerUpdate(name: string, updateSystemPromptDto: UpdateSystemPromptDto, options?: RawAxiosRequestConfig) {
        return SystemPromptsApiFp(this.configuration).systemPromptControllerUpdate(name, updateSystemPromptDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crea una nueva etiqueta para un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCreate: async (projectId: string, createTagDto: CreateTagDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerCreate', 'projectId', projectId)
            // verify required parameter 'createTagDto' is not null or undefined
            assertParamExists('tagControllerCreate', 'createTagDto', createTagDto)
            const localVarPath = `/api/projects/{projectId}/tags`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene todas las etiquetas de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tags`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
         * @param {string} name Nombre único de la etiqueta en el proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindByName: async (name: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagControllerFindByName', 'name', name)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerFindByName', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tags/by-name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su ID dentro de un proyecto
         * @param {string} tagId ID único de la etiqueta (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindOne: async (tagId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagControllerFindOne', 'tagId', tagId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Elimina una etiqueta de un proyecto
         * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerRemove: async (tagId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagControllerRemove', 'tagId', tagId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualiza una etiqueta existente en un proyecto
         * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdate: async (tagId: string, projectId: string, updateTagDto: UpdateTagDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagControllerUpdate', 'tagId', tagId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateTagDto' is not null or undefined
            assertParamExists('tagControllerUpdate', 'updateTagDto', updateTagDto)
            const localVarPath = `/api/projects/{projectId}/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crea una nueva etiqueta para un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerCreate(projectId: string, createTagDto: CreateTagDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerCreate(projectId, createTagDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene todas las etiquetas de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
         * @param {string} name Nombre único de la etiqueta en el proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerFindByName(name, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerFindByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su ID dentro de un proyecto
         * @param {string} tagId ID único de la etiqueta (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerFindOne(tagId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerFindOne(tagId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Elimina una etiqueta de un proyecto
         * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerRemove(tagId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerRemove(tagId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualiza una etiqueta existente en un proyecto
         * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerUpdate(tagId: string, projectId: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerUpdate(tagId, projectId, updateTagDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Crea una nueva etiqueta para un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCreate(projectId: string, createTagDto: CreateTagDto, options?: RawAxiosRequestConfig): AxiosPromise<TagDto> {
            return localVarFp.tagControllerCreate(projectId, createTagDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene todas las etiquetas de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TagDto>> {
            return localVarFp.tagControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
         * @param {string} name Nombre único de la etiqueta en el proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<TagDto> {
            return localVarFp.tagControllerFindByName(name, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su ID dentro de un proyecto
         * @param {string} tagId ID único de la etiqueta (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindOne(tagId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<TagDto> {
            return localVarFp.tagControllerFindOne(tagId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Elimina una etiqueta de un proyecto
         * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerRemove(tagId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<TagDto> {
            return localVarFp.tagControllerRemove(tagId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualiza una etiqueta existente en un proyecto
         * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdate(tagId: string, projectId: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig): AxiosPromise<TagDto> {
            return localVarFp.tagControllerUpdate(tagId, projectId, updateTagDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @summary Crea una nueva etiqueta para un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateTagDto} createTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerCreate(projectId: string, createTagDto: CreateTagDto, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerCreate(projectId, createTagDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene todas las etiquetas de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
     * @param {string} name Nombre único de la etiqueta en el proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerFindByName(name, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene una etiqueta por su ID dentro de un proyecto
     * @param {string} tagId ID único de la etiqueta (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerFindOne(tagId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerFindOne(tagId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Elimina una etiqueta de un proyecto
     * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerRemove(tagId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerRemove(tagId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualiza una etiqueta existente en un proyecto
     * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
     * @param {string} projectId ID del proyecto
     * @param {UpdateTagDto} updateTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerUpdate(tagId: string, projectId: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerUpdate(tagId, projectId, updateTagDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TenantsApi - axios parameter creator
 * @export
 */
export const TenantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new tenant in the system. This operation requires global admin privileges.
         * @summary Create new tenant
         * @param {CreateTenantDto} createTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantControllerCreate: async (createTenantDto: CreateTenantDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTenantDto' is not null or undefined
            assertParamExists('tenantControllerCreate', 'createTenantDto', createTenantDto)
            const localVarPath = `/api/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTenantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all tenants in the system. This operation requires global admin privileges.
         * @summary Get all tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific tenant by their unique ID. Accessible by global admins or tenant admins of the specified tenant.
         * @summary Get tenant by ID
         * @param {string} tenantId Unique tenant identifier (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantControllerFindOne: async (tenantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantControllerFindOne', 'tenantId', tenantId)
            const localVarPath = `/api/tenants/{tenantId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a tenant from the system. This is a destructive operation that requires global admin privileges.
         * @summary Delete tenant
         * @param {string} tenantId Unique tenant identifier to delete (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantControllerRemove: async (tenantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantControllerRemove', 'tenantId', tenantId)
            const localVarPath = `/api/tenants/{tenantId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing tenant\'s information. Accessible by global admins or tenant admins of the specified tenant.
         * @summary Update tenant
         * @param {string} tenantId Unique tenant identifier to update (UUID)
         * @param {UpdateTenantDto} updateTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantControllerUpdate: async (tenantId: string, updateTenantDto: UpdateTenantDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('tenantControllerUpdate', 'tenantId', tenantId)
            // verify required parameter 'updateTenantDto' is not null or undefined
            assertParamExists('tenantControllerUpdate', 'updateTenantDto', updateTenantDto)
            const localVarPath = `/api/tenants/{tenantId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTenantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantsApi - functional programming interface
 * @export
 */
export const TenantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new tenant in the system. This operation requires global admin privileges.
         * @summary Create new tenant
         * @param {CreateTenantDto} createTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantControllerCreate(createTenantDto: CreateTenantDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantControllerCreate(createTenantDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.tenantControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all tenants in the system. This operation requires global admin privileges.
         * @summary Get all tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TenantDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.tenantControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific tenant by their unique ID. Accessible by global admins or tenant admins of the specified tenant.
         * @summary Get tenant by ID
         * @param {string} tenantId Unique tenant identifier (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantControllerFindOne(tenantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantControllerFindOne(tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.tenantControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a tenant from the system. This is a destructive operation that requires global admin privileges.
         * @summary Delete tenant
         * @param {string} tenantId Unique tenant identifier to delete (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantControllerRemove(tenantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantControllerRemove(tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.tenantControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing tenant\'s information. Accessible by global admins or tenant admins of the specified tenant.
         * @summary Update tenant
         * @param {string} tenantId Unique tenant identifier to update (UUID)
         * @param {UpdateTenantDto} updateTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantControllerUpdate(tenantId: string, updateTenantDto: UpdateTenantDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantControllerUpdate(tenantId, updateTenantDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.tenantControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TenantsApi - factory interface
 * @export
 */
export const TenantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantsApiFp(configuration)
    return {
        /**
         * Creates a new tenant in the system. This operation requires global admin privileges.
         * @summary Create new tenant
         * @param {CreateTenantDto} createTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantControllerCreate(createTenantDto: CreateTenantDto, options?: RawAxiosRequestConfig): AxiosPromise<TenantDto> {
            return localVarFp.tenantControllerCreate(createTenantDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all tenants in the system. This operation requires global admin privileges.
         * @summary Get all tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<TenantDto>> {
            return localVarFp.tenantControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific tenant by their unique ID. Accessible by global admins or tenant admins of the specified tenant.
         * @summary Get tenant by ID
         * @param {string} tenantId Unique tenant identifier (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantControllerFindOne(tenantId: string, options?: RawAxiosRequestConfig): AxiosPromise<TenantDto> {
            return localVarFp.tenantControllerFindOne(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a tenant from the system. This is a destructive operation that requires global admin privileges.
         * @summary Delete tenant
         * @param {string} tenantId Unique tenant identifier to delete (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantControllerRemove(tenantId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tenantControllerRemove(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing tenant\'s information. Accessible by global admins or tenant admins of the specified tenant.
         * @summary Update tenant
         * @param {string} tenantId Unique tenant identifier to update (UUID)
         * @param {UpdateTenantDto} updateTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantControllerUpdate(tenantId: string, updateTenantDto: UpdateTenantDto, options?: RawAxiosRequestConfig): AxiosPromise<TenantDto> {
            return localVarFp.tenantControllerUpdate(tenantId, updateTenantDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantsApi - object-oriented interface
 * @export
 * @class TenantsApi
 * @extends {BaseAPI}
 */
export class TenantsApi extends BaseAPI {
    /**
     * Creates a new tenant in the system. This operation requires global admin privileges.
     * @summary Create new tenant
     * @param {CreateTenantDto} createTenantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantControllerCreate(createTenantDto: CreateTenantDto, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantControllerCreate(createTenantDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all tenants in the system. This operation requires global admin privileges.
     * @summary Get all tenants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantControllerFindAll(options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific tenant by their unique ID. Accessible by global admins or tenant admins of the specified tenant.
     * @summary Get tenant by ID
     * @param {string} tenantId Unique tenant identifier (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantControllerFindOne(tenantId: string, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantControllerFindOne(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a tenant from the system. This is a destructive operation that requires global admin privileges.
     * @summary Delete tenant
     * @param {string} tenantId Unique tenant identifier to delete (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantControllerRemove(tenantId: string, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantControllerRemove(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing tenant\'s information. Accessible by global admins or tenant admins of the specified tenant.
     * @summary Update tenant
     * @param {string} tenantId Unique tenant identifier to update (UUID)
     * @param {UpdateTenantDto} updateTenantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantControllerUpdate(tenantId: string, updateTenantDto: UpdateTenantDto, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantControllerUpdate(tenantId, updateTenantDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new user within the authenticated admin\'s tenant. Requires admin privileges.
         * @summary Create new user
         * @param {CreateUserDto} createUserDto User data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate: async (createUserDto: CreateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('userControllerCreate', 'createUserDto', createUserDto)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all users in the system. Requires admin privileges.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific user by their unique ID. Requires admin privileges.
         * @summary Get user by ID
         * @param {string} id Unique user identifier (CUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerFindOne', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a user from the system. Requires admin privileges.
         * @summary Delete user
         * @param {string} id Unique user identifier to delete (CUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerRemove', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing user\'s information. Requires admin privileges.
         * @summary Update user
         * @param {string} id Unique user identifier to update (CUID)
         * @param {object} body User data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userControllerUpdate', 'body', body)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new user within the authenticated admin\'s tenant. Requires admin privileges.
         * @summary Create new user
         * @param {CreateUserDto} createUserDto User data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerCreate(createUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all users in the system. Requires admin privileges.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateUserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific user by their unique ID. Requires admin privileges.
         * @summary Get user by ID
         * @param {string} id Unique user identifier (CUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a user from the system. Requires admin privileges.
         * @summary Delete user
         * @param {string} id Unique user identifier to delete (CUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing user\'s information. Requires admin privileges.
         * @summary Update user
         * @param {string} id Unique user identifier to update (CUID)
         * @param {object} body User data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdate(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Creates a new user within the authenticated admin\'s tenant. Requires admin privileges.
         * @summary Create new user
         * @param {CreateUserDto} createUserDto User data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto> {
            return localVarFp.userControllerCreate(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all users in the system. Requires admin privileges.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateUserDto>> {
            return localVarFp.userControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific user by their unique ID. Requires admin privileges.
         * @summary Get user by ID
         * @param {string} id Unique user identifier (CUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto> {
            return localVarFp.userControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a user from the system. Requires admin privileges.
         * @summary Delete user
         * @param {string} id Unique user identifier to delete (CUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto> {
            return localVarFp.userControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing user\'s information. Requires admin privileges.
         * @summary Update user
         * @param {string} id Unique user identifier to update (CUID)
         * @param {object} body User data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto> {
            return localVarFp.userControllerUpdate(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Creates a new user within the authenticated admin\'s tenant. Requires admin privileges.
     * @summary Create new user
     * @param {CreateUserDto} createUserDto User data to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerCreate(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all users in the system. Requires admin privileges.
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindAll(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific user by their unique ID. Requires admin privileges.
     * @summary Get user by ID
     * @param {string} id Unique user identifier (CUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a user from the system. Requires admin privileges.
     * @summary Delete user
     * @param {string} id Unique user identifier to delete (CUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing user\'s information. Requires admin privileges.
     * @summary Update user
     * @param {string} id Unique user identifier to update (CUID)
     * @param {object} body User data to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUpdate(id: string, body: object, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



