/* tslint:disable */
/* eslint-disable */
/**
 * JAPM API
 * API for the JAPM Prompt Engineering application
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AiModelResponseDto
 */
export interface AiModelResponseDto {
    /**
     * Unique CUID of the AI model
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'id': string;
    /**
     * Unique name for the AI model within the project
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'name': string;
    /**
     * Provider of the AI model
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'provider'?: string | null;
    /**
     * Optional description for the AI model
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'description'?: string | null;
    /**
     * Identifier used for API calls
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'apiIdentifier'?: string | null;
    /**
     * Environment variable name for the API Key
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'apiKeyEnvVar'?: string | null;
    /**
     * Default temperature setting
     * @type {number}
     * @memberof AiModelResponseDto
     */
    'temperature'?: number | null;
    /**
     * Default max tokens setting
     * @type {number}
     * @memberof AiModelResponseDto
     */
    'maxTokens'?: number | null;
    /**
     * Whether the model reliably supports JSON output mode
     * @type {boolean}
     * @memberof AiModelResponseDto
     */
    'supportsJson'?: boolean;
    /**
     * Maximum context window size in tokens
     * @type {number}
     * @memberof AiModelResponseDto
     */
    'contextWindow'?: number | null;
    /**
     * Timestamp of creation
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'createdAt': string;
    /**
     * ID of the project this model belongs to
     * @type {string}
     * @memberof AiModelResponseDto
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface AssetVersionLinkDto
 */
export interface AssetVersionLinkDto {
    /**
     * ID of the PromptAssetVersion to link.
     * @type {string}
     * @memberof AssetVersionLinkDto
     */
    'assetVersionId': string;
    /**
     * Usage context (optional).
     * @type {string}
     * @memberof AssetVersionLinkDto
     */
    'usageContext'?: string;
    /**
     * Position/order (optional).
     * @type {number}
     * @memberof AssetVersionLinkDto
     */
    'position'?: number;
}
/**
 * 
 * @export
 * @interface CreateAiModelDto
 */
export interface CreateAiModelDto {
    /**
     * Unique name for the AI model
     * @type {string}
     * @memberof CreateAiModelDto
     */
    'name': string;
    /**
     * Provider of the AI model
     * @type {string}
     * @memberof CreateAiModelDto
     */
    'provider'?: string;
    /**
     * Optional description for the AI model
     * @type {string}
     * @memberof CreateAiModelDto
     */
    'description'?: string;
    /**
     * Identifier used for API calls
     * @type {string}
     * @memberof CreateAiModelDto
     */
    'apiIdentifier'?: string;
}
/**
 * 
 * @export
 * @interface CreateAssetTranslationDto
 */
export interface CreateAssetTranslationDto {
    /**
     * ID de la versión del asset a la que pertenece esta traducción
     * @type {string}
     * @memberof CreateAssetTranslationDto
     */
    'versionId': string;
    /**
     * Código de idioma para esta traducción (formato xx-XX)
     * @type {string}
     * @memberof CreateAssetTranslationDto
     */
    'languageCode': string;
    /**
     * Valor del asset traducido a este idioma
     * @type {string}
     * @memberof CreateAssetTranslationDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface CreateCulturalDataDto
 */
export interface CreateCulturalDataDto {
    /**
     * Unique ID for this cultural data (slug format)
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'id': string;
    /**
     * Associated region ID (xx-XX language code)
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'regionId': string;
    /**
     * Formality level (optional)
     * @type {number}
     * @memberof CreateCulturalDataDto
     */
    'formalityLevel'?: number;
    /**
     * Communication style (optional)
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'style'?: string;
    /**
     * Cultural considerations (optional)
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'considerations'?: string;
    /**
     * Additional notes (optional)
     * @type {string}
     * @memberof CreateCulturalDataDto
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface CreateEnvironmentDto
 */
export interface CreateEnvironmentDto {
    /**
     * Unique name of the environment
     * @type {string}
     * @memberof CreateEnvironmentDto
     */
    'name': string;
    /**
     * Optional description of the environment
     * @type {string}
     * @memberof CreateEnvironmentDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateOrUpdatePromptTranslationDto
 */
export interface CreateOrUpdatePromptTranslationDto {
    /**
     * Language code for the translation (e.g., es-ES, fr-FR).
     * @type {string}
     * @memberof CreateOrUpdatePromptTranslationDto
     */
    'languageCode': string;
    /**
     * Translated prompt text for this version and language.
     * @type {string}
     * @memberof CreateOrUpdatePromptTranslationDto
     */
    'promptText': string;
}
/**
 * 
 * @export
 * @interface CreateProjectDto
 */
export interface CreateProjectDto {
    /**
     * Name of the project
     * @type {string}
     * @memberof CreateProjectDto
     */
    'name': string;
    /**
     * Optional description for the project
     * @type {string}
     * @memberof CreateProjectDto
     */
    'description'?: string;
    /**
     * Optional ID of the User who owns this project
     * @type {string}
     * @memberof CreateProjectDto
     */
    'ownerUserId'?: string;
}
/**
 * 
 * @export
 * @interface CreatePromptAssetDto
 */
export interface CreatePromptAssetDto {
    /**
     * Clave única identificadora del asset (e.g., saludo_formal_es)
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'key': string;
    /**
     * Nombre descriptivo del asset
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'name': string;
    /**
     * Tipo de asset (e.g., texto, json, lista)
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'type'?: string;
    /**
     * Descripción más detallada del propósito del asset
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'description'?: string;
    /**
     * Categoría para organizar assets (e.g., Saludos, Despedidas)
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'category'?: string;
    /**
     * Valor inicial del asset para la primera versión (v1.0.0)
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'initialValue': string;
    /**
     * Mensaje de cambio para la primera versión
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'initialChangeMessage'?: string;
    /**
     * ID opcional del proyecto al que pertenece el asset
     * @type {string}
     * @memberof CreatePromptAssetDto
     */
    'projectId'?: string;
}
/**
 * 
 * @export
 * @interface CreatePromptAssetLinkDto
 */
export interface CreatePromptAssetLinkDto {
    /**
     * ID de la PromptVersion a la que se vincula el asset.
     * @type {string}
     * @memberof CreatePromptAssetLinkDto
     */
    'promptVersionId': string;
    /**
     * ID de la PromptAssetVersion que se vincula.
     * @type {string}
     * @memberof CreatePromptAssetLinkDto
     */
    'assetVersionId': string;
    /**
     * Contexto de uso o propósito de este asset en el prompt.
     * @type {string}
     * @memberof CreatePromptAssetLinkDto
     */
    'usageContext'?: string;
    /**
     * Orden posicional del asset dentro del prompt (si aplica).
     * @type {number}
     * @memberof CreatePromptAssetLinkDto
     */
    'position'?: number;
    /**
     * Lógica de inserción condicional (formato a definir).
     * @type {string}
     * @memberof CreatePromptAssetLinkDto
     */
    'insertionLogic'?: string;
    /**
     * Indica si el asset es requerido para el prompt (default: true).
     * @type {boolean}
     * @memberof CreatePromptAssetLinkDto
     */
    'isRequired'?: boolean;
}
/**
 * 
 * @export
 * @interface CreatePromptAssetVersionDto
 */
export interface CreatePromptAssetVersionDto {
    /**
     * Key (slug) del asset lógico al que pertenece esta versión
     * @type {string}
     * @memberof CreatePromptAssetVersionDto
     */
    'assetId': string;
    /**
     * El valor del asset para esta versión
     * @type {string}
     * @memberof CreatePromptAssetVersionDto
     */
    'value': string;
    /**
     * Etiqueta de versión (e.g., v1.0.0). Debe ser única por asset.
     * @type {string}
     * @memberof CreatePromptAssetVersionDto
     */
    'versionTag'?: string;
    /**
     * Mensaje describiendo los cambios en esta versión.
     * @type {string}
     * @memberof CreatePromptAssetVersionDto
     */
    'changeMessage'?: string;
}
/**
 * 
 * @export
 * @interface CreatePromptDto
 */
export interface CreatePromptDto {
    /**
     * Unique prompt name (used as ID)
     * @type {string}
     * @memberof CreatePromptDto
     */
    'name': string;
    /**
     * Description of the prompt\'s purpose.
     * @type {string}
     * @memberof CreatePromptDto
     */
    'description'?: string;
    /**
     * ID (name) of the associated conversational tactic.
     * @type {string}
     * @memberof CreatePromptDto
     */
    'tacticId'?: string;
    /**
     * List of tag names to associate.
     * @type {Set<string>}
     * @memberof CreatePromptDto
     */
    'tags'?: Set<string>;
    /**
     * Base prompt text for the first version (v1.0.0)
     * @type {string}
     * @memberof CreatePromptDto
     */
    'promptText': string;
    /**
     * Optional initial translations for the first version
     * @type {Array<InitialTranslationDto>}
     * @memberof CreatePromptDto
     */
    'initialTranslations'?: Array<InitialTranslationDto>;
}
/**
 * 
 * @export
 * @interface CreatePromptTranslationDto
 */
export interface CreatePromptTranslationDto {
    /**
     * ID de la versión del prompt a la que pertenece esta traducción
     * @type {string}
     * @memberof CreatePromptTranslationDto
     */
    'versionId': string;
    /**
     * Código de idioma para esta traducción (formato xx-XX)
     * @type {string}
     * @memberof CreatePromptTranslationDto
     */
    'languageCode': string;
    /**
     * Texto del prompt traducido a este idioma
     * @type {string}
     * @memberof CreatePromptTranslationDto
     */
    'promptText': string;
}
/**
 * 
 * @export
 * @interface CreatePromptVersionDto
 */
export interface CreatePromptVersionDto {
    /**
     * BASE prompt text for this new version.
     * @type {string}
     * @memberof CreatePromptVersionDto
     */
    'promptText': string;
    /**
     * Unique tag for this version within the prompt (e.g., v1.1.0, beta-feature-x).
     * @type {string}
     * @memberof CreatePromptVersionDto
     */
    'versionTag': string;
    /**
     * Message describing the changes in this version.
     * @type {string}
     * @memberof CreatePromptVersionDto
     */
    'changeMessage'?: string;
    /**
     * List of asset versions to link to this prompt version.
     * @type {Array<AssetVersionLinkDto>}
     * @memberof CreatePromptVersionDto
     */
    'assetLinks': Array<AssetVersionLinkDto>;
    /**
     * Optional initial translations for this new version.
     * @type {Array<InitialTranslationDto>}
     * @memberof CreatePromptVersionDto
     */
    'initialTranslations'?: Array<InitialTranslationDto>;
}
/**
 * 
 * @export
 * @interface CreateRagDocumentMetadataDto
 */
export interface CreateRagDocumentMetadataDto {
    /**
     * ID de la región asociada (opcional)
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'regionId'?: string;
    /**
     * Nombre del documento RAG
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'documentName': string;
    /**
     * Categoría (opcional)
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'category'?: string;
    /**
     * Indica si ha sido revisado por compliance
     * @type {boolean}
     * @memberof CreateRagDocumentMetadataDto
     */
    'complianceReviewed'?: boolean;
    /**
     * Nivel de riesgo PII (Información Personal Identificable) (opcional)
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'piiRiskLevel'?: string;
    /**
     * Identificador de quién lo revisó por última vez (opcional)
     * @type {string}
     * @memberof CreateRagDocumentMetadataDto
     */
    'lastReviewedBy'?: string;
}
/**
 * 
 * @export
 * @interface CreateRegionDto
 */
export interface CreateRegionDto {
    /**
     * Unique language code acting as ID
     * @type {string}
     * @memberof CreateRegionDto
     */
    'languageCode': string;
    /**
     * Name of the region
     * @type {string}
     * @memberof CreateRegionDto
     */
    'name': string;
    /**
     * languageCode of the parent region (optional)
     * @type {string}
     * @memberof CreateRegionDto
     */
    'parentRegionId'?: string;
    /**
     * Time zone
     * @type {string}
     * @memberof CreateRegionDto
     */
    'timeZone'?: string;
    /**
     * Default formality level (optional)
     * @type {string}
     * @memberof CreateRegionDto
     */
    'defaultFormalityLevel'?: string;
    /**
     * Additional notes (optional)
     * @type {string}
     * @memberof CreateRegionDto
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface CreateSystemPromptDto
 */
export interface CreateSystemPromptDto {
    /**
     * Unique name/identifier for the system prompt
     * @type {string}
     * @memberof CreateSystemPromptDto
     */
    'name': string;
    /**
     * Optional description of the prompt\'s purpose
     * @type {string}
     * @memberof CreateSystemPromptDto
     */
    'description'?: string;
    /**
     * The actual text content of the system prompt
     * @type {string}
     * @memberof CreateSystemPromptDto
     */
    'promptText': string;
    /**
     * Optional category for grouping prompts
     * @type {string}
     * @memberof CreateSystemPromptDto
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface CreateTagDto
 */
export interface CreateTagDto {
    /**
     * Nombre único de la etiqueta
     * @type {string}
     * @memberof CreateTagDto
     */
    'name': string;
    /**
     * Descripción opcional de la etiqueta
     * @type {string}
     * @memberof CreateTagDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * User\'s name
     * @type {string}
     * @memberof CreateUserDto
     */
    'name'?: string;
    /**
     * Unique user email
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * User\'s password
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CulturalDataResponse
 */
export interface CulturalDataResponse {
    /**
     * Unique ID for this cultural data (slug format)
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'id': string;
    /**
     * Associated region ID (xx-XX language code)
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'regionId': string;
    /**
     * Formality level (optional)
     * @type {number}
     * @memberof CulturalDataResponse
     */
    'formalityLevel'?: number;
    /**
     * Communication style (optional)
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'style'?: string;
    /**
     * Cultural considerations (optional)
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'considerations'?: string;
    /**
     * Additional notes (optional)
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'notes'?: string;
    /**
     * 
     * @type {CreateRegionDto}
     * @memberof CulturalDataResponse
     */
    'region': CreateRegionDto;
    /**
     * 
     * @type {string}
     * @memberof CulturalDataResponse
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface ExecuteLlmDto
 */
export interface ExecuteLlmDto {
    /**
     * ID del AIModel a utilizar (de la tabla AIModel)
     * @type {string}
     * @memberof ExecuteLlmDto
     */
    'modelId': string;
    /**
     * El texto completo del prompt ya procesado y listo para enviar al LLM
     * @type {string}
     * @memberof ExecuteLlmDto
     */
    'promptText': string;
    /**
     * Variables originales usadas para ensamblar el prompt (opcional, para logging/contexto)
     * @type {object}
     * @memberof ExecuteLlmDto
     */
    'variables'?: object;
}
/**
 * 
 * @export
 * @interface ExecutePromptBodyDto
 */
export interface ExecutePromptBodyDto {
    /**
     * 
     * @type {object}
     * @memberof ExecutePromptBodyDto
     */
    'variables': object;
}
/**
 * 
 * @export
 * @interface ExecuteRawDto
 */
export interface ExecuteRawDto {
    /**
     * The raw text input from the user.
     * @type {string}
     * @memberof ExecuteRawDto
     */
    'userText': string;
    /**
     * The unique name of the SystemPrompt to use.
     * @type {string}
     * @memberof ExecuteRawDto
     */
    'systemPromptName': string;
    /**
     * The unique ID (CUID) of the AIModel to use for execution.
     * @type {string}
     * @memberof ExecuteRawDto
     */
    'aiModelId': string;
}
/**
 * 
 * @export
 * @interface HealthControllerCheck200Response
 */
export interface HealthControllerCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'info'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'error'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'details'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface HealthControllerCheck200ResponseInfoValue
 */
export interface HealthControllerCheck200ResponseInfoValue {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200ResponseInfoValue
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface HealthControllerCheck503Response
 */
export interface HealthControllerCheck503Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck503Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'info'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'error'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'details'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface InitialTranslationDto
 */
export interface InitialTranslationDto {
    /**
     * ISO language code (e.g., es, en)
     * @type {string}
     * @memberof InitialTranslationDto
     */
    'languageCode': string;
    /**
     * Translated prompt text
     * @type {string}
     * @memberof InitialTranslationDto
     */
    'promptText': string;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * User email address
     * @type {string}
     * @memberof LoginDto
     */
    'email': string;
    /**
     * User password
     * @type {string}
     * @memberof LoginDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface RagDocumentMetadataResponse
 */
export interface RagDocumentMetadataResponse {
    /**
     * ID de la región asociada (opcional)
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'regionId'?: string;
    /**
     * Nombre del documento RAG
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'documentName': string;
    /**
     * Categoría (opcional)
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'category'?: string;
    /**
     * Indica si ha sido revisado por compliance
     * @type {boolean}
     * @memberof RagDocumentMetadataResponse
     */
    'complianceReviewed'?: boolean;
    /**
     * Nivel de riesgo PII (Información Personal Identificable) (opcional)
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'piiRiskLevel'?: string;
    /**
     * Identificador de quién lo revisó por última vez (opcional)
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'lastReviewedBy'?: string;
    /**
     * 
     * @type {CreateRegionDto}
     * @memberof RagDocumentMetadataResponse
     */
    'region'?: CreateRegionDto;
    /**
     * 
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RagDocumentMetadataResponse
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface RegisterDto
 */
export interface RegisterDto {
    /**
     * User email address
     * @type {string}
     * @memberof RegisterDto
     */
    'email': string;
    /**
     * User password
     * @type {string}
     * @memberof RegisterDto
     */
    'password': string;
    /**
     * User full name
     * @type {string}
     * @memberof RegisterDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TagDto
 */
export interface TagDto {
    /**
     * Unique ID of the tag (CUID)
     * @type {string}
     * @memberof TagDto
     */
    'id': string;
    /**
     * Unique tag name within the project
     * @type {string}
     * @memberof TagDto
     */
    'name': string;
    /**
     * Description of the tag
     * @type {string}
     * @memberof TagDto
     */
    'description': string;
    /**
     * ID of the project this tag belongs to (CUID)
     * @type {string}
     * @memberof TagDto
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface UpdateAiModelDto
 */
export interface UpdateAiModelDto {
    /**
     * Unique name for the AI model
     * @type {string}
     * @memberof UpdateAiModelDto
     */
    'name'?: string;
    /**
     * Provider of the AI model
     * @type {string}
     * @memberof UpdateAiModelDto
     */
    'provider'?: string;
    /**
     * Optional description for the AI model
     * @type {string}
     * @memberof UpdateAiModelDto
     */
    'description'?: string;
    /**
     * Identifier used for API calls
     * @type {string}
     * @memberof UpdateAiModelDto
     */
    'apiIdentifier'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAssetTranslationDto
 */
export interface UpdateAssetTranslationDto {
    /**
     * Valor del asset traducido a este idioma
     * @type {string}
     * @memberof UpdateAssetTranslationDto
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCulturalDataDto
 */
export interface UpdateCulturalDataDto {
    /**
     * Formality level (optional)
     * @type {number}
     * @memberof UpdateCulturalDataDto
     */
    'formalityLevel'?: number;
    /**
     * Communication style (optional)
     * @type {string}
     * @memberof UpdateCulturalDataDto
     */
    'style'?: string;
    /**
     * Cultural considerations (optional)
     * @type {string}
     * @memberof UpdateCulturalDataDto
     */
    'considerations'?: string;
    /**
     * Additional notes (optional)
     * @type {string}
     * @memberof UpdateCulturalDataDto
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface UpdateEnvironmentDto
 */
export interface UpdateEnvironmentDto {
    /**
     * New unique name for the environment (optional)
     * @type {string}
     * @memberof UpdateEnvironmentDto
     */
    'name'?: string;
    /**
     * New optional description for the environment
     * @type {string}
     * @memberof UpdateEnvironmentDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProjectDto
 */
export interface UpdateProjectDto {
    /**
     * Name of the project
     * @type {string}
     * @memberof UpdateProjectDto
     */
    'name'?: string;
    /**
     * Optional description for the project
     * @type {string}
     * @memberof UpdateProjectDto
     */
    'description'?: string;
    /**
     * Optional ID of the User who owns this project
     * @type {string}
     * @memberof UpdateProjectDto
     */
    'ownerUserId'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePromptAssetDto
 */
export interface UpdatePromptAssetDto {
    /**
     * Nombre descriptivo del asset
     * @type {string}
     * @memberof UpdatePromptAssetDto
     */
    'name'?: string;
    /**
     * Tipo de asset (e.g., texto, json, lista)
     * @type {string}
     * @memberof UpdatePromptAssetDto
     */
    'type'?: string;
    /**
     * Descripción más detallada del propósito del asset
     * @type {string}
     * @memberof UpdatePromptAssetDto
     */
    'description'?: string;
    /**
     * Categoría para organizar assets (e.g., Saludos, Despedidas)
     * @type {string}
     * @memberof UpdatePromptAssetDto
     */
    'category'?: string;
    /**
     * Activa o desactiva el asset
     * @type {boolean}
     * @memberof UpdatePromptAssetDto
     */
    'enabled'?: boolean;
    /**
     * ID opcional del proyecto al que pertenece el asset (null para desvincular)
     * @type {string}
     * @memberof UpdatePromptAssetDto
     */
    'projectId'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdatePromptAssetLinkDto
 */
export interface UpdatePromptAssetLinkDto {
    /**
     * Contexto de uso o propósito de este asset en el prompt.
     * @type {string}
     * @memberof UpdatePromptAssetLinkDto
     */
    'usageContext'?: string;
    /**
     * Orden posicional del asset dentro del prompt (si aplica).
     * @type {number}
     * @memberof UpdatePromptAssetLinkDto
     */
    'position'?: number;
    /**
     * Lógica de inserción condicional (formato a definir).
     * @type {string}
     * @memberof UpdatePromptAssetLinkDto
     */
    'insertionLogic'?: string;
    /**
     * Indica si el asset es requerido para el prompt (default: true).
     * @type {boolean}
     * @memberof UpdatePromptAssetLinkDto
     */
    'isRequired'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdatePromptAssetVersionDto
 */
export interface UpdatePromptAssetVersionDto {
    /**
     * Nuevo valor/contenido del asset para esta versión.
     * @type {string}
     * @memberof UpdatePromptAssetVersionDto
     */
    'value'?: string;
    /**
     * Nuevo mensaje describiendo los cambios.
     * @type {string}
     * @memberof UpdatePromptAssetVersionDto
     */
    'changeMessage'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePromptDto
 */
export interface UpdatePromptDto {
    /**
     * New description of the prompt\'s purpose.
     * @type {string}
     * @memberof UpdatePromptDto
     */
    'description'?: string;
    /**
     * ID of the tactic to associate, or null to disassociate.
     * @type {string}
     * @memberof UpdatePromptDto
     */
    'tacticId'?: string | null;
    /**
     * Complete list of Tag IDs to associate (replaces existing ones). Empty array to remove all.
     * @type {Array<string>}
     * @memberof UpdatePromptDto
     */
    'tagIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdatePromptTranslationDto
 */
export interface UpdatePromptTranslationDto {
    /**
     * Texto del prompt traducido a este idioma
     * @type {string}
     * @memberof UpdatePromptTranslationDto
     */
    'promptText'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePromptVersionDto
 */
export interface UpdatePromptVersionDto {
    /**
     * BASE prompt text for this new version.
     * @type {string}
     * @memberof UpdatePromptVersionDto
     */
    'promptText'?: string;
    /**
     * Message describing the changes in this version.
     * @type {string}
     * @memberof UpdatePromptVersionDto
     */
    'changeMessage'?: string;
    /**
     * List of asset versions to link to this prompt version.
     * @type {Array<AssetVersionLinkDto>}
     * @memberof UpdatePromptVersionDto
     */
    'assetLinks'?: Array<AssetVersionLinkDto>;
    /**
     * Optional initial translations for this new version.
     * @type {Array<InitialTranslationDto>}
     * @memberof UpdatePromptVersionDto
     */
    'initialTranslations'?: Array<InitialTranslationDto>;
}
/**
 * 
 * @export
 * @interface UpdateRegionDto
 */
export interface UpdateRegionDto {
    /**
     * Name of the region
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'name'?: string;
    /**
     * languageCode of the parent region (optional)
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'parentRegionId'?: string;
    /**
     * Time zone
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'timeZone'?: string;
    /**
     * Default formality level (optional)
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'defaultFormalityLevel'?: string;
    /**
     * Additional notes (optional)
     * @type {string}
     * @memberof UpdateRegionDto
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface UpdateSystemPromptDto
 */
export interface UpdateSystemPromptDto {
    /**
     * Unique name/identifier for the system prompt
     * @type {string}
     * @memberof UpdateSystemPromptDto
     */
    'name'?: string;
    /**
     * Optional description of the prompt\'s purpose
     * @type {string}
     * @memberof UpdateSystemPromptDto
     */
    'description'?: string;
    /**
     * The actual text content of the system prompt
     * @type {string}
     * @memberof UpdateSystemPromptDto
     */
    'promptText'?: string;
    /**
     * Optional category for grouping prompts
     * @type {string}
     * @memberof UpdateSystemPromptDto
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTagDto
 */
export interface UpdateTagDto {
    /**
     * Nuevo nombre único de la etiqueta (opcional)
     * @type {string}
     * @memberof UpdateTagDto
     */
    'name'?: string;
    /**
     * Nueva descripción opcional de la etiqueta
     * @type {string}
     * @memberof UpdateTagDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'createdAt': string;
}

/**
 * AIModelsProjectSpecificApi - axios parameter creator
 * @export
 */
export const AIModelsProjectSpecificApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new AI model for this project
         * @param {string} projectId 
         * @param {CreateAiModelDto} createAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerCreate: async (projectId: string, createAiModelDto: CreateAiModelDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerCreate', 'projectId', projectId)
            // verify required parameter 'createAiModelDto' is not null or undefined
            assertParamExists('aiModelControllerCreate', 'createAiModelDto', createAiModelDto)
            const localVarPath = `/api/projects/{projectId}/aimodels`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAiModelDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all AI models for this project (includes global models)
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/aimodels`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific AI model by ID (must belong to project or be global)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerFindOne: async (projectId: string, aiModelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerFindOne', 'projectId', projectId)
            // verify required parameter 'aiModelId' is not null or undefined
            assertParamExists('aiModelControllerFindOne', 'aiModelId', aiModelId)
            const localVarPath = `/api/projects/{projectId}/aimodels/{aiModelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"aiModelId"}}`, encodeURIComponent(String(aiModelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerRemove: async (projectId: string, aiModelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerRemove', 'projectId', projectId)
            // verify required parameter 'aiModelId' is not null or undefined
            assertParamExists('aiModelControllerRemove', 'aiModelId', aiModelId)
            const localVarPath = `/api/projects/{projectId}/aimodels/{aiModelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"aiModelId"}}`, encodeURIComponent(String(aiModelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {UpdateAiModelDto} updateAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerUpdate: async (projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('aiModelControllerUpdate', 'projectId', projectId)
            // verify required parameter 'aiModelId' is not null or undefined
            assertParamExists('aiModelControllerUpdate', 'aiModelId', aiModelId)
            // verify required parameter 'updateAiModelDto' is not null or undefined
            assertParamExists('aiModelControllerUpdate', 'updateAiModelDto', updateAiModelDto)
            const localVarPath = `/api/projects/{projectId}/aimodels/{aiModelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"aiModelId"}}`, encodeURIComponent(String(aiModelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAiModelDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIModelsProjectSpecificApi - functional programming interface
 * @export
 */
export const AIModelsProjectSpecificApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIModelsProjectSpecificApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new AI model for this project
         * @param {string} projectId 
         * @param {CreateAiModelDto} createAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerCreate(projectId: string, createAiModelDto: CreateAiModelDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AiModelResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerCreate(projectId, createAiModelDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all AI models for this project (includes global models)
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AiModelResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific AI model by ID (must belong to project or be global)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerFindOne(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AiModelResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerFindOne(projectId, aiModelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerRemove(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AiModelResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerRemove(projectId, aiModelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {UpdateAiModelDto} updateAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiModelControllerUpdate(projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AiModelResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiModelControllerUpdate(projectId, aiModelId, updateAiModelDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIModelsProjectSpecificApi.aiModelControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AIModelsProjectSpecificApi - factory interface
 * @export
 */
export const AIModelsProjectSpecificApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIModelsProjectSpecificApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new AI model for this project
         * @param {string} projectId 
         * @param {CreateAiModelDto} createAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerCreate(projectId: string, createAiModelDto: CreateAiModelDto, options?: RawAxiosRequestConfig): AxiosPromise<AiModelResponseDto> {
            return localVarFp.aiModelControllerCreate(projectId, createAiModelDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all AI models for this project (includes global models)
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AiModelResponseDto>> {
            return localVarFp.aiModelControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific AI model by ID (must belong to project or be global)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerFindOne(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): AxiosPromise<AiModelResponseDto> {
            return localVarFp.aiModelControllerFindOne(projectId, aiModelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerRemove(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig): AxiosPromise<AiModelResponseDto> {
            return localVarFp.aiModelControllerRemove(projectId, aiModelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an AI model by ID (must belong to project)
         * @param {string} projectId Project ID
         * @param {string} aiModelId AI Model CUID
         * @param {UpdateAiModelDto} updateAiModelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiModelControllerUpdate(projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options?: RawAxiosRequestConfig): AxiosPromise<AiModelResponseDto> {
            return localVarFp.aiModelControllerUpdate(projectId, aiModelId, updateAiModelDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIModelsProjectSpecificApi - object-oriented interface
 * @export
 * @class AIModelsProjectSpecificApi
 * @extends {BaseAPI}
 */
export class AIModelsProjectSpecificApi extends BaseAPI {
    /**
     * 
     * @summary Create a new AI model for this project
     * @param {string} projectId 
     * @param {CreateAiModelDto} createAiModelDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerCreate(projectId: string, createAiModelDto: CreateAiModelDto, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerCreate(projectId, createAiModelDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all AI models for this project (includes global models)
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific AI model by ID (must belong to project or be global)
     * @param {string} projectId Project ID
     * @param {string} aiModelId AI Model CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerFindOne(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerFindOne(projectId, aiModelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an AI model by ID (must belong to project)
     * @param {string} projectId Project ID
     * @param {string} aiModelId AI Model CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerRemove(projectId: string, aiModelId: string, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerRemove(projectId, aiModelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an AI model by ID (must belong to project)
     * @param {string} projectId Project ID
     * @param {string} aiModelId AI Model CUID
     * @param {UpdateAiModelDto} updateAiModelDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIModelsProjectSpecificApi
     */
    public aiModelControllerUpdate(projectId: string, aiModelId: string, updateAiModelDto: UpdateAiModelDto, options?: RawAxiosRequestConfig) {
        return AIModelsProjectSpecificApiFp(this.configuration).aiModelControllerUpdate(projectId, aiModelId, updateAiModelDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AssetTranslationsWithinProjectAssetVersionApi - axios parameter creator
 * @export
 */
export const AssetTranslationsWithinProjectAssetVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a translation for a specific asset version within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {CreateAssetTranslationDto} createAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerCreate: async (projectId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'versionTag', versionTag)
            // verify required parameter 'createAssetTranslationDto' is not null or undefined
            assertParamExists('assetTranslationControllerCreate', 'createAssetTranslationDto', createAssetTranslationDto)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}/translations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAssetTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all translations for a specific asset version within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerFindAll: async (projectId: string, assetKey: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerFindAll', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerFindAll', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerFindAll', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}/translations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerFindOneByLanguage: async (projectId: string, assetKey: string, versionTag: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('assetTranslationControllerFindOneByLanguage', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerRemove: async (projectId: string, assetKey: string, versionTag: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('assetTranslationControllerRemove', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerUpdate: async (projectId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'languageCode', languageCode)
            // verify required parameter 'updateAssetTranslationDto' is not null or undefined
            assertParamExists('assetTranslationControllerUpdate', 'updateAssetTranslationDto', updateAssetTranslationDto)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAssetTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetTranslationsWithinProjectAssetVersionApi - functional programming interface
 * @export
 */
export const AssetTranslationsWithinProjectAssetVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetTranslationsWithinProjectAssetVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a translation for a specific asset version within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {CreateAssetTranslationDto} createAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerCreate(projectId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerCreate(projectId, assetKey, versionTag, createAssetTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsWithinProjectAssetVersionApi.assetTranslationControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all translations for a specific asset version within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerFindAll(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateAssetTranslationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerFindAll(projectId, assetKey, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsWithinProjectAssetVersionApi.assetTranslationControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerFindOneByLanguage(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerFindOneByLanguage(projectId, assetKey, versionTag, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsWithinProjectAssetVersionApi.assetTranslationControllerFindOneByLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerRemove(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerRemove(projectId, assetKey, versionTag, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsWithinProjectAssetVersionApi.assetTranslationControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetTranslationControllerUpdate(projectId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetTranslationControllerUpdate(projectId, assetKey, versionTag, languageCode, updateAssetTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetTranslationsWithinProjectAssetVersionApi.assetTranslationControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetTranslationsWithinProjectAssetVersionApi - factory interface
 * @export
 */
export const AssetTranslationsWithinProjectAssetVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetTranslationsWithinProjectAssetVersionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a translation for a specific asset version within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {CreateAssetTranslationDto} createAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerCreate(projectId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetTranslationDto> {
            return localVarFp.assetTranslationControllerCreate(projectId, assetKey, versionTag, createAssetTranslationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all translations for a specific asset version within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerFindAll(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateAssetTranslationDto>> {
            return localVarFp.assetTranslationControllerFindAll(projectId, assetKey, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerFindOneByLanguage(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetTranslationDto> {
            return localVarFp.assetTranslationControllerFindOneByLanguage(projectId, assetKey, versionTag, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerRemove(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.assetTranslationControllerRemove(projectId, assetKey, versionTag, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific translation by language code for an asset version
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetTranslationControllerUpdate(projectId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetTranslationDto> {
            return localVarFp.assetTranslationControllerUpdate(projectId, assetKey, versionTag, languageCode, updateAssetTranslationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetTranslationsWithinProjectAssetVersionApi - object-oriented interface
 * @export
 * @class AssetTranslationsWithinProjectAssetVersionApi
 * @extends {BaseAPI}
 */
export class AssetTranslationsWithinProjectAssetVersionApi extends BaseAPI {
    /**
     * 
     * @summary Create a translation for a specific asset version within a project
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {CreateAssetTranslationDto} createAssetTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApi
     */
    public assetTranslationControllerCreate(projectId: string, assetKey: string, versionTag: string, createAssetTranslationDto: CreateAssetTranslationDto, options?: RawAxiosRequestConfig) {
        return AssetTranslationsWithinProjectAssetVersionApiFp(this.configuration).assetTranslationControllerCreate(projectId, assetKey, versionTag, createAssetTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all translations for a specific asset version within a project
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApi
     */
    public assetTranslationControllerFindAll(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return AssetTranslationsWithinProjectAssetVersionApiFp(this.configuration).assetTranslationControllerFindAll(projectId, assetKey, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific translation by language code for an asset version
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code (e.g., es-ES)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApi
     */
    public assetTranslationControllerFindOneByLanguage(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return AssetTranslationsWithinProjectAssetVersionApiFp(this.configuration).assetTranslationControllerFindOneByLanguage(projectId, assetKey, versionTag, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific translation by language code for an asset version
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code of the translation to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApi
     */
    public assetTranslationControllerRemove(projectId: string, assetKey: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return AssetTranslationsWithinProjectAssetVersionApiFp(this.configuration).assetTranslationControllerRemove(projectId, assetKey, versionTag, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific translation by language code for an asset version
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code of the translation to update
     * @param {UpdateAssetTranslationDto} updateAssetTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetTranslationsWithinProjectAssetVersionApi
     */
    public assetTranslationControllerUpdate(projectId: string, assetKey: string, versionTag: string, languageCode: string, updateAssetTranslationDto: UpdateAssetTranslationDto, options?: RawAxiosRequestConfig) {
        return AssetTranslationsWithinProjectAssetVersionApiFp(this.configuration).assetTranslationControllerUpdate(projectId, assetKey, versionTag, languageCode, updateAssetTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log in a user
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerDto: RegisterDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authControllerRegister', 'registerDto', registerDto)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Log in a user
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile(options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Log in a user
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.authControllerRegister(registerDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerGetProfile(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Log in a user
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRegister(registerDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CulturalDataApi - axios parameter creator
 * @export
 */
export const CulturalDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates new cultural data within a project
         * @param {string} projectId Project ID
         * @param {CreateCulturalDataDto} createCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerCreate: async (projectId: string, createCulturalDataDto: CreateCulturalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerCreate', 'projectId', projectId)
            // verify required parameter 'createCulturalDataDto' is not null or undefined
            assertParamExists('culturalDataControllerCreate', 'createCulturalDataDto', createCulturalDataDto)
            const localVarPath = `/api/projects/{projectId}/cultural-data`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCulturalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all cultural data for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/cultural-data`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets cultural data by ID within a project
         * @param {string} culturalDataId ID of the cultural data
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerFindOne: async (culturalDataId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culturalDataId' is not null or undefined
            assertParamExists('culturalDataControllerFindOne', 'culturalDataId', culturalDataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/cultural-data/{culturalDataId}`
                .replace(`{${"culturalDataId"}}`, encodeURIComponent(String(culturalDataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes cultural data by ID within a project
         * @param {string} culturalDataId ID to delete
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerRemove: async (culturalDataId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culturalDataId' is not null or undefined
            assertParamExists('culturalDataControllerRemove', 'culturalDataId', culturalDataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/cultural-data/{culturalDataId}`
                .replace(`{${"culturalDataId"}}`, encodeURIComponent(String(culturalDataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates cultural data by ID within a project
         * @param {string} culturalDataId ID to update
         * @param {string} projectId Project ID
         * @param {UpdateCulturalDataDto} updateCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerUpdate: async (culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'culturalDataId' is not null or undefined
            assertParamExists('culturalDataControllerUpdate', 'culturalDataId', culturalDataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('culturalDataControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateCulturalDataDto' is not null or undefined
            assertParamExists('culturalDataControllerUpdate', 'updateCulturalDataDto', updateCulturalDataDto)
            const localVarPath = `/api/projects/{projectId}/cultural-data/{culturalDataId}`
                .replace(`{${"culturalDataId"}}`, encodeURIComponent(String(culturalDataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCulturalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CulturalDataApi - functional programming interface
 * @export
 */
export const CulturalDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CulturalDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates new cultural data within a project
         * @param {string} projectId Project ID
         * @param {CreateCulturalDataDto} createCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerCreate(projectId: string, createCulturalDataDto: CreateCulturalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CulturalDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerCreate(projectId, createCulturalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets all cultural data for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CulturalDataResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets cultural data by ID within a project
         * @param {string} culturalDataId ID of the cultural data
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerFindOne(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CulturalDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerFindOne(culturalDataId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes cultural data by ID within a project
         * @param {string} culturalDataId ID to delete
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerRemove(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerRemove(culturalDataId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates cultural data by ID within a project
         * @param {string} culturalDataId ID to update
         * @param {string} projectId Project ID
         * @param {UpdateCulturalDataDto} updateCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async culturalDataControllerUpdate(culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CulturalDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.culturalDataControllerUpdate(culturalDataId, projectId, updateCulturalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CulturalDataApi.culturalDataControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CulturalDataApi - factory interface
 * @export
 */
export const CulturalDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CulturalDataApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates new cultural data within a project
         * @param {string} projectId Project ID
         * @param {CreateCulturalDataDto} createCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerCreate(projectId: string, createCulturalDataDto: CreateCulturalDataDto, options?: RawAxiosRequestConfig): AxiosPromise<CulturalDataResponse> {
            return localVarFp.culturalDataControllerCreate(projectId, createCulturalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all cultural data for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CulturalDataResponse>> {
            return localVarFp.culturalDataControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets cultural data by ID within a project
         * @param {string} culturalDataId ID of the cultural data
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerFindOne(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CulturalDataResponse> {
            return localVarFp.culturalDataControllerFindOne(culturalDataId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes cultural data by ID within a project
         * @param {string} culturalDataId ID to delete
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerRemove(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.culturalDataControllerRemove(culturalDataId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates cultural data by ID within a project
         * @param {string} culturalDataId ID to update
         * @param {string} projectId Project ID
         * @param {UpdateCulturalDataDto} updateCulturalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        culturalDataControllerUpdate(culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options?: RawAxiosRequestConfig): AxiosPromise<CulturalDataResponse> {
            return localVarFp.culturalDataControllerUpdate(culturalDataId, projectId, updateCulturalDataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CulturalDataApi - object-oriented interface
 * @export
 * @class CulturalDataApi
 * @extends {BaseAPI}
 */
export class CulturalDataApi extends BaseAPI {
    /**
     * 
     * @summary Creates new cultural data within a project
     * @param {string} projectId Project ID
     * @param {CreateCulturalDataDto} createCulturalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerCreate(projectId: string, createCulturalDataDto: CreateCulturalDataDto, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerCreate(projectId, createCulturalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all cultural data for a project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets cultural data by ID within a project
     * @param {string} culturalDataId ID of the cultural data
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerFindOne(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerFindOne(culturalDataId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes cultural data by ID within a project
     * @param {string} culturalDataId ID to delete
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerRemove(culturalDataId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerRemove(culturalDataId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates cultural data by ID within a project
     * @param {string} culturalDataId ID to update
     * @param {string} projectId Project ID
     * @param {UpdateCulturalDataDto} updateCulturalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CulturalDataApi
     */
    public culturalDataControllerUpdate(culturalDataId: string, projectId: string, updateCulturalDataDto: UpdateCulturalDataDto, options?: RawAxiosRequestConfig) {
        return CulturalDataApiFp(this.configuration).culturalDataControllerUpdate(culturalDataId, projectId, updateCulturalDataDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new environment for a project
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentDto} createEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerCreate: async (projectId: string, createEnvironmentDto: CreateEnvironmentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerCreate', 'projectId', projectId)
            // verify required parameter 'createEnvironmentDto' is not null or undefined
            assertParamExists('environmentControllerCreate', 'createEnvironmentDto', createEnvironmentDto)
            const localVarPath = `/api/projects/{projectId}/environments`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEnvironmentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all environments for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/environments`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an environment by its name within a project
         * @param {string} name Unique environment name in the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindByName: async (name: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('environmentControllerFindByName', 'name', name)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerFindByName', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/environments/by-name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an environment by its ID within a project
         * @param {string} environmentId Unique environment ID (CUID)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindOne: async (environmentId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('environmentControllerFindOne', 'environmentId', environmentId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/environments/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an environment from a project
         * @param {string} environmentId Unique ID of the environment to delete (CUID)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerRemove: async (environmentId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('environmentControllerRemove', 'environmentId', environmentId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/environments/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing environment in a project
         * @param {string} environmentId Unique ID of the environment to update (CUID)
         * @param {string} projectId Project ID
         * @param {UpdateEnvironmentDto} updateEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerUpdate: async (environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('environmentControllerUpdate', 'environmentId', environmentId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('environmentControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateEnvironmentDto' is not null or undefined
            assertParamExists('environmentControllerUpdate', 'updateEnvironmentDto', updateEnvironmentDto)
            const localVarPath = `/api/projects/{projectId}/environments/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEnvironmentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new environment for a project
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentDto} createEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerCreate(projectId: string, createEnvironmentDto: CreateEnvironmentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerCreate(projectId, createEnvironmentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets all environments for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateEnvironmentDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets an environment by its name within a project
         * @param {string} name Unique environment name in the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerFindByName(name, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerFindByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets an environment by its ID within a project
         * @param {string} environmentId Unique environment ID (CUID)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerFindOne(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerFindOne(environmentId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes an environment from a project
         * @param {string} environmentId Unique ID of the environment to delete (CUID)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerRemove(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerRemove(environmentId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an existing environment in a project
         * @param {string} environmentId Unique ID of the environment to update (CUID)
         * @param {string} projectId Project ID
         * @param {UpdateEnvironmentDto} updateEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentControllerUpdate(environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEnvironmentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentControllerUpdate(environmentId, projectId, updateEnvironmentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.environmentControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new environment for a project
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentDto} createEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerCreate(projectId: string, createEnvironmentDto: CreateEnvironmentDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerCreate(projectId, createEnvironmentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all environments for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateEnvironmentDto>> {
            return localVarFp.environmentControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an environment by its name within a project
         * @param {string} name Unique environment name in the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerFindByName(name, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an environment by its ID within a project
         * @param {string} environmentId Unique environment ID (CUID)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerFindOne(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerFindOne(environmentId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an environment from a project
         * @param {string} environmentId Unique ID of the environment to delete (CUID)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerRemove(environmentId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerRemove(environmentId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an existing environment in a project
         * @param {string} environmentId Unique ID of the environment to update (CUID)
         * @param {string} projectId Project ID
         * @param {UpdateEnvironmentDto} updateEnvironmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentControllerUpdate(environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateEnvironmentDto> {
            return localVarFp.environmentControllerUpdate(environmentId, projectId, updateEnvironmentDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new environment for a project
     * @param {string} projectId Project ID
     * @param {CreateEnvironmentDto} createEnvironmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerCreate(projectId: string, createEnvironmentDto: CreateEnvironmentDto, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerCreate(projectId, createEnvironmentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all environments for a project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an environment by its name within a project
     * @param {string} name Unique environment name in the project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerFindByName(name, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an environment by its ID within a project
     * @param {string} environmentId Unique environment ID (CUID)
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerFindOne(environmentId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerFindOne(environmentId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an environment from a project
     * @param {string} environmentId Unique ID of the environment to delete (CUID)
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerRemove(environmentId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerRemove(environmentId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an existing environment in a project
     * @param {string} environmentId Unique ID of the environment to update (CUID)
     * @param {string} projectId Project ID
     * @param {UpdateEnvironmentDto} updateEnvironmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public environmentControllerUpdate(environmentId: string, projectId: string, updateEnvironmentDto: UpdateEnvironmentDto, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).environmentControllerUpdate(environmentId, projectId, updateEnvironmentDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthControllerCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthControllerCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck(options?: RawAxiosRequestConfig): AxiosPromise<HealthControllerCheck200Response> {
            return localVarFp.healthControllerCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LLMExecutionApi - axios parameter creator
 * @export
 */
export const LLMExecutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
         * @param {ExecuteLlmDto} executeLlmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        llmExecutionControllerExecuteLlm: async (executeLlmDto: ExecuteLlmDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'executeLlmDto' is not null or undefined
            assertParamExists('llmExecutionControllerExecuteLlm', 'executeLlmDto', executeLlmDto)
            const localVarPath = `/llm-execution/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeLlmDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LLMExecutionApi - functional programming interface
 * @export
 */
export const LLMExecutionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LLMExecutionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
         * @param {ExecuteLlmDto} executeLlmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async llmExecutionControllerExecuteLlm(executeLlmDto: ExecuteLlmDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.llmExecutionControllerExecuteLlm(executeLlmDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMExecutionApi.llmExecutionControllerExecuteLlm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LLMExecutionApi - factory interface
 * @export
 */
export const LLMExecutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LLMExecutionApiFp(configuration)
    return {
        /**
         * 
         * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
         * @param {ExecuteLlmDto} executeLlmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        llmExecutionControllerExecuteLlm(executeLlmDto: ExecuteLlmDto, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.llmExecutionControllerExecuteLlm(executeLlmDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LLMExecutionApi - object-oriented interface
 * @export
 * @class LLMExecutionApi
 * @extends {BaseAPI}
 */
export class LLMExecutionApi extends BaseAPI {
    /**
     * 
     * @summary Executes a pre-assembled prompt using a specified AI Model via LangChain
     * @param {ExecuteLlmDto} executeLlmDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMExecutionApi
     */
    public llmExecutionControllerExecuteLlm(executeLlmDto: ExecuteLlmDto, options?: RawAxiosRequestConfig) {
        return LLMExecutionApiFp(this.configuration).llmExecutionControllerExecuteLlm(executeLlmDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreate: async (createProjectDto: CreateProjectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectDto' is not null or undefined
            assertParamExists('projectControllerCreate', 'createProjectDto', createProjectDto)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get projects accessible by the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindMine: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects/mine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a project by ID
         * @param {string} id Project CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerFindOne', 'id', id)
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a project by ID
         * @param {string} id Project CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerRemove', 'id', id)
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a project by ID
         * @param {string} id Project CUID
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdate: async (id: string, updateProjectDto: UpdateProjectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerUpdate', 'id', id)
            // verify required parameter 'updateProjectDto' is not null or undefined
            assertParamExists('projectControllerUpdate', 'updateProjectDto', updateProjectDto)
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerCreate(createProjectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateProjectDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get projects accessible by the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerFindMine(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateProjectDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerFindMine(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerFindMine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a project by ID
         * @param {string} id Project CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a project by ID
         * @param {string} id Project CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a project by ID
         * @param {string} id Project CUID
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerUpdate(id, updateProjectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectDto> {
            return localVarFp.projectControllerCreate(createProjectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateProjectDto>> {
            return localVarFp.projectControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get projects accessible by the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindMine(options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateProjectDto>> {
            return localVarFp.projectControllerFindMine(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a project by ID
         * @param {string} id Project CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectDto> {
            return localVarFp.projectControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a project by ID
         * @param {string} id Project CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectDto> {
            return localVarFp.projectControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a project by ID
         * @param {string} id Project CUID
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectDto> {
            return localVarFp.projectControllerUpdate(id, updateProjectDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new project
     * @param {CreateProjectDto} createProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerCreate(createProjectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerFindAll(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get projects accessible by the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerFindMine(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerFindMine(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a project by ID
     * @param {string} id Project CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a project by ID
     * @param {string} id Project CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a project by ID
     * @param {string} id Project CUID
     * @param {UpdateProjectDto} updateProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerUpdate(id, updateProjectDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptAssetLinksWithinProjectVersionApi - axios parameter creator
 * @export
 */
export const PromptAssetLinksWithinProjectVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Link an Asset Version to a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {CreatePromptAssetLinkDto} createPromptAssetLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerCreate: async (projectId: string, promptVersionId: string, createPromptAssetLinkDto: CreatePromptAssetLinkDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetLinkControllerCreate', 'projectId', projectId)
            // verify required parameter 'promptVersionId' is not null or undefined
            assertParamExists('promptAssetLinkControllerCreate', 'promptVersionId', promptVersionId)
            // verify required parameter 'createPromptAssetLinkDto' is not null or undefined
            assertParamExists('promptAssetLinkControllerCreate', 'createPromptAssetLinkDto', createPromptAssetLinkDto)
            const localVarPath = `/api/projects/{projectId}/prompt-versions/{promptVersionId}/links`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptVersionId"}}`, encodeURIComponent(String(promptVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptAssetLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all links for a specific Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerFindAll: async (projectId: string, promptVersionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetLinkControllerFindAll', 'projectId', projectId)
            // verify required parameter 'promptVersionId' is not null or undefined
            assertParamExists('promptAssetLinkControllerFindAll', 'promptVersionId', promptVersionId)
            const localVarPath = `/api/projects/{projectId}/prompt-versions/{promptVersionId}/links`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptVersionId"}}`, encodeURIComponent(String(promptVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerFindOne: async (projectId: string, promptVersionId: string, linkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetLinkControllerFindOne', 'projectId', projectId)
            // verify required parameter 'promptVersionId' is not null or undefined
            assertParamExists('promptAssetLinkControllerFindOne', 'promptVersionId', promptVersionId)
            // verify required parameter 'linkId' is not null or undefined
            assertParamExists('promptAssetLinkControllerFindOne', 'linkId', linkId)
            const localVarPath = `/api/projects/{projectId}/prompt-versions/{promptVersionId}/links/{linkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptVersionId"}}`, encodeURIComponent(String(promptVersionId)))
                .replace(`{${"linkId"}}`, encodeURIComponent(String(linkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerRemove: async (projectId: string, promptVersionId: string, linkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetLinkControllerRemove', 'projectId', projectId)
            // verify required parameter 'promptVersionId' is not null or undefined
            assertParamExists('promptAssetLinkControllerRemove', 'promptVersionId', promptVersionId)
            // verify required parameter 'linkId' is not null or undefined
            assertParamExists('promptAssetLinkControllerRemove', 'linkId', linkId)
            const localVarPath = `/api/projects/{projectId}/prompt-versions/{promptVersionId}/links/{linkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptVersionId"}}`, encodeURIComponent(String(promptVersionId)))
                .replace(`{${"linkId"}}`, encodeURIComponent(String(linkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {UpdatePromptAssetLinkDto} updatePromptAssetLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerUpdate: async (projectId: string, promptVersionId: string, linkId: string, updatePromptAssetLinkDto: UpdatePromptAssetLinkDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetLinkControllerUpdate', 'projectId', projectId)
            // verify required parameter 'promptVersionId' is not null or undefined
            assertParamExists('promptAssetLinkControllerUpdate', 'promptVersionId', promptVersionId)
            // verify required parameter 'linkId' is not null or undefined
            assertParamExists('promptAssetLinkControllerUpdate', 'linkId', linkId)
            // verify required parameter 'updatePromptAssetLinkDto' is not null or undefined
            assertParamExists('promptAssetLinkControllerUpdate', 'updatePromptAssetLinkDto', updatePromptAssetLinkDto)
            const localVarPath = `/api/projects/{projectId}/prompt-versions/{promptVersionId}/links/{linkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptVersionId"}}`, encodeURIComponent(String(promptVersionId)))
                .replace(`{${"linkId"}}`, encodeURIComponent(String(linkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptAssetLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptAssetLinksWithinProjectVersionApi - functional programming interface
 * @export
 */
export const PromptAssetLinksWithinProjectVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptAssetLinksWithinProjectVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Link an Asset Version to a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {CreatePromptAssetLinkDto} createPromptAssetLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetLinkControllerCreate(projectId: string, promptVersionId: string, createPromptAssetLinkDto: CreatePromptAssetLinkDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetLinkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetLinkControllerCreate(projectId, promptVersionId, createPromptAssetLinkDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetLinksWithinProjectVersionApi.promptAssetLinkControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all links for a specific Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetLinkControllerFindAll(projectId: string, promptVersionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptAssetLinkDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetLinkControllerFindAll(projectId, promptVersionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetLinksWithinProjectVersionApi.promptAssetLinkControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetLinkControllerFindOne(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetLinkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetLinkControllerFindOne(projectId, promptVersionId, linkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetLinksWithinProjectVersionApi.promptAssetLinkControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetLinkControllerRemove(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetLinkControllerRemove(projectId, promptVersionId, linkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetLinksWithinProjectVersionApi.promptAssetLinkControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {UpdatePromptAssetLinkDto} updatePromptAssetLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetLinkControllerUpdate(projectId: string, promptVersionId: string, linkId: string, updatePromptAssetLinkDto: UpdatePromptAssetLinkDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetLinkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetLinkControllerUpdate(projectId, promptVersionId, linkId, updatePromptAssetLinkDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetLinksWithinProjectVersionApi.promptAssetLinkControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptAssetLinksWithinProjectVersionApi - factory interface
 * @export
 */
export const PromptAssetLinksWithinProjectVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptAssetLinksWithinProjectVersionApiFp(configuration)
    return {
        /**
         * 
         * @summary Link an Asset Version to a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {CreatePromptAssetLinkDto} createPromptAssetLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerCreate(projectId: string, promptVersionId: string, createPromptAssetLinkDto: CreatePromptAssetLinkDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetLinkDto> {
            return localVarFp.promptAssetLinkControllerCreate(projectId, promptVersionId, createPromptAssetLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all links for a specific Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerFindAll(projectId: string, promptVersionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptAssetLinkDto>> {
            return localVarFp.promptAssetLinkControllerFindAll(projectId, promptVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerFindOne(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetLinkDto> {
            return localVarFp.promptAssetLinkControllerFindOne(projectId, promptVersionId, linkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerRemove(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetLinkControllerRemove(projectId, promptVersionId, linkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific link by its ID for a Prompt Version within a Project
         * @param {string} projectId Project ID
         * @param {string} promptVersionId Prompt Version ID
         * @param {string} linkId Link ID
         * @param {UpdatePromptAssetLinkDto} updatePromptAssetLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetLinkControllerUpdate(projectId: string, promptVersionId: string, linkId: string, updatePromptAssetLinkDto: UpdatePromptAssetLinkDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetLinkDto> {
            return localVarFp.promptAssetLinkControllerUpdate(projectId, promptVersionId, linkId, updatePromptAssetLinkDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptAssetLinksWithinProjectVersionApi - object-oriented interface
 * @export
 * @class PromptAssetLinksWithinProjectVersionApi
 * @extends {BaseAPI}
 */
export class PromptAssetLinksWithinProjectVersionApi extends BaseAPI {
    /**
     * 
     * @summary Link an Asset Version to a Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {CreatePromptAssetLinkDto} createPromptAssetLinkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApi
     */
    public promptAssetLinkControllerCreate(projectId: string, promptVersionId: string, createPromptAssetLinkDto: CreatePromptAssetLinkDto, options?: RawAxiosRequestConfig) {
        return PromptAssetLinksWithinProjectVersionApiFp(this.configuration).promptAssetLinkControllerCreate(projectId, promptVersionId, createPromptAssetLinkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all links for a specific Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApi
     */
    public promptAssetLinkControllerFindAll(projectId: string, promptVersionId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetLinksWithinProjectVersionApiFp(this.configuration).promptAssetLinkControllerFindAll(projectId, promptVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific link by its ID for a Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {string} linkId Link ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApi
     */
    public promptAssetLinkControllerFindOne(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetLinksWithinProjectVersionApiFp(this.configuration).promptAssetLinkControllerFindOne(projectId, promptVersionId, linkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific link by its ID for a Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {string} linkId Link ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApi
     */
    public promptAssetLinkControllerRemove(projectId: string, promptVersionId: string, linkId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetLinksWithinProjectVersionApiFp(this.configuration).promptAssetLinkControllerRemove(projectId, promptVersionId, linkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific link by its ID for a Prompt Version within a Project
     * @param {string} projectId Project ID
     * @param {string} promptVersionId Prompt Version ID
     * @param {string} linkId Link ID
     * @param {UpdatePromptAssetLinkDto} updatePromptAssetLinkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetLinksWithinProjectVersionApi
     */
    public promptAssetLinkControllerUpdate(projectId: string, promptVersionId: string, linkId: string, updatePromptAssetLinkDto: UpdatePromptAssetLinkDto, options?: RawAxiosRequestConfig) {
        return PromptAssetLinksWithinProjectVersionApiFp(this.configuration).promptAssetLinkControllerUpdate(projectId, promptVersionId, linkId, updatePromptAssetLinkDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptAssetVersionsWithinProjectAssetApi - axios parameter creator
 * @export
 */
export const PromptAssetVersionsWithinProjectAssetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new version for a specific asset within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerCreate: async (projectId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerCreate', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerCreate', 'assetKey', assetKey)
            // verify required parameter 'createPromptAssetVersionDto' is not null or undefined
            assertParamExists('promptAssetVersionControllerCreate', 'createPromptAssetVersionDto', createPromptAssetVersionDto)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptAssetVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all versions for a specific asset within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerFindAll: async (projectId: string, assetKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindAll', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindAll', 'assetKey', assetKey)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag (e.g., v1.0.0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerFindOneByTag: async (projectId: string, assetKey: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindOneByTag', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindOneByTag', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptAssetVersionControllerFindOneByTag', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerRemove: async (projectId: string, assetKey: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerRemove', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerRemove', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptAssetVersionControllerRemove', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerUpdate: async (projectId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'projectId', projectId)
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'assetKey', assetKey)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'versionTag', versionTag)
            // verify required parameter 'updatePromptAssetVersionDto' is not null or undefined
            assertParamExists('promptAssetVersionControllerUpdate', 'updatePromptAssetVersionDto', updatePromptAssetVersionDto)
            const localVarPath = `/api/projects/{projectId}/assets/{assetKey}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptAssetVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptAssetVersionsWithinProjectAssetApi - functional programming interface
 * @export
 */
export const PromptAssetVersionsWithinProjectAssetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptAssetVersionsWithinProjectAssetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new version for a specific asset within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerCreate(projectId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerCreate(projectId, assetKey, createPromptAssetVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsWithinProjectAssetApi.promptAssetVersionControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all versions for a specific asset within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerFindAll(projectId: string, assetKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptAssetVersionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerFindAll(projectId, assetKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsWithinProjectAssetApi.promptAssetVersionControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag (e.g., v1.0.0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerFindOneByTag(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerFindOneByTag(projectId, assetKey, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsWithinProjectAssetApi.promptAssetVersionControllerFindOneByTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerRemove(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerRemove(projectId, assetKey, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsWithinProjectAssetApi.promptAssetVersionControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetVersionControllerUpdate(projectId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptAssetVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetVersionControllerUpdate(projectId, assetKey, versionTag, updatePromptAssetVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetVersionsWithinProjectAssetApi.promptAssetVersionControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptAssetVersionsWithinProjectAssetApi - factory interface
 * @export
 */
export const PromptAssetVersionsWithinProjectAssetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptAssetVersionsWithinProjectAssetApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new version for a specific asset within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerCreate(projectId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto> {
            return localVarFp.promptAssetVersionControllerCreate(projectId, assetKey, createPromptAssetVersionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all versions for a specific asset within a project
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerFindAll(projectId: string, assetKey: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptAssetVersionDto>> {
            return localVarFp.promptAssetVersionControllerFindAll(projectId, assetKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag (e.g., v1.0.0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerFindOneByTag(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto> {
            return localVarFp.promptAssetVersionControllerFindOneByTag(projectId, assetKey, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerRemove(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetVersionControllerRemove(projectId, assetKey, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific asset version by its tag within a project/asset
         * @param {string} projectId Project ID
         * @param {string} assetKey Asset Key
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetVersionControllerUpdate(projectId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptAssetVersionDto> {
            return localVarFp.promptAssetVersionControllerUpdate(projectId, assetKey, versionTag, updatePromptAssetVersionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptAssetVersionsWithinProjectAssetApi - object-oriented interface
 * @export
 * @class PromptAssetVersionsWithinProjectAssetApi
 * @extends {BaseAPI}
 */
export class PromptAssetVersionsWithinProjectAssetApi extends BaseAPI {
    /**
     * 
     * @summary Create a new version for a specific asset within a project
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {CreatePromptAssetVersionDto} createPromptAssetVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApi
     */
    public promptAssetVersionControllerCreate(projectId: string, assetKey: string, createPromptAssetVersionDto: CreatePromptAssetVersionDto, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsWithinProjectAssetApiFp(this.configuration).promptAssetVersionControllerCreate(projectId, assetKey, createPromptAssetVersionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all versions for a specific asset within a project
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApi
     */
    public promptAssetVersionControllerFindAll(projectId: string, assetKey: string, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsWithinProjectAssetApiFp(this.configuration).promptAssetVersionControllerFindAll(projectId, assetKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific asset version by its tag within a project/asset
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version tag (e.g., v1.0.0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApi
     */
    public promptAssetVersionControllerFindOneByTag(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsWithinProjectAssetApiFp(this.configuration).promptAssetVersionControllerFindOneByTag(projectId, assetKey, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific asset version by its tag within a project/asset
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApi
     */
    public promptAssetVersionControllerRemove(projectId: string, assetKey: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsWithinProjectAssetApiFp(this.configuration).promptAssetVersionControllerRemove(projectId, assetKey, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific asset version by its tag within a project/asset
     * @param {string} projectId Project ID
     * @param {string} assetKey Asset Key
     * @param {string} versionTag Version tag to update
     * @param {UpdatePromptAssetVersionDto} updatePromptAssetVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetVersionsWithinProjectAssetApi
     */
    public promptAssetVersionControllerUpdate(projectId: string, assetKey: string, versionTag: string, updatePromptAssetVersionDto: UpdatePromptAssetVersionDto, options?: RawAxiosRequestConfig) {
        return PromptAssetVersionsWithinProjectAssetApiFp(this.configuration).promptAssetVersionControllerUpdate(projectId, assetKey, versionTag, updatePromptAssetVersionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptAssetsApi - axios parameter creator
 * @export
 */
export const PromptAssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crea un nuevo prompt asset (y su primera versión) dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreatePromptAssetDto} createPromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerCreate: async (projectId: string, createPromptAssetDto: CreatePromptAssetDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerCreate', 'projectId', projectId)
            // verify required parameter 'createPromptAssetDto' is not null or undefined
            assertParamExists('promptAssetControllerCreate', 'createPromptAssetDto', createPromptAssetDto)
            const localVarPath = `/api/projects/{projectId}/prompt-assets`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene todos los prompt assets de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompt-assets`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene un prompt asset por su key dentro de un proyecto
         * @param {string} assetKey Key única del asset dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerFindOne: async (assetKey: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetControllerFindOne', 'assetKey', assetKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompt-assets/{assetKey}`
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un proyecto
         * @param {string} assetKey Key única del asset a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerRemove: async (assetKey: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetControllerRemove', 'assetKey', assetKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompt-assets/{assetKey}`
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un proyecto
         * @param {string} assetKey Key única del asset a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdatePromptAssetDto} updatePromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerUpdate: async (assetKey: string, projectId: string, updatePromptAssetDto: UpdatePromptAssetDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetKey' is not null or undefined
            assertParamExists('promptAssetControllerUpdate', 'assetKey', assetKey)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptAssetControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updatePromptAssetDto' is not null or undefined
            assertParamExists('promptAssetControllerUpdate', 'updatePromptAssetDto', updatePromptAssetDto)
            const localVarPath = `/api/projects/{projectId}/prompt-assets/{assetKey}`
                .replace(`{${"assetKey"}}`, encodeURIComponent(String(assetKey)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptAssetsApi - functional programming interface
 * @export
 */
export const PromptAssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptAssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crea un nuevo prompt asset (y su primera versión) dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreatePromptAssetDto} createPromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerCreate(projectId: string, createPromptAssetDto: CreatePromptAssetDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerCreate(projectId, createPromptAssetDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsApi.promptAssetControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene todos los prompt assets de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsApi.promptAssetControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene un prompt asset por su key dentro de un proyecto
         * @param {string} assetKey Key única del asset dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerFindOne(assetKey: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerFindOne(assetKey, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsApi.promptAssetControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un proyecto
         * @param {string} assetKey Key única del asset a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerRemove(assetKey: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerRemove(assetKey, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsApi.promptAssetControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un proyecto
         * @param {string} assetKey Key única del asset a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdatePromptAssetDto} updatePromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptAssetControllerUpdate(assetKey: string, projectId: string, updatePromptAssetDto: UpdatePromptAssetDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptAssetControllerUpdate(assetKey, projectId, updatePromptAssetDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptAssetsApi.promptAssetControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptAssetsApi - factory interface
 * @export
 */
export const PromptAssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptAssetsApiFp(configuration)
    return {
        /**
         * 
         * @summary Crea un nuevo prompt asset (y su primera versión) dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreatePromptAssetDto} createPromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerCreate(projectId: string, createPromptAssetDto: CreatePromptAssetDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerCreate(projectId, createPromptAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene todos los prompt assets de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene un prompt asset por su key dentro de un proyecto
         * @param {string} assetKey Key única del asset dentro del proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerFindOne(assetKey: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerFindOne(assetKey, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un proyecto
         * @param {string} assetKey Key única del asset a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerRemove(assetKey: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerRemove(assetKey, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un proyecto
         * @param {string} assetKey Key única del asset a actualizar
         * @param {string} projectId ID del proyecto
         * @param {UpdatePromptAssetDto} updatePromptAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptAssetControllerUpdate(assetKey: string, projectId: string, updatePromptAssetDto: UpdatePromptAssetDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptAssetControllerUpdate(assetKey, projectId, updatePromptAssetDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptAssetsApi - object-oriented interface
 * @export
 * @class PromptAssetsApi
 * @extends {BaseAPI}
 */
export class PromptAssetsApi extends BaseAPI {
    /**
     * 
     * @summary Crea un nuevo prompt asset (y su primera versión) dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreatePromptAssetDto} createPromptAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApi
     */
    public promptAssetControllerCreate(projectId: string, createPromptAssetDto: CreatePromptAssetDto, options?: RawAxiosRequestConfig) {
        return PromptAssetsApiFp(this.configuration).promptAssetControllerCreate(projectId, createPromptAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene todos los prompt assets de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApi
     */
    public promptAssetControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetsApiFp(this.configuration).promptAssetControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene un prompt asset por su key dentro de un proyecto
     * @param {string} assetKey Key única del asset dentro del proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApi
     */
    public promptAssetControllerFindOne(assetKey: string, projectId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetsApiFp(this.configuration).promptAssetControllerFindOne(assetKey, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Elimina un prompt asset (y sus versiones/traducciones por Cascade) dentro de un proyecto
     * @param {string} assetKey Key única del asset a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApi
     */
    public promptAssetControllerRemove(assetKey: string, projectId: string, options?: RawAxiosRequestConfig) {
        return PromptAssetsApiFp(this.configuration).promptAssetControllerRemove(assetKey, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualiza metadatos de un prompt asset (nombre, descripción, etc.) dentro de un proyecto
     * @param {string} assetKey Key única del asset a actualizar
     * @param {string} projectId ID del proyecto
     * @param {UpdatePromptAssetDto} updatePromptAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptAssetsApi
     */
    public promptAssetControllerUpdate(assetKey: string, projectId: string, updatePromptAssetDto: UpdatePromptAssetDto, options?: RawAxiosRequestConfig) {
        return PromptAssetsApiFp(this.configuration).promptAssetControllerUpdate(assetKey, projectId, updatePromptAssetDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptTranslationsWithinProjectPromptVersionApi - axios parameter creator
 * @export
 */
export const PromptTranslationsWithinProjectPromptVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a translation for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {CreatePromptTranslationDto} createPromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerCreate: async (projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerCreate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerCreate', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerCreate', 'versionTag', versionTag)
            // verify required parameter 'createPromptTranslationDto' is not null or undefined
            assertParamExists('promptTranslationControllerCreate', 'createPromptTranslationDto', createPromptTranslationDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all translations for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerFindAll: async (projectId: string, promptId: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerFindAll', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerFindAll', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerFindAll', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerFindOneByLanguage: async (projectId: string, promptId: string, versionTag: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerFindOneByLanguage', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerFindOneByLanguage', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerFindOneByLanguage', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('promptTranslationControllerFindOneByLanguage', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerRemove: async (projectId: string, promptId: string, versionTag: string, languageCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerRemove', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerRemove', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerRemove', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('promptTranslationControllerRemove', 'languageCode', languageCode)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerUpdate: async (projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'versionTag', versionTag)
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'languageCode', languageCode)
            // verify required parameter 'updatePromptTranslationDto' is not null or undefined
            assertParamExists('promptTranslationControllerUpdate', 'updatePromptTranslationDto', updatePromptTranslationDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}/translations/{languageCode}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)))
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptTranslationsWithinProjectPromptVersionApi - functional programming interface
 * @export
 */
export const PromptTranslationsWithinProjectPromptVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptTranslationsWithinProjectPromptVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a translation for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {CreatePromptTranslationDto} createPromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerCreate(projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerCreate(projectId, promptId, versionTag, createPromptTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all translations for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerFindAll(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptTranslationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerFindAll(projectId, promptId, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerFindOneByLanguage(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerFindOneByLanguage(projectId, promptId, versionTag, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerFindOneByLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerRemove(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerRemove(projectId, promptId, versionTag, languageCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptTranslationControllerUpdate(projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptTranslationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptTranslationControllerUpdate(projectId, promptId, versionTag, languageCode, updatePromptTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptTranslationsWithinProjectPromptVersionApi.promptTranslationControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptTranslationsWithinProjectPromptVersionApi - factory interface
 * @export
 */
export const PromptTranslationsWithinProjectPromptVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptTranslationsWithinProjectPromptVersionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a translation for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {CreatePromptTranslationDto} createPromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerCreate(projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptTranslationDto> {
            return localVarFp.promptTranslationControllerCreate(projectId, promptId, versionTag, createPromptTranslationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all translations for a specific prompt version within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerFindAll(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptTranslationDto>> {
            return localVarFp.promptTranslationControllerFindAll(projectId, promptId, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code (e.g., es-ES)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerFindOneByLanguage(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptTranslationDto> {
            return localVarFp.promptTranslationControllerFindOneByLanguage(projectId, promptId, versionTag, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerRemove(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptTranslationControllerRemove(projectId, promptId, versionTag, languageCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific translation by language code for a prompt version
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version Tag
         * @param {string} languageCode Language code of the translation to update
         * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptTranslationControllerUpdate(projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptTranslationDto> {
            return localVarFp.promptTranslationControllerUpdate(projectId, promptId, versionTag, languageCode, updatePromptTranslationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptTranslationsWithinProjectPromptVersionApi - object-oriented interface
 * @export
 * @class PromptTranslationsWithinProjectPromptVersionApi
 * @extends {BaseAPI}
 */
export class PromptTranslationsWithinProjectPromptVersionApi extends BaseAPI {
    /**
     * 
     * @summary Create a translation for a specific prompt version within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {CreatePromptTranslationDto} createPromptTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerCreate(projectId: string, promptId: string, versionTag: string, createPromptTranslationDto: CreatePromptTranslationDto, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerCreate(projectId, promptId, versionTag, createPromptTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all translations for a specific prompt version within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerFindAll(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerFindAll(projectId, promptId, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific translation by language code for a prompt version
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code (e.g., es-ES)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerFindOneByLanguage(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerFindOneByLanguage(projectId, promptId, versionTag, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific translation by language code for a prompt version
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code of the translation to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerRemove(projectId: string, promptId: string, versionTag: string, languageCode: string, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerRemove(projectId, promptId, versionTag, languageCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific translation by language code for a prompt version
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version Tag
     * @param {string} languageCode Language code of the translation to update
     * @param {UpdatePromptTranslationDto} updatePromptTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptTranslationsWithinProjectPromptVersionApi
     */
    public promptTranslationControllerUpdate(projectId: string, promptId: string, versionTag: string, languageCode: string, updatePromptTranslationDto: UpdatePromptTranslationDto, options?: RawAxiosRequestConfig) {
        return PromptTranslationsWithinProjectPromptVersionApiFp(this.configuration).promptTranslationControllerUpdate(projectId, promptId, versionTag, languageCode, updatePromptTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptVersionsWithinProjectPromptApi - axios parameter creator
 * @export
 */
export const PromptVersionsWithinProjectPromptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new version for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {CreatePromptVersionDto} createPromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerCreate: async (projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerCreate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerCreate', 'promptId', promptId)
            // verify required parameter 'createPromptVersionDto' is not null or undefined
            assertParamExists('promptVersionControllerCreate', 'createPromptVersionDto', createPromptVersionDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all versions for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerFindAll: async (projectId: string, promptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerFindAll', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerFindAll', 'promptId', promptId)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag (e.g., v1.0.0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerFindOneByTag: async (projectId: string, promptId: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerFindOneByTag', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerFindOneByTag', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptVersionControllerFindOneByTag', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerRemove: async (projectId: string, promptId: string, versionTag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerRemove', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerRemove', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptVersionControllerRemove', 'versionTag', versionTag)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptVersionDto} updatePromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerUpdate: async (projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptVersionControllerUpdate', 'projectId', projectId)
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('promptVersionControllerUpdate', 'promptId', promptId)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('promptVersionControllerUpdate', 'versionTag', versionTag)
            // verify required parameter 'updatePromptVersionDto' is not null or undefined
            assertParamExists('promptVersionControllerUpdate', 'updatePromptVersionDto', updatePromptVersionDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptId}/versions/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptId"}}`, encodeURIComponent(String(promptId)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptVersionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptVersionsWithinProjectPromptApi - functional programming interface
 * @export
 */
export const PromptVersionsWithinProjectPromptApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptVersionsWithinProjectPromptApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new version for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {CreatePromptVersionDto} createPromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerCreate(projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerCreate(projectId, promptId, createPromptVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all versions for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerFindAll(projectId: string, promptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptVersionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerFindAll(projectId, promptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag (e.g., v1.0.0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerFindOneByTag(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerFindOneByTag(projectId, promptId, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerFindOneByTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerRemove(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerRemove(projectId, promptId, versionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptVersionDto} updatePromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptVersionControllerUpdate(projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptVersionControllerUpdate(projectId, promptId, versionTag, updatePromptVersionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptVersionsWithinProjectPromptApi.promptVersionControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptVersionsWithinProjectPromptApi - factory interface
 * @export
 */
export const PromptVersionsWithinProjectPromptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptVersionsWithinProjectPromptApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new version for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {CreatePromptVersionDto} createPromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerCreate(projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto> {
            return localVarFp.promptVersionControllerCreate(projectId, promptId, createPromptVersionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all versions for a specific prompt within a project
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerFindAll(projectId: string, promptId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptVersionDto>> {
            return localVarFp.promptVersionControllerFindAll(projectId, promptId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag (e.g., v1.0.0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerFindOneByTag(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto> {
            return localVarFp.promptVersionControllerFindOneByTag(projectId, promptId, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerRemove(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptVersionControllerRemove(projectId, promptId, versionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific prompt version by its tag within a project/prompt
         * @param {string} projectId Project ID
         * @param {string} promptId Prompt CUID
         * @param {string} versionTag Version tag to update
         * @param {UpdatePromptVersionDto} updatePromptVersionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptVersionControllerUpdate(projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptVersionDto> {
            return localVarFp.promptVersionControllerUpdate(projectId, promptId, versionTag, updatePromptVersionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptVersionsWithinProjectPromptApi - object-oriented interface
 * @export
 * @class PromptVersionsWithinProjectPromptApi
 * @extends {BaseAPI}
 */
export class PromptVersionsWithinProjectPromptApi extends BaseAPI {
    /**
     * 
     * @summary Create a new version for a specific prompt within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {CreatePromptVersionDto} createPromptVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerCreate(projectId: string, promptId: string, createPromptVersionDto: CreatePromptVersionDto, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerCreate(projectId, promptId, createPromptVersionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all versions for a specific prompt within a project
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerFindAll(projectId: string, promptId: string, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerFindAll(projectId, promptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific prompt version by its tag within a project/prompt
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version tag (e.g., v1.0.0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerFindOneByTag(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerFindOneByTag(projectId, promptId, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific prompt version by its tag within a project/prompt
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerRemove(projectId: string, promptId: string, versionTag: string, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerRemove(projectId, promptId, versionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific prompt version by its tag within a project/prompt
     * @param {string} projectId Project ID
     * @param {string} promptId Prompt CUID
     * @param {string} versionTag Version tag to update
     * @param {UpdatePromptVersionDto} updatePromptVersionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptVersionsWithinProjectPromptApi
     */
    public promptVersionControllerUpdate(projectId: string, promptId: string, versionTag: string, updatePromptVersionDto: UpdatePromptVersionDto, options?: RawAxiosRequestConfig) {
        return PromptVersionsWithinProjectPromptApiFp(this.configuration).promptVersionControllerUpdate(projectId, promptId, versionTag, updatePromptVersionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptsApi - axios parameter creator
 * @export
 */
export const PromptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds or updates a translation for a specific prompt version in the project.
         * @param {string} versionId ID of the version to translate (CUID)
         * @param {string} promptName Parent prompt name (contextual)
         * @param {string} projectId Project ID
         * @param {CreateOrUpdatePromptTranslationDto} createOrUpdatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerAddOrUpdateTranslation: async (versionId: string, promptName: string, projectId: string, createOrUpdatePromptTranslationDto: CreateOrUpdatePromptTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('promptControllerAddOrUpdateTranslation', 'versionId', versionId)
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('promptControllerAddOrUpdateTranslation', 'promptName', promptName)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerAddOrUpdateTranslation', 'projectId', projectId)
            // verify required parameter 'createOrUpdatePromptTranslationDto' is not null or undefined
            assertParamExists('promptControllerAddOrUpdateTranslation', 'createOrUpdatePromptTranslationDto', createOrUpdatePromptTranslationDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptName}/versions/{versionId}/translations`
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)))
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdatePromptTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new logical prompt within a project
         * @param {string} projectId Project ID
         * @param {CreatePromptDto} createPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerCreate: async (projectId: string, createPromptDto: CreatePromptDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerCreate', 'projectId', projectId)
            // verify required parameter 'createPromptDto' is not null or undefined
            assertParamExists('promptControllerCreate', 'createPromptDto', createPromptDto)
            const localVarPath = `/api/projects/{projectId}/prompts`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all logical prompts for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompts`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a logical prompt by its name within a project
         * @param {string} promptName Unique name of the prompt within the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerFindOne: async (promptName: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('promptControllerFindOne', 'promptName', promptName)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptName}`
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a logical prompt (and its associated versions via Cascade) within a project by name
         * @param {string} promptName Name of the prompt to delete
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerRemove: async (promptName: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('promptControllerRemove', 'promptName', promptName)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptName}`
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing prompt by its name for a specific project
         * @param {string} promptName Name of the prompt to update
         * @param {string} projectId Project ID
         * @param {UpdatePromptDto} updatePromptDto Data to update the prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerUpdate: async (promptName: string, projectId: string, updatePromptDto: UpdatePromptDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('promptControllerUpdate', 'promptName', promptName)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('promptControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updatePromptDto' is not null or undefined
            assertParamExists('promptControllerUpdate', 'updatePromptDto', updatePromptDto)
            const localVarPath = `/api/projects/{projectId}/prompts/{promptName}`
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePromptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptsApi - functional programming interface
 * @export
 */
export const PromptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds or updates a translation for a specific prompt version in the project.
         * @param {string} versionId ID of the version to translate (CUID)
         * @param {string} promptName Parent prompt name (contextual)
         * @param {string} projectId Project ID
         * @param {CreateOrUpdatePromptTranslationDto} createOrUpdatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerAddOrUpdateTranslation(versionId: string, promptName: string, projectId: string, createOrUpdatePromptTranslationDto: CreateOrUpdatePromptTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerAddOrUpdateTranslation(versionId, promptName, projectId, createOrUpdatePromptTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerAddOrUpdateTranslation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a new logical prompt within a project
         * @param {string} projectId Project ID
         * @param {CreatePromptDto} createPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerCreate(projectId: string, createPromptDto: CreatePromptDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerCreate(projectId, createPromptDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets all logical prompts for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreatePromptDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a logical prompt by its name within a project
         * @param {string} promptName Unique name of the prompt within the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerFindOne(promptName: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePromptDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerFindOne(promptName, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a logical prompt (and its associated versions via Cascade) within a project by name
         * @param {string} promptName Name of the prompt to delete
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerRemove(promptName: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerRemove(promptName, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an existing prompt by its name for a specific project
         * @param {string} promptName Name of the prompt to update
         * @param {string} projectId Project ID
         * @param {UpdatePromptDto} updatePromptDto Data to update the prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promptControllerUpdate(promptName: string, projectId: string, updatePromptDto: UpdatePromptDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promptControllerUpdate(promptName, projectId, updatePromptDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.promptControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptsApi - factory interface
 * @export
 */
export const PromptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptsApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds or updates a translation for a specific prompt version in the project.
         * @param {string} versionId ID of the version to translate (CUID)
         * @param {string} promptName Parent prompt name (contextual)
         * @param {string} projectId Project ID
         * @param {CreateOrUpdatePromptTranslationDto} createOrUpdatePromptTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerAddOrUpdateTranslation(versionId: string, promptName: string, projectId: string, createOrUpdatePromptTranslationDto: CreateOrUpdatePromptTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptControllerAddOrUpdateTranslation(versionId, promptName, projectId, createOrUpdatePromptTranslationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new logical prompt within a project
         * @param {string} projectId Project ID
         * @param {CreatePromptDto} createPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerCreate(projectId: string, createPromptDto: CreatePromptDto, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptDto> {
            return localVarFp.promptControllerCreate(projectId, createPromptDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all logical prompts for a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreatePromptDto>> {
            return localVarFp.promptControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a logical prompt by its name within a project
         * @param {string} promptName Unique name of the prompt within the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerFindOne(promptName: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePromptDto> {
            return localVarFp.promptControllerFindOne(promptName, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a logical prompt (and its associated versions via Cascade) within a project by name
         * @param {string} promptName Name of the prompt to delete
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerRemove(promptName: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptControllerRemove(promptName, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an existing prompt by its name for a specific project
         * @param {string} promptName Name of the prompt to update
         * @param {string} projectId Project ID
         * @param {UpdatePromptDto} updatePromptDto Data to update the prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promptControllerUpdate(promptName: string, projectId: string, updatePromptDto: UpdatePromptDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.promptControllerUpdate(promptName, projectId, updatePromptDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptsApi - object-oriented interface
 * @export
 * @class PromptsApi
 * @extends {BaseAPI}
 */
export class PromptsApi extends BaseAPI {
    /**
     * 
     * @summary Adds or updates a translation for a specific prompt version in the project.
     * @param {string} versionId ID of the version to translate (CUID)
     * @param {string} promptName Parent prompt name (contextual)
     * @param {string} projectId Project ID
     * @param {CreateOrUpdatePromptTranslationDto} createOrUpdatePromptTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerAddOrUpdateTranslation(versionId: string, promptName: string, projectId: string, createOrUpdatePromptTranslationDto: CreateOrUpdatePromptTranslationDto, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerAddOrUpdateTranslation(versionId, promptName, projectId, createOrUpdatePromptTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new logical prompt within a project
     * @param {string} projectId Project ID
     * @param {CreatePromptDto} createPromptDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerCreate(projectId: string, createPromptDto: CreatePromptDto, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerCreate(projectId, createPromptDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all logical prompts for a project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a logical prompt by its name within a project
     * @param {string} promptName Unique name of the prompt within the project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerFindOne(promptName: string, projectId: string, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerFindOne(promptName, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a logical prompt (and its associated versions via Cascade) within a project by name
     * @param {string} promptName Name of the prompt to delete
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerRemove(promptName: string, projectId: string, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerRemove(promptName, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an existing prompt by its name for a specific project
     * @param {string} promptName Name of the prompt to update
     * @param {string} projectId Project ID
     * @param {UpdatePromptDto} updatePromptDto Data to update the prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public promptControllerUpdate(promptName: string, projectId: string, updatePromptDto: UpdatePromptDto, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).promptControllerUpdate(promptName, projectId, updatePromptDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RAGDocumentMetadataApi - axios parameter creator
 * @export
 */
export const RAGDocumentMetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crear metadatos para un documento RAG dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerCreate: async (projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerCreate', 'projectId', projectId)
            // verify required parameter 'createRagDocumentMetadataDto' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerCreate', 'createRagDocumentMetadataDto', createRagDocumentMetadataDto)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRagDocumentMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener todos los metadatos de documentos RAG de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID de los metadatos (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerFindOne: async (metadataId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerFindOne', 'metadataId', metadataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata/{metadataId}`
                .replace(`{${"metadataId"}}`, encodeURIComponent(String(metadataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Eliminar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerRemove: async (metadataId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerRemove', 'metadataId', metadataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata/{metadataId}`
                .replace(`{${"metadataId"}}`, encodeURIComponent(String(metadataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualizar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a actualizar
         * @param {string} projectId ID del proyecto
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerUpdate: async (metadataId: string, projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerUpdate', 'metadataId', metadataId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerUpdate', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ragDocumentMetadataControllerUpdate', 'body', body)
            const localVarPath = `/api/projects/{projectId}/rag-document-metadata/{metadataId}`
                .replace(`{${"metadataId"}}`, encodeURIComponent(String(metadataId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RAGDocumentMetadataApi - functional programming interface
 * @export
 */
export const RAGDocumentMetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RAGDocumentMetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crear metadatos para un documento RAG dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerCreate(projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RagDocumentMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerCreate(projectId, createRagDocumentMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtener todos los metadatos de documentos RAG de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RagDocumentMetadataResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtener metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID de los metadatos (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerFindOne(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RagDocumentMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerFindOne(metadataId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Eliminar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerRemove(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerRemove(metadataId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualizar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a actualizar
         * @param {string} projectId ID del proyecto
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragDocumentMetadataControllerUpdate(metadataId: string, projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RagDocumentMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragDocumentMetadataControllerUpdate(metadataId, projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RAGDocumentMetadataApi.ragDocumentMetadataControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RAGDocumentMetadataApi - factory interface
 * @export
 */
export const RAGDocumentMetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RAGDocumentMetadataApiFp(configuration)
    return {
        /**
         * 
         * @summary Crear metadatos para un documento RAG dentro de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerCreate(projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<RagDocumentMetadataResponse> {
            return localVarFp.ragDocumentMetadataControllerCreate(projectId, createRagDocumentMetadataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtener todos los metadatos de documentos RAG de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RagDocumentMetadataResponse>> {
            return localVarFp.ragDocumentMetadataControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtener metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID de los metadatos (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerFindOne(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<RagDocumentMetadataResponse> {
            return localVarFp.ragDocumentMetadataControllerFindOne(metadataId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Eliminar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a eliminar
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerRemove(metadataId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ragDocumentMetadataControllerRemove(metadataId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualizar metadatos por ID dentro de un proyecto
         * @param {string} metadataId ID a actualizar
         * @param {string} projectId ID del proyecto
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragDocumentMetadataControllerUpdate(metadataId: string, projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<RagDocumentMetadataResponse> {
            return localVarFp.ragDocumentMetadataControllerUpdate(metadataId, projectId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RAGDocumentMetadataApi - object-oriented interface
 * @export
 * @class RAGDocumentMetadataApi
 * @extends {BaseAPI}
 */
export class RAGDocumentMetadataApi extends BaseAPI {
    /**
     * 
     * @summary Crear metadatos para un documento RAG dentro de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateRagDocumentMetadataDto} createRagDocumentMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerCreate(projectId: string, createRagDocumentMetadataDto: CreateRagDocumentMetadataDto, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerCreate(projectId, createRagDocumentMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtener todos los metadatos de documentos RAG de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtener metadatos por ID dentro de un proyecto
     * @param {string} metadataId ID de los metadatos (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerFindOne(metadataId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerFindOne(metadataId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Eliminar metadatos por ID dentro de un proyecto
     * @param {string} metadataId ID a eliminar
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerRemove(metadataId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerRemove(metadataId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualizar metadatos por ID dentro de un proyecto
     * @param {string} metadataId ID a actualizar
     * @param {string} projectId ID del proyecto
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RAGDocumentMetadataApi
     */
    public ragDocumentMetadataControllerUpdate(metadataId: string, projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return RAGDocumentMetadataApiFp(this.configuration).ragDocumentMetadataControllerUpdate(metadataId, projectId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RawExecutionApi - axios parameter creator
 * @export
 */
export const RawExecutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Executes raw text using a specified System Prompt and AI Model ID.
         * @param {ExecuteRawDto} executeRawDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawExecutionControllerExecuteRawText: async (executeRawDto: ExecuteRawDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'executeRawDto' is not null or undefined
            assertParamExists('rawExecutionControllerExecuteRawText', 'executeRawDto', executeRawDto)
            const localVarPath = `/api/execute-raw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeRawDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RawExecutionApi - functional programming interface
 * @export
 */
export const RawExecutionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RawExecutionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Executes raw text using a specified System Prompt and AI Model ID.
         * @param {ExecuteRawDto} executeRawDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rawExecutionControllerExecuteRawText(executeRawDto: ExecuteRawDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rawExecutionControllerExecuteRawText(executeRawDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RawExecutionApi.rawExecutionControllerExecuteRawText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RawExecutionApi - factory interface
 * @export
 */
export const RawExecutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RawExecutionApiFp(configuration)
    return {
        /**
         * 
         * @summary Executes raw text using a specified System Prompt and AI Model ID.
         * @param {ExecuteRawDto} executeRawDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawExecutionControllerExecuteRawText(executeRawDto: ExecuteRawDto, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.rawExecutionControllerExecuteRawText(executeRawDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RawExecutionApi - object-oriented interface
 * @export
 * @class RawExecutionApi
 * @extends {BaseAPI}
 */
export class RawExecutionApi extends BaseAPI {
    /**
     * 
     * @summary Executes raw text using a specified System Prompt and AI Model ID.
     * @param {ExecuteRawDto} executeRawDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExecutionApi
     */
    public rawExecutionControllerExecuteRawText(executeRawDto: ExecuteRawDto, options?: RawAxiosRequestConfig) {
        return RawExecutionApiFp(this.configuration).rawExecutionControllerExecuteRawText(executeRawDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RegionsApi - axios parameter creator
 * @export
 */
export const RegionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new region for a specific project
         * @param {string} projectId Project ID
         * @param {CreateRegionDto} createRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerCreate: async (projectId: string, createRegionDto: CreateRegionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerCreate', 'projectId', projectId)
            // verify required parameter 'createRegionDto' is not null or undefined
            assertParamExists('regionControllerCreate', 'createRegionDto', createRegionDto)
            const localVarPath = `/api/projects/{projectId}/regions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRegionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all regions for a specific project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/regions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a specific region within a project
         * @param {string} languageCode Language code (ID) of the region
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerFindOne: async (languageCode: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('regionControllerFindOne', 'languageCode', languageCode)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/regions/{languageCode}`
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a specific region within a project
         * @param {string} languageCode Language code (ID) of the region to delete
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerRemove: async (languageCode: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('regionControllerRemove', 'languageCode', languageCode)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/regions/{languageCode}`
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific region within a project
         * @param {string} languageCode Language code (ID) of the region to update
         * @param {string} projectId Project ID
         * @param {UpdateRegionDto} updateRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerUpdate: async (languageCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageCode' is not null or undefined
            assertParamExists('regionControllerUpdate', 'languageCode', languageCode)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regionControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateRegionDto' is not null or undefined
            assertParamExists('regionControllerUpdate', 'updateRegionDto', updateRegionDto)
            const localVarPath = `/api/projects/{projectId}/regions/{languageCode}`
                .replace(`{${"languageCode"}}`, encodeURIComponent(String(languageCode)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRegionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegionsApi - functional programming interface
 * @export
 */
export const RegionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new region for a specific project
         * @param {string} projectId Project ID
         * @param {CreateRegionDto} createRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerCreate(projectId: string, createRegionDto: CreateRegionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRegionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerCreate(projectId, createRegionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets all regions for a specific project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateRegionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a specific region within a project
         * @param {string} languageCode Language code (ID) of the region
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerFindOne(languageCode: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRegionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerFindOne(languageCode, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a specific region within a project
         * @param {string} languageCode Language code (ID) of the region to delete
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerRemove(languageCode: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerRemove(languageCode, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific region within a project
         * @param {string} languageCode Language code (ID) of the region to update
         * @param {string} projectId Project ID
         * @param {UpdateRegionDto} updateRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionControllerUpdate(languageCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRegionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionControllerUpdate(languageCode, projectId, updateRegionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionsApi.regionControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RegionsApi - factory interface
 * @export
 */
export const RegionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new region for a specific project
         * @param {string} projectId Project ID
         * @param {CreateRegionDto} createRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerCreate(projectId: string, createRegionDto: CreateRegionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateRegionDto> {
            return localVarFp.regionControllerCreate(projectId, createRegionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all regions for a specific project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateRegionDto>> {
            return localVarFp.regionControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a specific region within a project
         * @param {string} languageCode Language code (ID) of the region
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerFindOne(languageCode: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateRegionDto> {
            return localVarFp.regionControllerFindOne(languageCode, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a specific region within a project
         * @param {string} languageCode Language code (ID) of the region to delete
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerRemove(languageCode: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.regionControllerRemove(languageCode, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific region within a project
         * @param {string} languageCode Language code (ID) of the region to update
         * @param {string} projectId Project ID
         * @param {UpdateRegionDto} updateRegionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionControllerUpdate(languageCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateRegionDto> {
            return localVarFp.regionControllerUpdate(languageCode, projectId, updateRegionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegionsApi - object-oriented interface
 * @export
 * @class RegionsApi
 * @extends {BaseAPI}
 */
export class RegionsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new region for a specific project
     * @param {string} projectId Project ID
     * @param {CreateRegionDto} createRegionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerCreate(projectId: string, createRegionDto: CreateRegionDto, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerCreate(projectId, createRegionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all regions for a specific project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a specific region within a project
     * @param {string} languageCode Language code (ID) of the region
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerFindOne(languageCode: string, projectId: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerFindOne(languageCode, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a specific region within a project
     * @param {string} languageCode Language code (ID) of the region to delete
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerRemove(languageCode: string, projectId: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerRemove(languageCode, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific region within a project
     * @param {string} languageCode Language code (ID) of the region to update
     * @param {string} projectId Project ID
     * @param {UpdateRegionDto} updateRegionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionControllerUpdate(languageCode: string, projectId: string, updateRegionDto: UpdateRegionDto, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionControllerUpdate(languageCode, projectId, updateRegionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServePromptApi - axios parameter creator
 * @export
 */
export const ServePromptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assembles and prepares a specific prompt version for execution with provided variables
         * @param {string} projectId Project ID
         * @param {string} promptName The unique name of the prompt within the project
         * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;)
         * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
         * @param {string} [languageCode] Optional language code for translation (e.g., \&quot;es\&quot;)
         * @param {string} [environmentName] Optional environment context (currently informational)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servePromptControllerExecutePrompt: async (projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, languageCode?: string, environmentName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('servePromptControllerExecutePrompt', 'projectId', projectId)
            // verify required parameter 'promptName' is not null or undefined
            assertParamExists('servePromptControllerExecutePrompt', 'promptName', promptName)
            // verify required parameter 'versionTag' is not null or undefined
            assertParamExists('servePromptControllerExecutePrompt', 'versionTag', versionTag)
            // verify required parameter 'executePromptBodyDto' is not null or undefined
            assertParamExists('servePromptControllerExecutePrompt', 'executePromptBodyDto', executePromptBodyDto)
            const localVarPath = `/serve-prompt/execute/{projectId}/{promptName}/{versionTag}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"promptName"}}`, encodeURIComponent(String(promptName)))
                .replace(`{${"versionTag"}}`, encodeURIComponent(String(versionTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (languageCode !== undefined) {
                localVarQueryParameter['languageCode'] = languageCode;
            }

            if (environmentName !== undefined) {
                localVarQueryParameter['environmentName'] = environmentName;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executePromptBodyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServePromptApi - functional programming interface
 * @export
 */
export const ServePromptApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServePromptApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assembles and prepares a specific prompt version for execution with provided variables
         * @param {string} projectId Project ID
         * @param {string} promptName The unique name of the prompt within the project
         * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;)
         * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
         * @param {string} [languageCode] Optional language code for translation (e.g., \&quot;es\&quot;)
         * @param {string} [environmentName] Optional environment context (currently informational)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servePromptControllerExecutePrompt(projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, languageCode?: string, environmentName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servePromptControllerExecutePrompt(projectId, promptName, versionTag, executePromptBodyDto, languageCode, environmentName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServePromptApi.servePromptControllerExecutePrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServePromptApi - factory interface
 * @export
 */
export const ServePromptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServePromptApiFp(configuration)
    return {
        /**
         * 
         * @summary Assembles and prepares a specific prompt version for execution with provided variables
         * @param {string} projectId Project ID
         * @param {string} promptName The unique name of the prompt within the project
         * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;)
         * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
         * @param {string} [languageCode] Optional language code for translation (e.g., \&quot;es\&quot;)
         * @param {string} [environmentName] Optional environment context (currently informational)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servePromptControllerExecutePrompt(projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, languageCode?: string, environmentName?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.servePromptControllerExecutePrompt(projectId, promptName, versionTag, executePromptBodyDto, languageCode, environmentName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServePromptApi - object-oriented interface
 * @export
 * @class ServePromptApi
 * @extends {BaseAPI}
 */
export class ServePromptApi extends BaseAPI {
    /**
     * 
     * @summary Assembles and prepares a specific prompt version for execution with provided variables
     * @param {string} projectId Project ID
     * @param {string} promptName The unique name of the prompt within the project
     * @param {string} versionTag Specific version tag (e.g., \&quot;v1.2.0\&quot;)
     * @param {ExecutePromptBodyDto} executePromptBodyDto Input variables for the prompt
     * @param {string} [languageCode] Optional language code for translation (e.g., \&quot;es\&quot;)
     * @param {string} [environmentName] Optional environment context (currently informational)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServePromptApi
     */
    public servePromptControllerExecutePrompt(projectId: string, promptName: string, versionTag: string, executePromptBodyDto: ExecutePromptBodyDto, languageCode?: string, environmentName?: string, options?: RawAxiosRequestConfig) {
        return ServePromptApiFp(this.configuration).servePromptControllerExecutePrompt(projectId, promptName, versionTag, executePromptBodyDto, languageCode, environmentName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemPromptsApi - axios parameter creator
 * @export
 */
export const SystemPromptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new system prompt (Admin Only - conceptually)
         * @param {CreateSystemPromptDto} createSystemPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerCreate: async (createSystemPromptDto: CreateSystemPromptDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSystemPromptDto' is not null or undefined
            assertParamExists('systemPromptControllerCreate', 'createSystemPromptDto', createSystemPromptDto)
            const localVarPath = `/api/system-prompts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSystemPromptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all system prompts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/system-prompts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific system prompt by name
         * @param {string} name Unique name of the system prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerFindOne: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('systemPromptControllerFindOne', 'name', name)
            const localVarPath = `/api/system-prompts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a system prompt (Admin Only - conceptually)
         * @param {string} name Unique name of the system prompt to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerRemove: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('systemPromptControllerRemove', 'name', name)
            const localVarPath = `/api/system-prompts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing system prompt (Admin Only - conceptually)
         * @param {string} name Unique name of the system prompt to update
         * @param {UpdateSystemPromptDto} updateSystemPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerUpdate: async (name: string, updateSystemPromptDto: UpdateSystemPromptDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('systemPromptControllerUpdate', 'name', name)
            // verify required parameter 'updateSystemPromptDto' is not null or undefined
            assertParamExists('systemPromptControllerUpdate', 'updateSystemPromptDto', updateSystemPromptDto)
            const localVarPath = `/api/system-prompts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSystemPromptDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemPromptsApi - functional programming interface
 * @export
 */
export const SystemPromptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemPromptsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new system prompt (Admin Only - conceptually)
         * @param {CreateSystemPromptDto} createSystemPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPromptControllerCreate(createSystemPromptDto: CreateSystemPromptDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPromptControllerCreate(createSystemPromptDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemPromptsApi.systemPromptControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all system prompts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPromptControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPromptControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemPromptsApi.systemPromptControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific system prompt by name
         * @param {string} name Unique name of the system prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPromptControllerFindOne(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPromptControllerFindOne(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemPromptsApi.systemPromptControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a system prompt (Admin Only - conceptually)
         * @param {string} name Unique name of the system prompt to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPromptControllerRemove(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPromptControllerRemove(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemPromptsApi.systemPromptControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing system prompt (Admin Only - conceptually)
         * @param {string} name Unique name of the system prompt to update
         * @param {UpdateSystemPromptDto} updateSystemPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPromptControllerUpdate(name: string, updateSystemPromptDto: UpdateSystemPromptDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPromptControllerUpdate(name, updateSystemPromptDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemPromptsApi.systemPromptControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemPromptsApi - factory interface
 * @export
 */
export const SystemPromptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemPromptsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new system prompt (Admin Only - conceptually)
         * @param {CreateSystemPromptDto} createSystemPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerCreate(createSystemPromptDto: CreateSystemPromptDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.systemPromptControllerCreate(createSystemPromptDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all system prompts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.systemPromptControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific system prompt by name
         * @param {string} name Unique name of the system prompt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerFindOne(name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.systemPromptControllerFindOne(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a system prompt (Admin Only - conceptually)
         * @param {string} name Unique name of the system prompt to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerRemove(name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.systemPromptControllerRemove(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing system prompt (Admin Only - conceptually)
         * @param {string} name Unique name of the system prompt to update
         * @param {UpdateSystemPromptDto} updateSystemPromptDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPromptControllerUpdate(name: string, updateSystemPromptDto: UpdateSystemPromptDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.systemPromptControllerUpdate(name, updateSystemPromptDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemPromptsApi - object-oriented interface
 * @export
 * @class SystemPromptsApi
 * @extends {BaseAPI}
 */
export class SystemPromptsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new system prompt (Admin Only - conceptually)
     * @param {CreateSystemPromptDto} createSystemPromptDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemPromptsApi
     */
    public systemPromptControllerCreate(createSystemPromptDto: CreateSystemPromptDto, options?: RawAxiosRequestConfig) {
        return SystemPromptsApiFp(this.configuration).systemPromptControllerCreate(createSystemPromptDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all system prompts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemPromptsApi
     */
    public systemPromptControllerFindAll(options?: RawAxiosRequestConfig) {
        return SystemPromptsApiFp(this.configuration).systemPromptControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific system prompt by name
     * @param {string} name Unique name of the system prompt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemPromptsApi
     */
    public systemPromptControllerFindOne(name: string, options?: RawAxiosRequestConfig) {
        return SystemPromptsApiFp(this.configuration).systemPromptControllerFindOne(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a system prompt (Admin Only - conceptually)
     * @param {string} name Unique name of the system prompt to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemPromptsApi
     */
    public systemPromptControllerRemove(name: string, options?: RawAxiosRequestConfig) {
        return SystemPromptsApiFp(this.configuration).systemPromptControllerRemove(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing system prompt (Admin Only - conceptually)
     * @param {string} name Unique name of the system prompt to update
     * @param {UpdateSystemPromptDto} updateSystemPromptDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemPromptsApi
     */
    public systemPromptControllerUpdate(name: string, updateSystemPromptDto: UpdateSystemPromptDto, options?: RawAxiosRequestConfig) {
        return SystemPromptsApiFp(this.configuration).systemPromptControllerUpdate(name, updateSystemPromptDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crea una nueva etiqueta para un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCreate: async (projectId: string, createTagDto: CreateTagDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerCreate', 'projectId', projectId)
            // verify required parameter 'createTagDto' is not null or undefined
            assertParamExists('tagControllerCreate', 'createTagDto', createTagDto)
            const localVarPath = `/api/projects/{projectId}/tags`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene todas las etiquetas de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerFindAll', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tags`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
         * @param {string} name Nombre único de la etiqueta en el proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindByName: async (name: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagControllerFindByName', 'name', name)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerFindByName', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tags/by-name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su ID dentro de un proyecto
         * @param {string} tagId ID único de la etiqueta (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindOne: async (tagId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagControllerFindOne', 'tagId', tagId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerFindOne', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Elimina una etiqueta de un proyecto
         * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerRemove: async (tagId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagControllerRemove', 'tagId', tagId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerRemove', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actualiza una etiqueta existente en un proyecto
         * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdate: async (tagId: string, projectId: string, updateTagDto: UpdateTagDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('tagControllerUpdate', 'tagId', tagId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('tagControllerUpdate', 'projectId', projectId)
            // verify required parameter 'updateTagDto' is not null or undefined
            assertParamExists('tagControllerUpdate', 'updateTagDto', updateTagDto)
            const localVarPath = `/api/projects/{projectId}/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crea una nueva etiqueta para un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerCreate(projectId: string, createTagDto: CreateTagDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerCreate(projectId, createTagDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene todas las etiquetas de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
         * @param {string} name Nombre único de la etiqueta en el proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerFindByName(name, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerFindByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su ID dentro de un proyecto
         * @param {string} tagId ID único de la etiqueta (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerFindOne(tagId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerFindOne(tagId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Elimina una etiqueta de un proyecto
         * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerRemove(tagId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerRemove(tagId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actualiza una etiqueta existente en un proyecto
         * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerUpdate(tagId: string, projectId: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerUpdate(tagId, projectId, updateTagDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Crea una nueva etiqueta para un proyecto
         * @param {string} projectId ID del proyecto
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCreate(projectId: string, createTagDto: CreateTagDto, options?: RawAxiosRequestConfig): AxiosPromise<TagDto> {
            return localVarFp.tagControllerCreate(projectId, createTagDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene todas las etiquetas de un proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TagDto>> {
            return localVarFp.tagControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
         * @param {string} name Nombre único de la etiqueta en el proyecto
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<TagDto> {
            return localVarFp.tagControllerFindByName(name, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtiene una etiqueta por su ID dentro de un proyecto
         * @param {string} tagId ID único de la etiqueta (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindOne(tagId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<TagDto> {
            return localVarFp.tagControllerFindOne(tagId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Elimina una etiqueta de un proyecto
         * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerRemove(tagId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<TagDto> {
            return localVarFp.tagControllerRemove(tagId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actualiza una etiqueta existente en un proyecto
         * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
         * @param {string} projectId ID del proyecto
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdate(tagId: string, projectId: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig): AxiosPromise<TagDto> {
            return localVarFp.tagControllerUpdate(tagId, projectId, updateTagDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @summary Crea una nueva etiqueta para un proyecto
     * @param {string} projectId ID del proyecto
     * @param {CreateTagDto} createTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerCreate(projectId: string, createTagDto: CreateTagDto, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerCreate(projectId, createTagDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene todas las etiquetas de un proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene una etiqueta por su nombre dentro de un proyecto
     * @param {string} name Nombre único de la etiqueta en el proyecto
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerFindByName(name: string, projectId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerFindByName(name, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtiene una etiqueta por su ID dentro de un proyecto
     * @param {string} tagId ID único de la etiqueta (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerFindOne(tagId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerFindOne(tagId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Elimina una etiqueta de un proyecto
     * @param {string} tagId ID único de la etiqueta a eliminar (CUID)
     * @param {string} projectId ID del proyecto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerRemove(tagId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerRemove(tagId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actualiza una etiqueta existente en un proyecto
     * @param {string} tagId ID único de la etiqueta a actualizar (CUID)
     * @param {string} projectId ID del proyecto
     * @param {UpdateTagDto} updateTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagControllerUpdate(tagId: string, projectId: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagControllerUpdate(tagId, projectId, updateTagDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate: async (createUserDto: CreateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('userControllerCreate', 'createUserDto', createUserDto)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user by ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerFindOne', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user by ID
         * @param {string} id ID of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerRemove', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user by ID
         * @param {string} id ID of the user to update
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userControllerUpdate', 'body', body)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerCreate(createUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateUserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user by ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user by ID
         * @param {string} id ID of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a user by ID
         * @param {string} id ID of the user to update
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdate(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto> {
            return localVarFp.userControllerCreate(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateUserDto>> {
            return localVarFp.userControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user by ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto> {
            return localVarFp.userControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user by ID
         * @param {string} id ID of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user by ID
         * @param {string} id ID of the user to update
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserDto> {
            return localVarFp.userControllerUpdate(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new user
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerCreate(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindAll(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user by ID
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user by ID
     * @param {string} id ID of the user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user by ID
     * @param {string} id ID of the user to update
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUpdate(id: string, body: object, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



